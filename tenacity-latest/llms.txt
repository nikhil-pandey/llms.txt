api.md

---

# API Reference

## Retry Main API

<div class="autofunction" data-noindex="">

tenacity.retry

</div>

<div class="autoclass" data-members="">

tenacity.Retrying

</div>

<div class="autoclass" data-members="">

tenacity.AsyncRetrying

</div>

<div class="autoclass" data-members="">

tenacity.tornadoweb.TornadoRetrying

</div>

<div class="autoclass" data-members="">

tenacity.RetryCallState

</div>

## After Functions

Those functions can be used as the <span class="title-ref">after</span> keyword argument of :py\`tenacity.retry\`.

<div class="automodule" data-members="">

tenacity.after

</div>

## Before Functions

Those functions can be used as the <span class="title-ref">before</span> keyword argument of :py\`tenacity.retry\`.

<div class="automodule" data-members="">

tenacity.before

</div>

## Before Sleep Functions

Those functions can be used as the <span class="title-ref">before\_sleep</span> keyword argument of :py\`tenacity.retry\`.

<div class="automodule" data-members="">

tenacity.before\_sleep

</div>

## Nap Functions

Those functions can be used as the <span class="title-ref">sleep</span> keyword argument of :py\`tenacity.retry\`.

<div class="automodule" data-members="">

tenacity.nap

</div>

## Retry Functions

Those functions can be used as the <span class="title-ref">retry</span> keyword argument of :py\`tenacity.retry\`.

<div class="automodule" data-members="">

tenacity.retry

</div>

## Stop Functions

Those functions can be used as the <span class="title-ref">stop</span> keyword argument of :py\`tenacity.retry\`.

<div class="automodule" data-members="">

tenacity.stop

</div>

## Wait Functions

Those functions can be used as the <span class="title-ref">wait</span> keyword argument of :py\`tenacity.retry\`.

<div class="automodule" data-members="">

tenacity.wait

</div>

---

changelog.md

---

# Changelog

<div class="release-notes">

</div>

---

index.md

---

# Tenacity

[![image](https://img.shields.io/pypi/v/tenacity.svg)](https://pypi.python.org/pypi/tenacity)

[![image](https://circleci.com/gh/jd/tenacity.svg?style=svg)](https://circleci.com/gh/jd/tenacity)

[![Mergify Status](https://img.shields.io/endpoint.svg?url=https://api.mergify.com/badges/jd/tenacity&style=flat)](https://mergify.io)

**Please refer to the** [tenacity documentation](https://tenacity.readthedocs.io/en/latest/) **for a better experience.**

Tenacity is an Apache 2.0 licensed general-purpose retrying library, written in Python, to simplify the task of adding retry behavior to just about anything. It originates from [a fork of retrying](https://github.com/rholder/retrying/issues/65) which is sadly no longer [maintained](https://julien.danjou.info/python-tenacity/). Tenacity isn't api compatible with retrying but adds significant new functionality and fixes a number of longstanding bugs.

The simplest use case is retrying a flaky function whenever an <span class="title-ref">Exception</span> occurs until a value is returned.

<div class="testcode">

import random from tenacity import retry

@retry def do\_something\_unreliable(): if random.randint(0, 10) \> 1: raise IOError("Broken sauce, everything is hosed\!\!\!111one") else: return "Awesome sauce\!"

print(do\_something\_unreliable())

</div>

<div class="testoutput" data-hide="">

Awesome sauce\!

</div>

<div class="toctree" hidden="" data-maxdepth="2">

changelog api

</div>

## Features

  - Generic Decorator API
  - Specify stop condition (i.e. limit by number of attempts)
  - Specify wait condition (i.e. exponential backoff sleeping between attempts)
  - Customize retrying on Exceptions
  - Customize retrying on expected returned result
  - Retry on coroutines
  - Retry code block with context manager

## Installation

To install *tenacity*, simply:

`` `bash     $ pip install tenacity   Examples ``\` ----------

### Basic Retry

<div class="testsetup">

import logging \# \# Note the following import is used for demonstration convenience only. \# Production code should always explicitly import the names it needs. \# from tenacity import \*

  - class MyException(Exception):  
    pass

</div>

As you saw above, the default behavior is to retry forever without waiting when an exception is raised.

<div class="testcode">

@retry def never\_gonna\_give\_you\_up(): print("Retry forever ignoring Exceptions, don't wait between retries") raise Exception

</div>

### Stopping

Let's be a little less persistent and set some boundaries, such as the number of attempts before giving up.

<div class="testcode">

@retry(stop=stop\_after\_attempt(7)) def stop\_after\_7\_attempts(): print("Stopping after 7 attempts") raise Exception

</div>

We don't have all day, so let's set a boundary for how long we should be retrying stuff.

<div class="testcode">

@retry(stop=stop\_after\_delay(10)) def stop\_after\_10\_s(): print("Stopping after 10 seconds") raise Exception

</div>

If you're on a tight deadline, and exceeding your delay time isn't ok, then you can give up on retries one attempt before you would exceed the delay.

<div class="testcode">

@retry(stop=stop\_before\_delay(10)) def stop\_before\_10\_s(): print("Stopping 1 attempt before 10 seconds") raise Exception

</div>

You can combine several stop conditions by using the <span class="title-ref">|</span> operator:

<div class="testcode">

@retry(stop=(stop\_after\_delay(10) | stop\_after\_attempt(5))) def stop\_after\_10\_s\_or\_5\_retries(): print("Stopping after 10 seconds or 5 retries") raise Exception

</div>

### Waiting before retrying

Most things don't like to be polled as fast as possible, so let's just wait 2 seconds between retries.

<div class="testcode">

@retry(wait=wait\_fixed(2)) def wait\_2\_s(): print("Wait 2 second between retries") raise Exception

</div>

Some things perform best with a bit of randomness injected.

<div class="testcode">

@retry(wait=wait\_random(min=1, max=2)) def wait\_random\_1\_to\_2\_s(): print("Randomly wait 1 to 2 seconds between retries") raise Exception

</div>

Then again, it's hard to beat exponential backoff when retrying distributed services and other remote endpoints.

<div class="testcode">

@retry(wait=wait\_exponential(multiplier=1, min=4, max=10)) def wait\_exponential\_1(): print("Wait 2^x \* 1 second between each retry starting with 4 seconds, then up to 10 seconds, then 10 seconds afterwards") raise Exception

</div>

Then again, it's also hard to beat combining fixed waits and jitter (to help avoid thundering herds) when retrying distributed services and other remote endpoints.

<div class="testcode">

@retry(wait=wait\_fixed(3) + wait\_random(0, 2)) def wait\_fixed\_jitter(): print("Wait at least 3 seconds, and add up to 2 seconds of random delay") raise Exception

</div>

When multiple processes are in contention for a shared resource, exponentially increasing jitter helps minimise collisions.

<div class="testcode">

@retry(wait=wait\_random\_exponential(multiplier=1, max=60)) def wait\_exponential\_jitter(): print("Randomly wait up to 2^x \* 1 seconds between each retry until the range reaches 60 seconds, then randomly up to 60 seconds afterwards") raise Exception

</div>

Sometimes it's necessary to build a chain of backoffs.

<div class="testcode">

  - @retry(wait=wait\_chain(\*\[wait\_fixed(3) for i in range(3)\] +  
    \[wait\_fixed(7) for i in range(2)\] + \[wait\_fixed(9)\]))

  - def wait\_fixed\_chained():  
    print("Wait 3s for 3 attempts, 7s for the next 2 attempts and 9s for all attempts thereafter") raise Exception

</div>

### Whether to retry

We have a few options for dealing with retries that raise specific or general exceptions, as in the cases here.

<div class="testcode">

  - class ClientError(Exception):  
    """Some type of client error."""

@retry(retry=retry\_if\_exception\_type(IOError)) def might\_io\_error(): print("Retry forever with no wait if an IOError occurs, raise any other errors") raise Exception

@retry(retry=retry\_if\_not\_exception\_type(ClientError)) def might\_client\_error(): print("Retry forever with no wait if any error other than ClientError occurs. Immediately raise ClientError.") raise Exception

</div>

We can also use the result of the function to alter the behavior of retrying.

<div class="testcode">

  - def is\_none\_p(value):  
    """Return True if value is None""" return value is None

@retry(retry=retry\_if\_result(is\_none\_p)) def might\_return\_none(): print("Retry with no wait if return value is None")

</div>

See also these methods:

<div class="testcode">

retry\_if\_exception retry\_if\_exception\_type retry\_if\_not\_exception\_type retry\_unless\_exception\_type retry\_if\_result retry\_if\_not\_result retry\_if\_exception\_message retry\_if\_not\_exception\_message retry\_any retry\_all

</div>

We can also combine several conditions:

<div class="testcode">

  - def is\_none\_p(value):  
    """Return True if value is None""" return value is None

@retry(retry=(retry\_if\_result(is\_none\_p) | retry\_if\_exception\_type())) def might\_return\_none(): print("Retry forever ignoring Exceptions with no wait if return value is None")

</div>

Any combination of stop, wait, etc. is also supported to give you the freedom to mix and match.

It's also possible to retry explicitly at any time by raising the <span class="title-ref">TryAgain</span> exception:

<div class="testcode">

@retry def do\_something(): result = something\_else() if result == 23: raise TryAgain

</div>

### Error Handling

Normally when your function fails its final time (and will not be retried again based on your settings), a <span class="title-ref">RetryError</span> is raised. The exception your code encountered will be shown somewhere in the *middle* of the stack trace.

If you would rather see the exception your code encountered at the *end* of the stack trace (where it is most visible), you can set <span class="title-ref">reraise=True</span>.

<div class="testcode">

@retry(reraise=True, stop=stop\_after\_attempt(3)) def raise\_my\_exception(): raise MyException("Fail")

  - try:  
    raise\_my\_exception()

  - except MyException:  
    \# timed out retrying pass

</div>

### Before and After Retry, and Logging

It's possible to execute an action before any attempt of calling the function by using the before callback function:

<div class="testcode">

import logging import sys

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

logger = logging.getLogger(\_\_name\_\_)

@retry(stop=stop\_after\_attempt(3), before=before\_log(logger, logging.DEBUG)) def raise\_my\_exception(): raise MyException("Fail")

</div>

In the same spirit, It's possible to execute after a call that failed:

<div class="testcode">

import logging import sys

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

logger = logging.getLogger(\_\_name\_\_)

@retry(stop=stop\_after\_attempt(3), after=after\_log(logger, logging.DEBUG)) def raise\_my\_exception(): raise MyException("Fail")

</div>

It's also possible to only log failures that are going to be retried. Normally retries happen after a wait interval, so the keyword argument is called `before_sleep`:

<div class="testcode">

import logging import sys

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

logger = logging.getLogger(\_\_name\_\_)

  - @retry(stop=stop\_after\_attempt(3),  
    before\_sleep=before\_sleep\_log(logger, logging.DEBUG))

  - def raise\_my\_exception():  
    raise MyException("Fail")

</div>

### Statistics

You can access the statistics about the retry made over a function by using the <span class="title-ref">statistics</span> attribute attached to the function:

<div class="testcode">

@retry(stop=stop\_after\_attempt(3)) def raise\_my\_exception(): raise MyException("Fail")

  - try:  
    raise\_my\_exception()

  - except Exception:  
    pass

print(raise\_my\_exception.statistics)

</div>

<div class="testoutput" data-hide="">

...

</div>

### Custom Callbacks

You can also define your own callbacks. The callback should accept one parameter called `retry_state` that contains all information about current retry invocation.

For example, you can call a custom callback function after all retries failed, without raising an exception (or you can re-raise or do anything really)

<div class="testcode">

  - def return\_last\_value(retry\_state):  
    """return the result of the last call attempt""" return retry\_state.outcome.result()

  - def is\_false(value):  
    """Return True if value is False""" return value is False

\# will return False after trying 3 times to get a different result @retry(stop=stop\_after\_attempt(3), retry\_error\_callback=return\_last\_value, retry=retry\_if\_result(is\_false)) def eventually\_return\_false(): return False

</div>

### RetryCallState

`retry_state` argument is an object of <span class="title-ref">\~tenacity.RetryCallState</span> class.

### Other Custom Callbacks

It's also possible to define custom callbacks for other keyword arguments.

<div class="function">

my\_stop(retry\_state)

  - param RetryCallState retry\_state  
    info about current retry invocation

  - return  
    whether or not retrying should stop

  - rtype  
    bool

</div>

<div class="function">

my\_wait(retry\_state)

  - param RetryCallState retry\_state  
    info about current retry invocation

  - return  
    number of seconds to wait before next retry

  - rtype  
    float

</div>

<div class="function">

my\_retry(retry\_state)

  - param RetryCallState retry\_state  
    info about current retry invocation

  - return  
    whether or not retrying should continue

  - rtype  
    bool

</div>

<div class="function">

my\_before(retry\_state)

  - param RetryCallState retry\_state  
    info about current retry invocation

</div>

<div class="function">

my\_after(retry\_state)

  - param RetryCallState retry\_state  
    info about current retry invocation

</div>

<div class="function">

my\_before\_sleep(retry\_state)

  - param RetryCallState retry\_state  
    info about current retry invocation

</div>

Here's an example with a custom `before_sleep` function:

<div class="testcode">

import logging

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

logger = logging.getLogger(\_\_name\_\_)

  - def my\_before\_sleep(retry\_state):
    
      - if retry\_state.attempt\_number \< 1:  
        loglevel = logging.INFO
    
      - else:  
        loglevel = logging.WARNING
    
      - logger.log(  
        loglevel, 'Retrying %s: attempt %s ended with: %s', retry\_state.fn, retry\_state.attempt\_number, retry\_state.outcome)

@retry(stop=stop\_after\_attempt(3), before\_sleep=my\_before\_sleep) def raise\_my\_exception(): raise MyException("Fail")

  - try:  
    raise\_my\_exception()

  - except RetryError:  
    pass

</div>

### Changing Arguments at Run Time

You can change the arguments of a retry decorator as needed when calling it by using the <span class="title-ref">retry\_with</span> function attached to the wrapped function:

<div class="testcode">

@retry(stop=stop\_after\_attempt(3)) def raise\_my\_exception(): raise MyException("Fail")

  - try:  
    raise\_my\_exception.retry\_with(stop=stop\_after\_attempt(4))()

  - except Exception:  
    pass

print(raise\_my\_exception.statistics)

</div>

<div class="testoutput" data-hide="">

...

</div>

If you want to use variables to set up the retry parameters, you don't have to use the <span class="title-ref">retry</span> decorator - you can instead use <span class="title-ref">Retrying</span> directly:

<div class="testcode">

  - def never\_good\_enough(arg1):  
    raise Exception('Invalid argument: {}'.format(arg1))

  - def try\_never\_good\_enough(max\_attempts=3):  
    retryer = Retrying(stop=stop\_after\_attempt(max\_attempts), reraise=True) retryer(never\_good\_enough, 'I really do try')

</div>

You may also want to change the behaviour of a decorated function temporarily, like in tests to avoid unnecessary wait times. You can modify/patch the <span class="title-ref">retry</span> attribute attached to the function. Bear in mind this is a write-only attribute, statistics should be read from the function <span class="title-ref">statistics</span> attribute.

<div class="testcode">

@retry(stop=stop\_after\_attempt(3), wait=wait\_fixed(3)) def raise\_my\_exception(): raise MyException("Fail")

from unittest import mock

  - with mock.patch.object(raise\_my\_exception.retry, "wait", wait\_fixed(0)):
    
      - try:  
        raise\_my\_exception()
    
      - except Exception:  
        pass

print(raise\_my\_exception.statistics)

</div>

<div class="testoutput" data-hide="">

...

</div>

### Retrying code block

Tenacity allows you to retry a code block without the need to wraps it in an isolated function. This makes it easy to isolate failing block while sharing context. The trick is to combine a for loop and a context manager.

<div class="testcode">

from tenacity import Retrying, RetryError, stop\_after\_attempt

  - try:
    
      - for attempt in Retrying(stop=stop\_after\_attempt(3)):
        
          - with attempt:  
            raise Exception('My code is failing\!')

  - except RetryError:  
    pass

</div>

You can configure every details of retry policy by configuring the Retrying object.

With async code you can use AsyncRetrying.

<div class="testcode">

from tenacity import AsyncRetrying, RetryError, stop\_after\_attempt

  - async def function():
    
      - try:
        
          - async for attempt in AsyncRetrying(stop=stop\_after\_attempt(3)):
            
              - with attempt:  
                raise Exception('My code is failing\!')
    
      - except RetryError:  
        pass

</div>

In both cases, you may want to set the result to the attempt so it's available in retry strategies like `retry_if_result`. This can be done accessing the `retry_state` property:

<div class="testcode">

from tenacity import AsyncRetrying, retry\_if\_result

  - async def function():
    
      - async for attempt in AsyncRetrying(retry=retry\_if\_result(lambda x: x \< 3)):
        
          - with attempt:  
            result = 1 \# Some complex calculation, function call, etc.
        
          - if not attempt.retry\_state.outcome.failed:  
            attempt.retry\_state.set\_result(result)
    
    return result

</div>

### Async and retry

Finally, `retry` works also on asyncio, Trio, and Tornado (\>= 4.5) coroutines. Sleeps are done asynchronously too.

`` `python     @retry     async def my_asyncio_function(loop):         await loop.getaddrinfo('8.8.8.8', 53)  .. code-block:: python      @retry     async def my_async_trio_function():         await trio.socket.getaddrinfo('8.8.8.8', 53)  .. code-block:: python      @retry     @tornado.gen.coroutine     def my_async_tornado_function(http_client, url):         yield http_client.fetch(url)  You can even use alternative event loops such as `curio` by passing the correct sleep function:  .. code-block:: python      @retry(sleep=curio.sleep)     async def my_async_curio_function():         await asks.get('https://example.org')  Contribute ``\` ----------

1.  Check for open issues or open a fresh issue to start a discussion around a feature idea or a bug.
2.  Fork [the repository](https://github.com/jd/tenacity) on GitHub to start making your changes to the **main** branch (or branch off of it).
3.  Write a test which shows that the bug was fixed or that the feature works as expected.
4.  Add a [changelog](#Changelogs)
5.  Make the docs better (or more detailed, or more easier to read, or ...)

### Changelogs

[reno](https://docs.openstack.org/reno/latest/user/usage.html) is used for managing changelogs. Take a look at their usage docs.

The doc generation will automatically compile the changelogs. You just need to add them.

`` `sh     # Opens a template file in an editor     tox -e reno -- new some-slug-for-my-change --edit ``\`

---

README.rst

---

Tenacity
========

[![image](https://img.shields.io/pypi/v/tenacity.svg)](https://pypi.python.org/pypi/tenacity)

[![image](https://circleci.com/gh/jd/tenacity.svg?style=svg)](https://circleci.com/gh/jd/tenacity)

[![Mergify Status](https://img.shields.io/endpoint.svg?url=https://api.mergify.com/badges/jd/tenacity&style=flat)](https://mergify.io)

**Please refer to the** [tenacity documentation](https://tenacity.readthedocs.io/en/latest/) **for a better experience.**

Tenacity is an Apache 2.0 licensed general-purpose retrying library, written in Python, to simplify the task of adding retry behavior to just about anything. It originates from [a fork of retrying](https://github.com/rholder/retrying/issues/65) which is sadly no longer [maintained](https://julien.danjou.info/python-tenacity/). Tenacity isn\'t api compatible with retrying but adds significant new functionality and fixes a number of longstanding bugs.

The simplest use case is retrying a flaky function whenever an [Exception]{.title-ref} occurs until a value is returned.

::: {.testcode}
import random from tenacity import retry

\@retry def do\_something\_unreliable(): if random.randint(0, 10) \> 1: raise IOError(\"Broken sauce, everything is hosed!!!111one\") else: return \"Awesome sauce!\"

print(do\_something\_unreliable())
:::

::: {.testoutput hide=""}
Awesome sauce!
:::

::: {.toctree hidden="" maxdepth="2"}
changelog api
:::

Features
--------

-   Generic Decorator API
-   Specify stop condition (i.e. limit by number of attempts)
-   Specify wait condition (i.e. exponential backoff sleeping between attempts)
-   Customize retrying on Exceptions
-   Customize retrying on expected returned result
-   Retry on coroutines
-   Retry code block with context manager

Installation
------------

To install *tenacity*, simply:

``` {.bash}
$ pip install tenacity
```

Examples
--------

### Basic Retry

::: {.testsetup}
import logging \# \# Note the following import is used for demonstration convenience only. \# Production code should always explicitly import the names it needs. \# from tenacity import \*

class MyException(Exception):

:   pass
:::

As you saw above, the default behavior is to retry forever without waiting when an exception is raised.

::: {.testcode}
\@retry def never\_gonna\_give\_you\_up(): print(\"Retry forever ignoring Exceptions, don\'t wait between retries\") raise Exception
:::

### Stopping

Let\'s be a little less persistent and set some boundaries, such as the number of attempts before giving up.

::: {.testcode}
\@retry(stop=stop\_after\_attempt(7)) def stop\_after\_7\_attempts(): print(\"Stopping after 7 attempts\") raise Exception
:::

We don\'t have all day, so let\'s set a boundary for how long we should be retrying stuff.

::: {.testcode}
\@retry(stop=stop\_after\_delay(10)) def stop\_after\_10\_s(): print(\"Stopping after 10 seconds\") raise Exception
:::

If you\'re on a tight deadline, and exceeding your delay time isn\'t ok, then you can give up on retries one attempt before you would exceed the delay.

::: {.testcode}
\@retry(stop=stop\_before\_delay(10)) def stop\_before\_10\_s(): print(\"Stopping 1 attempt before 10 seconds\") raise Exception
:::

You can combine several stop conditions by using the [\|]{.title-ref} operator:

::: {.testcode}
\@retry(stop=(stop\_after\_delay(10) \| stop\_after\_attempt(5))) def stop\_after\_10\_s\_or\_5\_retries(): print(\"Stopping after 10 seconds or 5 retries\") raise Exception
:::

### Waiting before retrying

Most things don\'t like to be polled as fast as possible, so let\'s just wait 2 seconds between retries.

::: {.testcode}
\@retry(wait=wait\_fixed(2)) def wait\_2\_s(): print(\"Wait 2 second between retries\") raise Exception
:::

Some things perform best with a bit of randomness injected.

::: {.testcode}
\@retry(wait=wait\_random(min=1, max=2)) def wait\_random\_1\_to\_2\_s(): print(\"Randomly wait 1 to 2 seconds between retries\") raise Exception
:::

Then again, it\'s hard to beat exponential backoff when retrying distributed services and other remote endpoints.

::: {.testcode}
\@retry(wait=wait\_exponential(multiplier=1, min=4, max=10)) def wait\_exponential\_1(): print(\"Wait 2\^x \* 1 second between each retry starting with 4 seconds, then up to 10 seconds, then 10 seconds afterwards\") raise Exception
:::

Then again, it\'s also hard to beat combining fixed waits and jitter (to help avoid thundering herds) when retrying distributed services and other remote endpoints.

::: {.testcode}
\@retry(wait=wait\_fixed(3) + wait\_random(0, 2)) def wait\_fixed\_jitter(): print(\"Wait at least 3 seconds, and add up to 2 seconds of random delay\") raise Exception
:::

When multiple processes are in contention for a shared resource, exponentially increasing jitter helps minimise collisions.

::: {.testcode}
\@retry(wait=wait\_random\_exponential(multiplier=1, max=60)) def wait\_exponential\_jitter(): print(\"Randomly wait up to 2\^x \* 1 seconds between each retry until the range reaches 60 seconds, then randomly up to 60 seconds afterwards\") raise Exception
:::

Sometimes it\'s necessary to build a chain of backoffs.

::: {.testcode}

\@retry(wait=wait\_chain(\*\[wait\_fixed(3) for i in range(3)\] +

:   \[wait\_fixed(7) for i in range(2)\] + \[wait\_fixed(9)\]))

def wait\_fixed\_chained():

:   print(\"Wait 3s for 3 attempts, 7s for the next 2 attempts and 9s for all attempts thereafter\") raise Exception
:::

### Whether to retry

We have a few options for dealing with retries that raise specific or general exceptions, as in the cases here.

::: {.testcode}

class ClientError(Exception):

:   \"\"\"Some type of client error.\"\"\"

\@retry(retry=retry\_if\_exception\_type(IOError)) def might\_io\_error(): print(\"Retry forever with no wait if an IOError occurs, raise any other errors\") raise Exception

\@retry(retry=retry\_if\_not\_exception\_type(ClientError)) def might\_client\_error(): print(\"Retry forever with no wait if any error other than ClientError occurs. Immediately raise ClientError.\") raise Exception
:::

We can also use the result of the function to alter the behavior of retrying.

::: {.testcode}

def is\_none\_p(value):

:   \"\"\"Return True if value is None\"\"\" return value is None

\@retry(retry=retry\_if\_result(is\_none\_p)) def might\_return\_none(): print(\"Retry with no wait if return value is None\")
:::

See also these methods:

::: {.testcode}
retry\_if\_exception retry\_if\_exception\_type retry\_if\_not\_exception\_type retry\_unless\_exception\_type retry\_if\_result retry\_if\_not\_result retry\_if\_exception\_message retry\_if\_not\_exception\_message retry\_any retry\_all
:::

We can also combine several conditions:

::: {.testcode}

def is\_none\_p(value):

:   \"\"\"Return True if value is None\"\"\" return value is None

\@retry(retry=(retry\_if\_result(is\_none\_p) \| retry\_if\_exception\_type())) def might\_return\_none(): print(\"Retry forever ignoring Exceptions with no wait if return value is None\")
:::

Any combination of stop, wait, etc. is also supported to give you the freedom to mix and match.

It\'s also possible to retry explicitly at any time by raising the [TryAgain]{.title-ref} exception:

::: {.testcode}
\@retry def do\_something(): result = something\_else() if result == 23: raise TryAgain
:::

### Error Handling

Normally when your function fails its final time (and will not be retried again based on your settings), a [RetryError]{.title-ref} is raised. The exception your code encountered will be shown somewhere in the *middle* of the stack trace.

If you would rather see the exception your code encountered at the *end* of the stack trace (where it is most visible), you can set [reraise=True]{.title-ref}.

::: {.testcode}
\@retry(reraise=True, stop=stop\_after\_attempt(3)) def raise\_my\_exception(): raise MyException(\"Fail\")

try:

:   raise\_my\_exception()

except MyException:

:   \# timed out retrying pass
:::

### Before and After Retry, and Logging

It\'s possible to execute an action before any attempt of calling the function by using the before callback function:

::: {.testcode}
import logging import sys

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

logger = logging.getLogger(\_\_name\_\_)

\@retry(stop=stop\_after\_attempt(3), before=before\_log(logger, logging.DEBUG)) def raise\_my\_exception(): raise MyException(\"Fail\")
:::

In the same spirit, It\'s possible to execute after a call that failed:

::: {.testcode}
import logging import sys

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

logger = logging.getLogger(\_\_name\_\_)

\@retry(stop=stop\_after\_attempt(3), after=after\_log(logger, logging.DEBUG)) def raise\_my\_exception(): raise MyException(\"Fail\")
:::

It\'s also possible to only log failures that are going to be retried. Normally retries happen after a wait interval, so the keyword argument is called `before_sleep`:

::: {.testcode}
import logging import sys

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

logger = logging.getLogger(\_\_name\_\_)

\@retry(stop=stop\_after\_attempt(3),

:   before\_sleep=before\_sleep\_log(logger, logging.DEBUG))

def raise\_my\_exception():

:   raise MyException(\"Fail\")
:::

### Statistics

You can access the statistics about the retry made over a function by using the [statistics]{.title-ref} attribute attached to the function:

::: {.testcode}
\@retry(stop=stop\_after\_attempt(3)) def raise\_my\_exception(): raise MyException(\"Fail\")

try:

:   raise\_my\_exception()

except Exception:

:   pass

print(raise\_my\_exception.statistics)
:::

::: {.testoutput hide=""}
\...
:::

### Custom Callbacks

You can also define your own callbacks. The callback should accept one parameter called `retry_state` that contains all information about current retry invocation.

For example, you can call a custom callback function after all retries failed, without raising an exception (or you can re-raise or do anything really)

::: {.testcode}

def return\_last\_value(retry\_state):

:   \"\"\"return the result of the last call attempt\"\"\" return retry\_state.outcome.result()

def is\_false(value):

:   \"\"\"Return True if value is False\"\"\" return value is False

\# will return False after trying 3 times to get a different result \@retry(stop=stop\_after\_attempt(3), retry\_error\_callback=return\_last\_value, retry=retry\_if\_result(is\_false)) def eventually\_return\_false(): return False
:::

### RetryCallState

`retry_state` argument is an object of `~tenacity.RetryCallState`{.interpreted-text role="class"} class.

### Other Custom Callbacks

It\'s also possible to define custom callbacks for other keyword arguments.

::: {.function}
my\_stop(retry\_state)

param RetryCallState retry\_state

:   info about current retry invocation

return

:   whether or not retrying should stop

rtype

:   bool
:::

::: {.function}
my\_wait(retry\_state)

param RetryCallState retry\_state

:   info about current retry invocation

return

:   number of seconds to wait before next retry

rtype

:   float
:::

::: {.function}
my\_retry(retry\_state)

param RetryCallState retry\_state

:   info about current retry invocation

return

:   whether or not retrying should continue

rtype

:   bool
:::

::: {.function}
my\_before(retry\_state)

param RetryCallState retry\_state

:   info about current retry invocation
:::

::: {.function}
my\_after(retry\_state)

param RetryCallState retry\_state

:   info about current retry invocation
:::

::: {.function}
my\_before\_sleep(retry\_state)

param RetryCallState retry\_state

:   info about current retry invocation
:::

Here\'s an example with a custom `before_sleep` function:

::: {.testcode}
import logging

logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

logger = logging.getLogger(\_\_name\_\_)

def my\_before\_sleep(retry\_state):

:   

    if retry\_state.attempt\_number \< 1:

    :   loglevel = logging.INFO

    else:

    :   loglevel = logging.WARNING

    logger.log(

    :   loglevel, \'Retrying %s: attempt %s ended with: %s\', retry\_state.fn, retry\_state.attempt\_number, retry\_state.outcome)

\@retry(stop=stop\_after\_attempt(3), before\_sleep=my\_before\_sleep) def raise\_my\_exception(): raise MyException(\"Fail\")

try:

:   raise\_my\_exception()

except RetryError:

:   pass
:::

### Changing Arguments at Run Time

You can change the arguments of a retry decorator as needed when calling it by using the [retry\_with]{.title-ref} function attached to the wrapped function:

::: {.testcode}
\@retry(stop=stop\_after\_attempt(3)) def raise\_my\_exception(): raise MyException(\"Fail\")

try:

:   raise\_my\_exception.retry\_with(stop=stop\_after\_attempt(4))()

except Exception:

:   pass

print(raise\_my\_exception.statistics)
:::

::: {.testoutput hide=""}
\...
:::

If you want to use variables to set up the retry parameters, you don\'t have to use the [retry]{.title-ref} decorator - you can instead use [Retrying]{.title-ref} directly:

::: {.testcode}

def never\_good\_enough(arg1):

:   raise Exception(\'Invalid argument: {}\'.format(arg1))

def try\_never\_good\_enough(max\_attempts=3):

:   retryer = Retrying(stop=stop\_after\_attempt(max\_attempts), reraise=True) retryer(never\_good\_enough, \'I really do try\')
:::

You may also want to change the behaviour of a decorated function temporarily, like in tests to avoid unnecessary wait times. You can modify/patch the [retry]{.title-ref} attribute attached to the function. Bear in mind this is a write-only attribute, statistics should be read from the function [statistics]{.title-ref} attribute.

::: {.testcode}
\@retry(stop=stop\_after\_attempt(3), wait=wait\_fixed(3)) def raise\_my\_exception(): raise MyException(\"Fail\")

from unittest import mock

with mock.patch.object(raise\_my\_exception.retry, \"wait\", wait\_fixed(0)):

:   

    try:

    :   raise\_my\_exception()

    except Exception:

    :   pass

print(raise\_my\_exception.statistics)
:::

::: {.testoutput hide=""}
\...
:::

### Retrying code block

Tenacity allows you to retry a code block without the need to wraps it in an isolated function. This makes it easy to isolate failing block while sharing context. The trick is to combine a for loop and a context manager.

::: {.testcode}
from tenacity import Retrying, RetryError, stop\_after\_attempt

try:

:   

    for attempt in Retrying(stop=stop\_after\_attempt(3)):

    :   

        with attempt:

        :   raise Exception(\'My code is failing!\')

except RetryError:

:   pass
:::

You can configure every details of retry policy by configuring the Retrying object.

With async code you can use AsyncRetrying.

::: {.testcode}
from tenacity import AsyncRetrying, RetryError, stop\_after\_attempt

async def function():

:   

    try:

    :   

        async for attempt in AsyncRetrying(stop=stop\_after\_attempt(3)):

        :   

            with attempt:

            :   raise Exception(\'My code is failing!\')

    except RetryError:

    :   pass
:::

In both cases, you may want to set the result to the attempt so it\'s available in retry strategies like `retry_if_result`. This can be done accessing the `retry_state` property:

::: {.testcode}
from tenacity import AsyncRetrying, retry\_if\_result

async def function():

:   

    async for attempt in AsyncRetrying(retry=retry\_if\_result(lambda x: x \< 3)):

    :   

        with attempt:

        :   result = 1 \# Some complex calculation, function call, etc.

        if not attempt.retry\_state.outcome.failed:

        :   attempt.retry\_state.set\_result(result)

    return result
:::

### Async and retry

Finally, `retry` works also on asyncio, Trio, and Tornado (\>= 4.5) coroutines. Sleeps are done asynchronously too.

``` {.python}
@retry
async def my_asyncio_function(loop):
    await loop.getaddrinfo('8.8.8.8', 53)
```

``` {.python}
@retry
async def my_async_trio_function():
    await trio.socket.getaddrinfo('8.8.8.8', 53)
```

``` {.python}
@retry
@tornado.gen.coroutine
def my_async_tornado_function(http_client, url):
    yield http_client.fetch(url)
```

You can even use alternative event loops such as [curio]{.title-ref} by passing the correct sleep function:

``` {.python}
@retry(sleep=curio.sleep)
async def my_async_curio_function():
    await asks.get('https://example.org')
```

Contribute
----------

1.  Check for open issues or open a fresh issue to start a discussion around a feature idea or a bug.
2.  Fork [the repository](https://github.com/jd/tenacity) on GitHub to start making your changes to the **main** branch (or branch off of it).
3.  Write a test which shows that the bug was fixed or that the feature works as expected.
4.  Add a [changelog](#Changelogs)
5.  Make the docs better (or more detailed, or more easier to read, or \...)

### Changelogs

[reno](https://docs.openstack.org/reno/latest/user/usage.html) is used for managing changelogs. Take a look at their usage docs.

The doc generation will automatically compile the changelogs. You just need to add them.

``` {.sh}
# Opens a template file in an editor
tox -e reno -- new some-slug-for-my-change --edit
```
