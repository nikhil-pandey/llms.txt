additional_features.md

---

# Additional features

This section discusses various features that did not fit in naturally in one of the previous sections.

## Dataclasses

The :py`dataclasses` module allows defining and customizing simple boilerplate-free classes. They can be defined using the :py\`@dataclasses.dataclass \<python:dataclasses.dataclass\>\` decorator:

`` `python     from dataclasses import dataclass, field      @dataclass     class Application:         name: str         plugins: list[str] = field(default_factory=list)      test = Application("Testing...")  # OK     bad = Application("Testing...", "with plugin")  # Error: list[str] expected  Mypy will detect special methods (such as :py`__lt__ <object.__lt__>`) depending on the flags used to ``\` define dataclasses. For example:

`` `python     from dataclasses import dataclass      @dataclass(order=True)     class OrderedPoint:         x: int         y: int      @dataclass(order=False)     class UnorderedPoint:         x: int         y: int      OrderedPoint(1, 2) < OrderedPoint(3, 4)  # OK     UnorderedPoint(1, 2) < UnorderedPoint(3, 4)  # Error: Unsupported operand types  Dataclasses can be generic and can be used in any other way a normal ``\` class can be used (Python 3.12 syntax):

`` `python     from dataclasses import dataclass      @dataclass     class BoxedData[T]:         data: T         label: str      def unbox[T](bd: BoxedData[T]) -> T:         ...      val = unbox(BoxedData(42, "<important>"))  # OK, inferred type is int  For more information see [official docs <python:library/dataclasses>](official docs <python:library/dataclasses>.md) ``<span class="title-ref"> and :pep:\`557</span>.

### Caveats/Known Issues

Some functions in the :py`dataclasses` module, such as :py\`\~dataclasses.asdict\`, have imprecise (too permissive) types. This will be fixed in future releases.

Mypy does not yet recognize aliases of :py\`dataclasses.dataclass \<dataclasses.dataclass\>\`, and will probably never recognize dynamically computed decorators. The following example does **not** work:

`` `python     from dataclasses import dataclass      dataclass_alias = dataclass     def dataclass_wrapper(cls):       return dataclass(cls)      @dataclass_alias     class AliasDecorated:       """       Mypy doesn't recognize this as a dataclass because it is decorated by an       alias of `dataclass` rather than by `dataclass` itself.       """       attribute: int      AliasDecorated(attribute=1) # error: Unexpected keyword argument   To have Mypy recognize a wrapper of :py`dataclasses.dataclass <dataclasses.dataclass>` ``<span class="title-ref"> as a dataclass decorator, consider using the :py</span>\~typing.dataclass\_transform\` decorator (example uses Python 3.12 syntax):

`` `python     from dataclasses import dataclass, Field     from typing import dataclass_transform      @dataclass_transform(field_specifiers=(Field,))     def my_dataclass[T](cls: type[T]) -> type[T]:         ...         return dataclass(cls)   Data Class Transforms ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Mypy supports the :py\`\~typing.dataclass\_transform\` decorator as described in [PEP 681](https://www.python.org/dev/peps/pep-0681/#the-dataclass-transform-decorator).

\> **Note** \> Pragmatically, mypy will assume such classes have the internal attribute `__dataclass_fields__` (even though they might lack it in runtime) and will assume functions such as :py\`dataclasses.is\_dataclass\` and :py\`dataclasses.fields\` treat them as if they were dataclasses (even though they may fail at runtime).

## The attrs package

\[attrs \<attrs:index\>\](attrs \<attrs:index\>.md) is a package that lets you define classes without writing boilerplate code. Mypy can detect uses of the package and will generate the necessary method definitions for decorated classes using the type annotations it finds. Type annotations can be added as follows:

`` `python     import attr      @attrs.define     class A:         one: int         two: int = 7         three: int = attrs.field(8)  If you're using ``auto\_attribs=False`you must use`attrs.field`:  .. code-block:: python      import attrs      @attrs.define     class A:         one: int = attrs.field()          # Variable annotation (Python 3.6+)         two = attrs.field()  # type: int  # Type comment         three = attrs.field(type=int)     # type= argument  Typeshed has a couple of "white lie" annotations to make type checking`<span class="title-ref"> easier. :py\`attrs.field</span> and :py\`attrs.Factory\` actually return objects, but the annotation says these return the types that they expect to be assigned to. That enables this to work:

`` `python     import attrs      @attrs.define     class A:         one: int = attrs.field(8)         two: dict[str, str] = attrs.Factory(dict)         bad: str = attrs.field(16)   # Error: can't assign int to str  Caveats/Known Issues ``\` ====================

  - The detection of attr classes and attributes works by function name only. This means that if you have your own helper functions that, for example, `return attrs.field()` mypy will not see them.
  - All boolean arguments that mypy cares about must be literal `True` or `False`. e.g the following will not work:
      - \`\`\`python  
        import attrs YES = True @attrs.define(init=YES) class A: ...
  - Currently, `converter` only supports named functions. If mypy finds something else it will complain about not understanding the argument and the type annotation in :py\`\_\_init\_\_ \<object.\_\_init\_\_\><span class="title-ref"> will be replaced by </span><span class="title-ref">Any</span>\`.
  - \[Validator decorators \<attrs:examples-validators\>\](\#validator-decorators-\<attrs:examples-validators\>) and [default decorators](https://www.attrs.org/en/stable/examples.html#defaults) are not type-checked against the attribute they are setting/validating.
  - Method definitions added by mypy currently overwrite any existing method definitions.

<div id="remote-cache">

Using a remote cache to speed up mypy runs `` ` ******************************************  Mypy performs type checking *incrementally*, reusing results from previous runs to speed up successive runs. If you are type checking a large codebase, mypy can still be sometimes slower than desirable. For example, if you create a new branch based on a much more recent commit than the target of the previous mypy run, mypy may have to process almost every file, as a large fraction of source files may have changed. This can also happen after you've rebased a local branch.  Mypy supports using a *remote cache* to improve performance in cases such as the above.  In a large codebase, remote caching can sometimes speed up mypy runs by a factor of 10, or more.  Mypy doesn't include all components needed to set this up -- generally you will have to perform some simple integration with your Continuous Integration (CI) or build system to configure mypy to use a remote cache. This discussion assumes you have a CI system set up for the mypy build you want to speed up, and that you are using a central git repository. Generalizing to different environments should not be difficult.  Here are the main components needed:  * A shared repository for storing mypy cache files for all landed commits.  * CI build that uploads mypy incremental cache files to the shared repository for   each commit for which the CI build runs.  * A wrapper script around mypy that developers use to run mypy with remote   caching enabled.  Below we discuss each of these components in some detail.  Shared repository for cache files =================================  You need a repository that allows you to upload mypy cache files from your CI build and make the cache files available for download based on a commit id.  A simple approach would be to produce an archive of the ``.mypy\_cache`directory (which contains the mypy cache data) as a downloadable *build artifact* from your CI build (depending on the capabilities of your CI system).  Alternatively, you could upload the data to a web server or to S3, for example.  Continuous Integration build ============================  The CI build would run a regular mypy build and create an archive containing the`.mypy\_cache`directory produced by the build. Finally, it will produce the cache as a build artifact or upload it to a repository where it is accessible by the mypy wrapper script.  Your CI script might work like this:  * Run mypy normally. This will generate cache data under the`.mypy\_cache`directory.  * Create a tarball from the`.mypy\_cache`directory.  * Determine the current git master branch commit id (say, using`git rev-parse HEAD`).  * Upload the tarball to the shared repository with a name derived from the   commit id.  Mypy wrapper script ===================  The wrapper script is used by developers to run mypy locally during development instead of invoking mypy directly.  The wrapper first populates the local`.mypy\_cache`directory from the shared repository and then runs a normal incremental build.  The wrapper script needs some logic to determine the most recent central repository commit (by convention, the`origin/master`branch for git) the local development branch is based on. In a typical git setup you can do it like this:  .. code::      git merge-base HEAD origin/master  The next step is to download the cache data (contents of the`.mypy\_cache`directory) from the shared repository based on the commit id of the merge base produced by the git command above. The script will decompress the data so that mypy will start with a fresh`.mypy\_cache`. Finally, the script runs mypy normally. And that's all!  Caching with mypy daemon ========================  You can also use remote caching with the [mypy daemon <mypy_daemon>](#mypy-daemon-<mypy_daemon>). The remote cache will significantly speed up the first`dmypy check``run after starting or restarting the daemon.  The mypy daemon requires extra fine-grained dependency data in the cache files which aren't included by default. To use caching with the mypy daemon, use the :option:`--cache-fine-grained <mypy --cache-fine-grained>` option in your CI build::      $ mypy --cache-fine-grained <args...>  This flag adds extra information for the daemon to the cache. In order to use this extra information, you will also need to use the``--use-fine-grained-cache`option with`dmypy start`or`dmypy restart`. Example::      $ dmypy start -- --use-fine-grained-cache <options...>  Now your first`dmypy check``run should be much faster, as it can use cache information to avoid processing the whole program.  Refinements ===========  There are several optional refinements that may improve things further, at least if your codebase is hundreds of thousands of lines or more:  * If the wrapper script determines that the merge base hasn't changed   from a previous run, there's no need to download the cache data and   it's better to instead reuse the existing local cache data.  * If you use the mypy daemon, you may want to restart the daemon each time   after the merge base or local branch has changed to avoid processing a   potentially large number of changes in an incremental build, as this can   be much slower than downloading cache data and restarting the daemon.  * If the current local branch is based on a very recent master commit,   the remote cache data may not yet be available for that commit, as   there will necessarily be some latency to build the cache files. It   may be a good idea to look for cache data for, say, the 5 latest   master commits and use the most recent data that is available.  * If the remote cache is not accessible for some reason (say, from a public   network), the script can still fall back to a normal incremental build.  * You can have multiple local cache directories for different local branches   using the :option:`--cache-dir <mypy --cache-dir>` option. If the user switches to an existing   branch where downloaded cache data is already available, you can continue   to use the existing cache data instead of redownloading the data.  * You can set up your CI build to use a remote cache to speed up the   CI build. This would be particularly useful if each CI build starts   from a fresh state without access to cache files from previous   builds. It's still recommended to run a full, non-incremental   mypy build to create the cache data, as repeatedly updating cache   data incrementally could result in drift over a long time period (due   to a mypy caching issue, perhaps).  .. _extended_callable:  Extended Callable types ***********************  > **Note** >     This feature is deprecated.  You can use    [callback protocols <callback_protocols>](#callback-protocols-<callback_protocols>) as a replacement.  As an experimental mypy extension, you can specify :py`~collections.abc.Callable` types that support keyword arguments, optional arguments, and more.  When you specify the arguments of a :py`~collections.abc.Callable`, you can choose to supply just the type of a nameless positional argument, or an "argument specifier" representing a more complicated form of argument.  This allows one to more closely emulate the full range of possibilities given by the``def``statement in Python.  As an example, here's a complicated function definition and the corresponding :py`~collections.abc.Callable`:``\`python from collections.abc import Callable from mypy\_extensions import (Arg, DefaultArg, NamedArg, DefaultNamedArg, VarArg, KwArg)

</div>

>   - def func(\_\_a: int, \# This convention is for nameless arguments  
>     b: int, c: int = 0, *args: int, d: int, e: int = 0,*\*kwargs: int) -\> int: ...
> 
>   - F = Callable\[\[int, \# Or Arg(int)  
>     Arg(int, 'b'), DefaultArg(int, 'c'), VarArg(int), NamedArg(int, 'd'), DefaultNamedArg(int, 'e'), KwArg(int)\], int\]
> 
> f: F = func

Argument specifiers are special function calls that can specify the `` ` following aspects of an argument:  - its type (the only thing that the basic format supports)  - its name (if it has one)  - whether it may be omitted  - whether it may or must be passed using a keyword  - whether it is a ``\*args`argument (representing the remaining   positional arguments)  - whether it is a`\*\*kwargs`argument (representing the remaining   keyword arguments)  The following functions are available in`mypy\_extensions`for this purpose:`\`python def Arg(type=Any, name=None): \# A normal, mandatory, positional argument. \# If the name is specified it may be passed as a keyword.

>   - def DefaultArg(type=Any, name=None):  
>     \# An optional positional argument (i.e. with a default value). \# If the name is specified it may be passed as a keyword.
> 
>   - def NamedArg(type=Any, name=None):  
>     \# A mandatory keyword-only argument.
> 
>   - def DefaultNamedArg(type=Any, name=None):  
>     \# An optional keyword-only argument (i.e. with a default value).
> 
>   - def VarArg(type=Any):  
>     \# A \*args-style variadic positional argument. \# A single VarArg() specifier represents all remaining \# positional arguments.
> 
>   - def KwArg(type=Any):  
>     \# A \*\*kwargs-style variadic keyword argument. \# A single KwArg() specifier represents all remaining \# keyword arguments.

In all cases, the `type` argument defaults to `Any`, and if the `` ` ``name`argument is omitted the argument has no name (the name is required for`NamedArg`and`DefaultNamedArg``).  A basic :py`~collections.abc.Callable` such as``\`python MyFunc = Callable\[\[int, str, int\], float\]

is equivalent to the following:

``` python
MyFunc = Callable[[Arg(int), Arg(str), Arg(int)], float]
```

A :py\`\~collections.abc.Callable\` with unspecified argument types, such as

``` python
MyOtherFunc = Callable[..., int]
```

is (roughly) equivalent to

``` python
MyOtherFunc = Callable[[VarArg(), KwArg()], int]
```

\> **Note** \> Each of the functions above currently just returns its `type` argument at runtime, so the information contained in the argument specifiers is not available at runtime. This limitation is necessary for backwards compatibility with the existing `typing.py` module as present in the Python 3.5+ standard library and distributed via PyPI. \`\`\`

---

builtin_types.md

---

# Built-in types

This chapter introduces some commonly used built-in types. We will cover many other kinds of types later.

## Simple types

Here are examples of some common built-in types:

| Type     | Description                                             |
| -------- | ------------------------------------------------------- |
| `int`    | integer                                                 |
| `float`  | floating point number                                   |
| `bool`   | boolean value (subclass of `int`)                       |
| `str`    | text, sequence of unicode codepoints                    |
| `bytes`  | 8-bit string, sequence of byte values                   |
| `object` | an arbitrary object (`object` is the common base class) |

All built-in classes can be used as types.

## Any type

If you can't find a good type for some value, you can always fall back to `Any`:

| Type  | Description                                    |
| ----- | ---------------------------------------------- |
| `Any` | dynamically typed value with an arbitrary type |

The type `Any` is defined in the :py`typing` module. See \[dynamic-typing\](\#dynamic-typing) for more details.

## Generic types

In Python 3.9 and later, built-in collection type objects support indexing:

| Type                | Description                                                      |
| ------------------- | ---------------------------------------------------------------- |
| `list[str]`         | list of `str` objects                                            |
| `tuple[int, int]`   | tuple of two `int` objects (`tuple[()]` is the empty tuple)      |
| `tuple[int, ...]`   | tuple of an arbitrary number of `int` objects                    |
| `dict[str, int]`    | dictionary from `str` keys to `int` values                       |
| `Iterable[int]`     | iterable object containing ints                                  |
| `Sequence[bool]`    | sequence of booleans (read-only)                                 |
| `Mapping[str, int]` | mapping from `str` keys to `int` values (read-only)              |
| `type[C]`           | type object of `C` (`C` is a class/type variable/union of types) |

The type `dict` is a *generic* class, signified by type arguments within `[...]`. For example, `dict[int, str]` is a dictionary from integers to strings and `dict[Any, Any]` is a dictionary of dynamically typed (arbitrary) values and keys. `list` is another generic class.

`Iterable`, `Sequence`, and `Mapping` are generic types that correspond to Python protocols. For example, a `str` object or a `list[str]` object is valid when `Iterable[str]` or `Sequence[str]` is expected. You can import them from :py`collections.abc` instead of importing from :py`typing` in Python 3.9.

See \[generic-builtins\](\#generic-builtins) for more details, including how you can use these in annotations also in Python 3.7 and 3.8.

These legacy types defined in :py`typing` are needed if you need to support Python 3.8 and earlier:

| Type                | Description                                                      |
| ------------------- | ---------------------------------------------------------------- |
| `List[str]`         | list of `str` objects                                            |
| `Tuple[int, int]`   | tuple of two `int` objects (`Tuple[()]` is the empty tuple)      |
| `Tuple[int, ...]`   | tuple of an arbitrary number of `int` objects                    |
| `Dict[str, int]`    | dictionary from `str` keys to `int` values                       |
| `Iterable[int]`     | iterable object containing ints                                  |
| `Sequence[bool]`    | sequence of booleans (read-only)                                 |
| `Mapping[str, int]` | mapping from `str` keys to `int` values (read-only)              |
| `Type[C]`           | type object of `C` (`C` is a class/type variable/union of types) |

`List` is an alias for the built-in type `list` that supports indexing (and similarly for `dict`/`Dict` and `tuple`/`Tuple`).

Note that even though `Iterable`, `Sequence` and `Mapping` look similar to abstract base classes defined in :py`collections.abc` (formerly `collections`), they are not identical, since the latter don't support indexing prior to Python 3.9.

---

cheat_sheet_py3.md

---

# Type hints cheat sheet

This document is a quick cheat sheet showing how to use type annotations for various common types in Python.

## Variables

Technically many of the type annotations shown below are redundant, since mypy can usually infer the type of a variable from its value. See \[type-inference-and-annotations\](\#type-inference-and-annotations) for more details.

`` `python    # This is how you declare the type of a variable    age: int = 1     # You don't need to initialize a variable to annotate it    a: int  # Ok (no value at runtime until assigned)     # Doing so can be useful in conditional branches    child: bool    if age < 18:        child = True    else:        child = False   Useful built-in types ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

`` `python    # For most types, just use the name of the type in the annotation    # Note that mypy can usually infer the type of a variable from its value,    # so technically these annotations are redundant    x: int = 1    x: float = 1.0    x: bool = True    x: str = "test"    x: bytes = b"test"     # For collections on Python 3.9+, the type of the collection item is in brackets    x: list[int] = [1]    x: set[int] = {6, 7}     # For mappings, we need the types of both keys and values    x: dict[str, float] = {"field": 2.0}  # Python 3.9+     # For tuples of fixed size, we specify the types of all the elements    x: tuple[int, str, float] = (3, "yes", 7.5)  # Python 3.9+     # For tuples of variable size, we use one type and ellipsis    x: tuple[int, ...] = (1, 2, 3)  # Python 3.9+     # On Python 3.8 and earlier, the name of the collection type is    # capitalized, and the type is imported from the 'typing' module    from typing import List, Set, Dict, Tuple    x: List[int] = [1]    x: Set[int] = {6, 7}    x: Dict[str, float] = {"field": 2.0}    x: Tuple[int, str, float] = (3, "yes", 7.5)    x: Tuple[int, ...] = (1, 2, 3)     from typing import Union, Optional     # On Python 3.10+, use the | operator when something could be one of a few types    x: list[int | str] = [3, 5, "test", "fun"]  # Python 3.10+    # On earlier versions, use Union    x: list[Union[int, str]] = [3, 5, "test", "fun"]     # Use X | None for a value that could be None on Python 3.10+    # Use Optional[X] on 3.9 and earlier; Optional[X] is the same as 'X | None'    x: str | None = "something" if some_condition() else None    if x is not None:        # Mypy understands x won't be None here because of the if-statement        print(x.upper())    # If you know a value can never be None due to some logic that mypy doesn't    # understand, use an assert    assert x is not None    print(x.upper())  Functions ``\` \*\*\*\*\*\*\*\*\*

`` `python    from collections.abc import Iterator, Callable    from typing import Union, Optional     # This is how you annotate a function definition    def stringify(num: int) -> str:        return str(num)     # And here's how you specify multiple arguments    def plus(num1: int, num2: int) -> int:        return num1 + num2     # If a function does not return a value, use None as the return type    # Default value for an argument goes after the type annotation    def show(value: str, excitement: int = 10) -> None:        print(value + "!" * excitement)     # Note that arguments without a type are dynamically typed (treated as Any)    # and that functions without any annotations are not checked    def untyped(x):        x.anything() + 1 + "string"  # no errors     # This is how you annotate a callable (function) value    x: Callable[[int, float], float] = f    def register(callback: Callable[[str], int]) -> None: ...     # A generator function that yields ints is secretly just a function that    # returns an iterator of ints, so that's how we annotate it    def gen(n: int) -> Iterator[int]:        i = 0        while i < n:            yield i            i += 1     # You can of course split a function annotation over multiple lines    def send_email(        address: str | list[str],        sender: str,        cc: list[str] | None,        bcc: list[str] | None,        subject: str = '',        body: list[str] | None = None,    ) -> bool:        ...     # Mypy understands positional-only and keyword-only arguments    # Positional-only arguments can also be marked by using a name starting with    # two underscores    def quux(x: int, /, *, y: int) -> None:        pass     quux(3, y=5)  # Ok    quux(3, 5)  # error: Too many positional arguments for "quux"    quux(x=3, y=5)  # error: Unexpected keyword argument "x" for "quux"     # This says each positional arg and each keyword arg is a "str"    def call(self, *args: str, **kwargs: str) -> str:        reveal_type(args)  # Revealed type is "tuple[str, ...]"        reveal_type(kwargs)  # Revealed type is "dict[str, str]"        request = make_request(*args, **kwargs)        return self.do_api_query(request)  Classes ``\` \*\*\*\*\*\*\*

`` `python    from typing import ClassVar     class BankAccount:        # The "__init__" method doesn't return anything, so it gets return        # type "None" just like any other method that doesn't return anything        def __init__(self, account_name: str, initial_balance: int = 0) -> None:            # mypy will infer the correct types for these instance variables            # based on the types of the parameters.            self.account_name = account_name            self.balance = initial_balance         # For instance methods, omit type for "self"        def deposit(self, amount: int) -> None:            self.balance += amount         def withdraw(self, amount: int) -> None:            self.balance -= amount     # User-defined classes are valid as types in annotations    account: BankAccount = BankAccount("Alice", 400)    def transfer(src: BankAccount, dst: BankAccount, amount: int) -> None:        src.withdraw(amount)        dst.deposit(amount)     # Functions that accept BankAccount also accept any subclass of BankAccount!    class AuditedBankAccount(BankAccount):        # You can optionally declare instance variables in the class body        audit_log: list[str]         def __init__(self, account_name: str, initial_balance: int = 0) -> None:            super().__init__(account_name, initial_balance)            self.audit_log: list[str] = []         def deposit(self, amount: int) -> None:            self.audit_log.append(f"Deposited {amount}")            self.balance += amount         def withdraw(self, amount: int) -> None:            self.audit_log.append(f"Withdrew {amount}")            self.balance -= amount     audited = AuditedBankAccount("Bob", 300)    transfer(audited, account, 100)  # type checks!     # You can use the ClassVar annotation to declare a class variable    class Car:        seats: ClassVar[int] = 4        passengers: ClassVar[list[str]]     # If you want dynamic attributes on your class, have it    # override "__setattr__" or "__getattr__"    class A:        # This will allow assignment to any A.x, if x is the same type as "value"        # (use "value: Any" to allow arbitrary types)        def __setattr__(self, name: str, value: int) -> None: ...         # This will allow access to any A.x, if x is compatible with the return type        def __getattr__(self, name: str) -> int: ...     a = A()    a.foo = 42  # Works    a.bar = 'Ex-parrot'  # Fails type checking  When you're puzzled or when things are complicated ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

`` `python    from typing import Union, Any, Optional, TYPE_CHECKING, cast     # To find out what type mypy infers for an expression anywhere in    # your program, wrap it in reveal_type().  Mypy will print an error    # message with the type; remove it again before running the code.    reveal_type(1)  # Revealed type is "builtins.int"     # If you initialize a variable with an empty container or "None"    # you may have to help mypy a bit by providing an explicit type annotation    x: list[str] = []    x: str | None = None     # Use Any if you don't know the type of something or it's too    # dynamic to write a type for    x: Any = mystery_function()    # Mypy will let you do anything with x!    x.whatever() * x["you"] + x("want") - any(x) and all(x) is super  # no errors     # Use a "type: ignore" comment to suppress errors on a given line,    # when your code confuses mypy or runs into an outright bug in mypy.    # Good practice is to add a comment explaining the issue.    x = confusing_function()  # type: ignore  # confusing_function won't return None here because ...     # "cast" is a helper function that lets you override the inferred    # type of an expression. It's only for mypy -- there's no runtime check.    a = [4]    b = cast(list[int], a)  # Passes fine    c = cast(list[str], a)  # Passes fine despite being a lie (no runtime check)    reveal_type(c)  # Revealed type is "builtins.list[builtins.str]"    print(c)  # Still prints [4] ... the object is not changed or casted at runtime     # Use "TYPE_CHECKING" if you want to have code that mypy can see but will not    # be executed at runtime (or to have code that mypy can't see)    if TYPE_CHECKING:        import json    else:        import orjson as json  # mypy is unaware of this  In some cases type annotations can cause issues at runtime, see ``\` \[runtime\_troubles\](\#runtime\_troubles) for dealing with this.

See \[silencing-type-errors\](\#silencing-type-errors) for details on how to silence errors.

## Standard "duck types"

In typical Python code, many functions that can take a list or a dict as an argument only need their argument to be somehow "list-like" or "dict-like". A specific meaning of "list-like" or "dict-like" (or something-else-like) is called a "duck type", and several duck types that are common in idiomatic Python are standardized.

`` `python    from collections.abc import Mapping, MutableMapping, Sequence, Iterable    # or 'from typing import ...' (required in Python 3.8)     # Use Iterable for generic iterables (anything usable in "for"),    # and Sequence where a sequence (supporting "len" and "__getitem__") is    # required    def f(ints: Iterable[int]) -> list[str]:        return [str(x) for x in ints]     f(range(1, 3))     # Mapping describes a dict-like object (with "__getitem__") that we won't    # mutate, and MutableMapping one (with "__setitem__") that we might    def f(my_mapping: Mapping[int, str]) -> list[int]:        my_mapping[5] = 'maybe'  # mypy will complain about this line...        return list(my_mapping.keys())     f({3: 'yes', 4: 'no'})     def f(my_mapping: MutableMapping[int, str]) -> set[str]:        my_mapping[5] = 'maybe'  # ...but mypy is OK with this.        return set(my_mapping.values())     f({3: 'yes', 4: 'no'})     import sys    from typing import IO     # Use IO[str] or IO[bytes] for functions that should accept or return    # objects that come from an open() call (note that IO does not    # distinguish between reading, writing or other modes)    def get_sys_IO(mode: str = 'w') -> IO[str]:        if mode == 'w':            return sys.stdout        elif mode == 'r':            return sys.stdin        else:            return sys.stdout   You can even make your own duck types using [protocol-types](#protocol-types).  Forward references ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

`` `python    # You may want to reference a class before it is defined.    # This is known as a "forward reference".    def f(foo: A) -> int:  # This will fail at runtime with 'A' is not defined        ...     # However, if you add the following special import:    from __future__ import annotations    # It will work at runtime and type checking will succeed as long as there    # is a class of that name later on in the file    def f(foo: A) -> int:  # Ok        ...     # Another option is to just put the type in quotes    def f(foo: 'A') -> int:  # Also ok        ...     class A:        # This can also come up if you need to reference a class in a type        # annotation inside the definition of that class        @classmethod        def create(cls) -> A:            ...  See [forward-references](#forward-references) for more details.  Decorators ``\` \*\*\*\*\*\*\*\*\*\*

Decorator functions can be expressed via generics. See \[declaring-decorators\](\#declaring-decorators) for more details. Example using Python 3.12 syntax:

`` `python     from collections.abc import Callable     from typing import Any      def bare_decorator[F: Callable[..., Any]](func: F) -> F:         ...      def decorator_args[F: Callable[..., Any]](url: str) -> Callable[[F], F]:         ...  The same example using pre-3.12 syntax:  .. code-block:: python      from collections.abc import Callable     from typing import Any, TypeVar      F = TypeVar('F', bound=Callable[..., Any])      def bare_decorator(func: F) -> F:         ...      def decorator_args(url: str) -> Callable[[F], F]:         ...  Coroutines and asyncio ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

See \[async-and-await\](\#async-and-await) for the full detail on typing coroutines and asynchronous code.

`` `python import asyncio  # A coroutine is typed like a normal function async def countdown(tag: str, count: int) -> str:     while count > 0:         print(f'T-minus {count} ({tag})')         await asyncio.sleep(0.1)         count -= 1     return "Blastoff!" ``\`

---

class_basics.md

---

# Class basics

This section will help get you started annotating your classes. Built-in classes such as `int` also follow these same rules.

## Instance and class attributes

The mypy type checker detects if you are trying to access a missing attribute, which is a very common programming error. For this to work correctly, instance and class attributes must be defined or initialized within the class. Mypy infers the types of attributes:

`` `python    class A:        def __init__(self, x: int) -> None:            self.x = x  # Aha, attribute 'x' of type 'int'     a = A(1)    a.x = 2  # OK!    a.y = 3  # Error: "A" has no attribute "y"  This is a bit like each class having an implicitly defined ``<span class="title-ref"> :py</span>\_\_slots\_\_ \<object.\_\_slots\_\_\>\` attribute. This is only enforced during type checking and not when your program is running.

You can declare types of variables in the class body explicitly using a type annotation:

`` `python    class A:        x: list[int]  # Declare attribute 'x' of type list[int]     a = A()    a.x = [1]     # OK  As in Python generally, a variable defined in the class body can be used ``<span class="title-ref"> as a class or an instance variable. (As discussed in the next section, you can override this with a :py</span>\~typing.ClassVar\` annotation.)

Similarly, you can give explicit types to instance variables defined in a method:

`` `python    class A:        def __init__(self) -> None:            self.x: list[int] = []         def f(self) -> None:            self.y: Any = 0  You can only define an instance variable within a method if you assign ``<span class="title-ref"> to it explicitly using </span><span class="title-ref">self</span>\`:

`` `python    class A:        def __init__(self) -> None:            self.y = 1   # Define 'y'            a = self            a.x = 1      # Error: 'x' not defined  Annotating __init__ methods ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

The :py\`\_\_init\_\_ \<object.\_\_init\_\_\><span class="title-ref"> method is somewhat special -- it doesn't return a value. This is best expressed as </span><span class="title-ref">-\> None</span><span class="title-ref">. However, since many feel this is redundant, it is allowed to omit the return type declaration on :py</span>\_\_init\_\_ \<object.\_\_init\_\_\><span class="title-ref"> methods \*\*if at least one argument is annotated\*\*. For example, in the following classes :py</span>\_\_init\_\_ \<object.\_\_init\_\_\>\` is considered fully annotated:

`` `python    class C1:        def __init__(self) -> None:            self.var = 42     class C2:        def __init__(self, arg: int):            self.var = arg  However, if :py`__init__ <object.__init__>` has no annotated arguments and no return type ``\` annotation, it is considered an untyped method:

`` `python    class C3:        def __init__(self):            # This body is not type checked            self.var = 42 + 'abc'  Class attribute annotations ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

You can use a :py\`ClassVar\[t\] \<typing.ClassVar\>\` annotation to explicitly declare that a particular attribute should not be set on instances:

`` `python   from typing import ClassVar    class A:       x: ClassVar[int] = 0  # Class variable only    A.x += 1  # OK    a = A()   a.x = 1  # Error: Cannot assign to class variable "x" via instance   print(a.x)  # OK -- can be read through an instance  It's not necessary to annotate all class variables using ``<span class="title-ref"> :py</span>\~typing.ClassVar\`. An attribute without the :py\`\~typing.ClassVar\` annotation can still be used as a class variable. However, mypy won't prevent it from being used as an instance variable, as discussed previously:

`` `python   class A:       x = 0  # Can be used as a class or instance variable    A.x += 1  # OK    a = A()   a.x = 1  # Also OK  Note that :py`~typing.ClassVar` is not a class, and you can't use it with ``<span class="title-ref"> :py\`isinstance</span> or :py\`issubclass\`. It does not change Python runtime behavior -- it's only for type checkers such as mypy (and also helpful for human readers).

You can also omit the square brackets and the variable type in a :py\`\~typing.ClassVar\` annotation, but this might not do what you'd expect:

`` `python    class A:        y: ClassVar = 0  # Type implicitly Any!  In this case the type of the attribute will be implicitly ``Any`.`\` This behavior will change in the future, since it's surprising.

An explicit :py\`\~typing.ClassVar\` may be particularly handy to distinguish between class and instance variables with callable types. For example:

`` `python    from collections.abc import Callable    from typing import ClassVar     class A:        foo: Callable[[int], None]        bar: ClassVar[Callable[[A, int], None]]        bad: Callable[[A], None]     A().foo(42)  # OK    A().bar(42)  # OK    A().bad()  # Error: Too few arguments  .. note::    A :py`~typing.ClassVar` type parameter cannot include type variables: ``ClassVar\[T\]`and`ClassVar\[list\[T\]\]`are both invalid if`T`is a type variable (see [generic-classes](#generic-classes)    for more about type variables).  Overriding statically typed methods`\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

When overriding a statically typed method, mypy checks that the override has a compatible signature:

`` `python    class Base:        def f(self, x: int) -> None:            ...     class Derived1(Base):        def f(self, x: str) -> None:   # Error: type of 'x' incompatible            ...     class Derived2(Base):        def f(self, x: int, y: int) -> None:  # Error: too many arguments            ...     class Derived3(Base):        def f(self, x: int) -> None:   # OK            ...     class Derived4(Base):        def f(self, x: float) -> None:   # OK: mypy treats int as a subtype of float            ...     class Derived5(Base):        def f(self, x: int, y: int = 0) -> None:   # OK: accepts more than the base            ...                                    #     class method  > **Note** >     You can also vary return types **covariantly** in overriding. For    example, you could override the return type ``Iterable\[int\]`with a    subtype such as`list\[int\]`. Similarly, you can vary argument types    **contravariantly** -- subclasses can have more general argument types.  In order to ensure that your code remains correct when renaming methods,`<span class="title-ref"> it can be helpful to explicitly mark a method as overriding a base method. This can be done with the </span><span class="title-ref">@override</span><span class="title-ref"> decorator. </span><span class="title-ref">@override</span><span class="title-ref"> can be imported from </span><span class="title-ref">typing</span><span class="title-ref"> starting with Python 3.12 or from </span><span class="title-ref">typing\_extensions</span>\` for use with older Python versions. If the base method is then renamed while the overriding method is not, mypy will show an error:

`` `python    from typing import override     class Base:        def f(self, x: int) -> None:            ...        def g_renamed(self, y: str) -> None:            ...     class Derived1(Base):        @override        def f(self, x: int) -> None:   # OK            ...         @override        def g(self, y: str) -> None:   # Error: no corresponding base method found            ...  > **Note** >     Use [--enable-error-code explicit-override <code-explicit-override>](#--enable-error-code-explicit-override-<code-explicit-override>) to require    that method overrides use the ``@override`decorator. Emit an error if it is missing.  You can also override a statically typed method with a dynamically`\` typed one. This allows dynamically typed code to override methods defined in library classes without worrying about their type signatures.

As always, relying on dynamically typed code can be unsafe. There is no runtime enforcement that the method override returns a value that is compatible with the original return type, since annotations have no effect at runtime:

`` `python    class Base:        def inc(self, x: int) -> int:            return x + 1     class Derived(Base):        def inc(self, x):   # Override, dynamically typed            return 'hello'  # Incompatible with 'Base', but no mypy error  Abstract base classes and multiple inheritance ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Mypy supports Python \[abstract base classes \<python:library/abc\>\](abstract base classes \<python:library/abc\>.md) (ABCs). Abstract classes have at least one abstract method or property that must be implemented by any *concrete* (non-abstract) subclass. You can define abstract base classes using the :py\`abc.ABCMeta\` metaclass and the :py\`@abc.abstractmethod \<abc.abstractmethod\>\` function decorator. Example:

`` `python    from abc import ABCMeta, abstractmethod     class Animal(metaclass=ABCMeta):        @abstractmethod        def eat(self, food: str) -> None: pass         @property        @abstractmethod        def can_walk(self) -> bool: pass     class Cat(Animal):        def eat(self, food: str) -> None:            ...  # Body omitted         @property        def can_walk(self) -> bool:            return True     x = Animal()  # Error: 'Animal' is abstract due to 'eat' and 'can_walk'    y = Cat()     # OK  Note that mypy performs checking for unimplemented abstract methods ``<span class="title-ref"> even if you omit the :py</span>\~abc.ABCMeta\` metaclass. This can be useful if the metaclass would cause runtime metaclass conflicts.

Since you can't create instances of ABCs, they are most commonly used in type annotations. For example, this method accepts arbitrary iterables containing arbitrary animals (instances of concrete `Animal` subclasses):

`` `python    def feed_all(animals: Iterable[Animal], food: str) -> None:        for animal in animals:            animal.eat(food)  There is one important peculiarity about how ABCs work in Python -- ``<span class="title-ref"> whether a particular class is abstract or not is somewhat implicit. In the example below, </span><span class="title-ref">Derived</span><span class="title-ref"> is treated as an abstract base class since </span><span class="title-ref">Derived</span><span class="title-ref"> inherits an abstract </span><span class="title-ref">f</span><span class="title-ref"> method from </span><span class="title-ref">Base</span><span class="title-ref"> and doesn't explicitly implement it. The definition of </span><span class="title-ref">Derived</span>\` generates no errors from mypy, since it's a valid ABC:

`` `python    from abc import ABCMeta, abstractmethod     class Base(metaclass=ABCMeta):        @abstractmethod        def f(self, x: int) -> None: pass     class Derived(Base):  # No error -- Derived is implicitly abstract        def g(self) -> None:            ...  Attempting to create an instance of ``Derived`will be rejected,`\` however:

`` `python    d = Derived()  # Error: 'Derived' is abstract  > **Note** >     It's a common error to forget to implement an abstract method.    As shown above, the class definition will not generate an error    in this case, but any attempt to construct an instance will be    flagged as an error.  Mypy allows you to omit the body for an abstract method, but if you do so, ``<span class="title-ref"> it is unsafe to call such method via </span><span class="title-ref">super()</span>\`. For example:

`` `python    from abc import abstractmethod    class Base:        @abstractmethod        def foo(self) -> int: pass        @abstractmethod        def bar(self) -> int:            return 0    class Sub(Base):        def foo(self) -> int:            return super().foo() + 1  # error: Call to abstract method "foo" of "Base"                                      # with trivial body via super() is unsafe        @abstractmethod        def bar(self) -> int:            return super().bar() + 1  # This is OK however.  A class can inherit any number of classes, both abstract and ``\` concrete. As with normal overrides, a dynamically typed method can override or implement a statically typed method defined in any base class, including an abstract method defined in an abstract base class.

You can implement an abstract property using either a normal property or an instance variable.

## Slots

When a class has explicitly defined :std`__slots__`, mypy will check that all attributes assigned to are members of `__slots__`:

`` `python   class Album:       __slots__ = ('name', 'year')        def __init__(self, name: str, year: int) -> None:          self.name = name          self.year = year          # Error: Trying to assign name "released" that is not in "__slots__" of type "Album"          self.released = True    my_album = Album('Songs about Python', 2021)  Mypy will only check attribute assignments against ``\_\_slots\_\_`when`\` the following conditions hold:

1.  All base classes (except builtin ones) must have explicit `__slots__` defined (this mirrors Python semantics).
2.  `__slots__` does not include `__dict__`. If `__slots__` includes `__dict__`, arbitrary attributes can be set, similar to when `__slots__` is not defined (this mirrors Python semantics).
3.  All values in `__slots__` must be string literals.

---

command_line.md

---

<div id="command-line">

<div class="program">

mypy

</div>

</div>

# The mypy command line

This section documents mypy's command line interface. You can view a quick summary of the available flags by running `mypy --help`.

\> **Note** \> Command line flags are liable to change between releases.

## Specifying what to type check

By default, you can specify what code you want mypy to type check by passing in the paths to what you want to have type checked:

    $ mypy foo.py bar.py some_directory

Note that directories are checked recursively.

Mypy also lets you specify what code to type check in several other ways. A short summary of the relevant flags is included below: for full details, see \[running-mypy\](\#running-mypy).

<div class="option">

\-m MODULE, --module MODULE

Asks mypy to type check the provided module. This flag may be repeated multiple times.

Mypy *will not* recursively type check any submodules of the provided module.

</div>

<div class="option">

\-p PACKAGE, --package PACKAGE

Asks mypy to type check the provided package. This flag may be repeated multiple times.

Mypy *will* recursively type check any submodules of the provided package. This flag is identical to `--module` apart from this behavior.

</div>

<div class="option">

\-c PROGRAM\_TEXT, --command PROGRAM\_TEXT

Asks mypy to type check the provided string as a program.

</div>

<div class="option">

\--exclude

A regular expression that matches file names, directory names and paths which mypy should ignore while recursively discovering files to check. Use forward slashes on all platforms.

For instance, to avoid discovering any files named <span class="title-ref">setup.py</span> you could pass `--exclude '/setup\.py$'`. Similarly, you can ignore discovering directories with a given name by e.g. `--exclude /build/` or those matching a subpath with `--exclude /project/vendor/`. To ignore multiple files / directories / paths, you can provide the --exclude flag more than once, e.g `--exclude '/setup\.py$' --exclude '/build/'`.

Note that this flag only affects recursive directory tree discovery, that is, when mypy is discovering files within a directory tree or submodules of a package to check. If you pass a file or module explicitly it will still be checked. For instance, `mypy --exclude '/setup.py$' but_still_check/setup.py`.

In particular, `--exclude` does not affect mypy's \[import following \<follow-imports\>\](\#import-following

</div>

  - \----\<follow-imports\>). You can use a per-module `follow_imports` config  
    option to additionally avoid mypy from following imports and checking code you do not wish to be checked.
    
    Note that mypy will never recursively discover files and directories named "site-packages", "node\_modules" or "\_\_pycache\_\_", or those whose name starts with a period, exactly as `--exclude '/(site-packages|node_modules|__pycache__|\..*)/$'` would. Mypy will also never recursively discover files with extensions other than `.py` or `.pyi`.

## Optional arguments

<div class="option">

\-h, --help

Show help message and exit.

</div>

<div class="option">

\-v, --verbose

More verbose messages.

</div>

<div class="option">

\-V, --version

Show program's version number and exit.

</div>

<div class="option">

\-O FORMAT, --output FORMAT {json}

Set a custom output format.

</div>

## Config file

<div class="option">

\--config-file CONFIG\_FILE

This flag makes mypy read configuration settings from the given file.

By default settings are read from `mypy.ini`, `.mypy.ini`, `pyproject.toml`, or `setup.cfg` in the current directory. Settings override mypy's built-in defaults and command line flags can override settings.

Specifying `--config-file= <--config-file>` (with no filename) will ignore *all* config files.

See \[config-file\](\#config-file) for the syntax of configuration files.

</div>

<div class="option">

\--warn-unused-configs

This flag makes mypy warn about unused `[mypy-<pattern>]` config file sections. (This requires turning off incremental mode using `--no-incremental`.)

</div>

## Import discovery

The following flags customize how exactly mypy discovers and follows imports.

<div class="option">

\--explicit-package-bases

This flag tells mypy that top-level packages will be based in either the current directory, or a member of the `MYPYPATH` environment variable or `mypy_path` config option. This option is only useful in the absence of <span class="title-ref">\_\_init\_\_.py</span>. See \[Mapping file paths to modules \<mapping-paths-to-modules\>\](\#mapping-file

</div>

\----paths-to-modules-\<mapping-paths-to-modules\>) for details.

<div class="option">

\--ignore-missing-imports

This flag makes mypy ignore all missing imports. It is equivalent to adding `# type: ignore` comments to all unresolved imports within your codebase.

Note that this flag does *not* suppress errors about missing names in successfully resolved modules. For example, if one has the following files:

    package/__init__.py
    package/mod.py

Then mypy will generate the following errors with `--ignore-missing-imports`:

  - \`\`\`python  
    import package.unknown \# No error, ignored x = package.unknown.func() \# OK. 'func' is assumed to be of type 'Any'
    
    from package import unknown \# No error, ignored from package.mod import NonExisting \# Error: Module has no attribute 'NonExisting'

For more details, see \[ignore-missing-imports\](\#ignore-missing-imports).

</div>

<div class="option">

\--follow-imports {normal,silent,skip,error}

This flag adjusts how mypy follows imported modules that were not explicitly passed in via the command line.

The default option is `normal`: mypy will follow and type check all modules. For more information on what the other options do, see \[Following imports \<follow-imports\>\](\#following-imports-\<follow-imports\>).

</div>

<div class="option">

\--python-executable EXECUTABLE

This flag will have mypy collect type information from `561` compliant packages installed for the Python executable `EXECUTABLE`. If not provided, mypy will use PEP 561 compliant packages installed for the Python executable running mypy.

See \[installed-packages\](\#installed-packages) for more on making PEP 561 compliant packages.

</div>

<div class="option">

\--no-site-packages

This flag will disable searching for `561` compliant packages. This will also disable searching for a usable Python executable.

Use this flag if mypy cannot find a Python executable for the version of Python being checked, and you don't need to use PEP 561 typed packages. Otherwise, use `--python-executable`.

</div>

<div class="option">

\--no-silence-site-packages

By default, mypy will suppress any error messages generated within `561` compliant packages. Adding this flag will disable this behavior.

</div>

<div class="option">

\--fast-module-lookup

The default logic used to scan through search paths to resolve imports has a quadratic worse-case behavior in some cases, which is for instance triggered by a large number of folders sharing a top-level namespace as in:

    foo/
        company/
            foo/
                a.py
    bar/
        company/
            bar/
                b.py
    baz/
        company/
            baz/
                c.py
    ...

If you are in this situation, you can enable an experimental fast path by setting the `--fast-module-lookup` option.

</div>

<div class="option">

\--no-namespace-packages

This flag disables import discovery of namespace packages (see `420`). In particular, this prevents discovery of packages that don't have an `__init__.py` (or `__init__.pyi`) file.

This flag affects how mypy finds modules and packages explicitly passed on the command line. It also affects how mypy determines fully qualified module names for files passed on the command line. See \[Mapping file paths to modules \<mapping-paths-to-modules\>\](\#mapping-file-paths-to

</div>

\----modules-\<mapping-paths-to-modules\>) for details.

<div id="platform-configuration">

Platform configuration `` ` **********************  By default, mypy will assume that you intend to run your code using the same operating system and Python version you are using to run mypy itself. The following flags let you modify this behavior.  For more information on how to use these flags, see [version_and_platform_checks](#version_and_platform_checks).  .. option:: --python-version X.Y      This flag will make mypy type check your code as if it were     run under Python version X.Y. Without this option, mypy will default to using     whatever version of Python is running mypy.      This flag will attempt to find a Python executable of the corresponding     version to search for :pep:`561` compliant packages. If you'd like to     disable this, use the :option:`--no-site-packages` flag (see     [import-discovery](#import-discovery) for more details).  .. option:: --platform PLATFORM      This flag will make mypy type check your code as if it were     run under the given operating system. Without this option, mypy will     default to using whatever operating system you are currently using.      The ``PLATFORM``parameter may be any string supported by     :py`sys.platform`.  .. _always-true:  .. option:: --always-true NAME      This flag will treat all variables named``NAME`as     compile-time constants that are always true.  This flag may     be repeated.  .. option:: --always-false NAME      This flag will treat all variables named`NAME`as     compile-time constants that are always false.  This flag may     be repeated.   .. _disallow-dynamic-typing:  Disallow dynamic typing ***********************  The`Any`type is used to represent a value that has a [dynamic type <dynamic-typing>](#dynamic-type-<dynamic-typing>). The`--disallow-any`family of flags will disallow various uses of the`Any`type in a module -- this lets us strategically disallow the use of dynamic typing in a controlled way.  The following options are available:  .. option:: --disallow-any-unimported      This flag disallows usage of types that come from unfollowed imports     (such types become aliases for`Any``). Unfollowed imports occur either     when the imported module does not exist or when :option:`--follow-imports=skip <--follow-imports>`     is set.  .. option:: --disallow-any-expr      This flag disallows all expressions in the module that have type``Any`.     If an expression of type`Any``appears anywhere in the module     mypy will output an error unless the expression is immediately     used as an argument to :py`~typing.cast` or assigned to a variable with an     explicit type annotation.      In addition, declaring a variable of type``Any`or casting to type`Any`is not allowed. Note that calling functions     that take parameters of type`Any`is still allowed.  .. option:: --disallow-any-decorated      This flag disallows functions that have`Any`in their signature     after decorator transformation.  .. option:: --disallow-any-explicit      This flag disallows explicit`Any`in type positions such as type     annotations and generic type parameters.  .. option:: --disallow-any-generics      This flag disallows usage of generic types that do not specify explicit     type parameters. For example, you can't use a bare`x: list`. Instead, you     must always write something like`x: list\[int\]`.  .. option:: --disallow-subclassing-any      This flag reports an error whenever a class subclasses a value of     type`Any``.  This may occur when the base class is imported from     a module that doesn't exist (when using     :option:`--ignore-missing-imports`) or is     ignored due to :option:`--follow-imports=skip <--follow-imports>` or a``\# type: ignore`comment on the`import`statement.      Since the module is silenced, the imported class is given a type of`Any``.     By default mypy will assume that the subclass correctly inherited     the base class even though that may not actually be the case.  This     flag makes mypy raise an error instead.   .. _untyped-definitions-and-calls:  Untyped definitions and calls *****************************  The following flags configure how mypy handles untyped function definitions or calls.  .. option:: --disallow-untyped-calls      This flag reports an error whenever a function with type annotations     calls a function defined without annotations.  .. option:: --untyped-calls-exclude      This flag allows to selectively disable :option:`--disallow-untyped-calls`     for functions and methods defined in specific packages, modules, or classes.     Note that each exclude entry acts as a prefix. For example (assuming there     are no type annotations for``third\_party\_lib`available):`\`python \# mypy --disallow-untyped-calls \# --untyped-calls-exclude=third\_party\_lib.module\_a \# --untyped-calls-exclude=foo.A from third\_party\_lib.module\_a import some\_func from third\_party\_lib.module\_b import other\_func import foo

</div>

> some\_func() \# OK, function comes from module <span class="title-ref">third\_party\_lib.module\_a</span> other\_func() \# E: Call to untyped function "other\_func" in typed context
> 
> foo.A().meth() \# OK, method was defined in class <span class="title-ref">foo.A</span> foo.B().meth() \# E: Call to untyped function "meth" in typed context
> 
> \# file foo.py class A: def meth(self): pass class B: def meth(self): pass

<div class="option">

\--disallow-untyped-defs

This flag reports an error whenever it encounters a function definition without type annotations or with incomplete type annotations. (a superset of `--disallow-incomplete-defs`).

For example, it would report an error for `def f(a, b)` and `def f(a: int, b)`.

</div>

<div class="option">

\--disallow-incomplete-defs

This flag reports an error whenever it encounters a partly annotated function definition, while still allowing entirely unannotated definitions.

For example, it would report an error for `def f(a: int, b)` but not `def f(a, b)`.

</div>

<div class="option">

\--check-untyped-defs

This flag is less severe than the previous two options -- it type checks the body of every function, regardless of whether it has type annotations. (By default the bodies of functions without annotations are not type checked.)

It will assume all arguments have type `Any` and always infer `Any` as the return type.

</div>

<div class="option">

\--disallow-untyped-decorators

This flag reports an error whenever a function with type annotations is decorated with a decorator without annotations.

</div>

<div id="none-and-optional-handling">

None and Optional handling `` ` **************************  The following flags adjust how mypy handles values of type ``None`.  .. _implicit-optional:  .. option:: --implicit-optional      This flag causes mypy to treat parameters with a`None`default value as having an implicit optional type (`T | None`).      For example, if this flag is set, mypy would assume that the`x`parameter is actually of type`int | None`in the code snippet below,     since the default parameter is`None`:`\`python def foo(x: int = None) -\> None: print(x)

</div>

> **Note:** This was disabled by default starting in mypy 0.980.

<div id="no_strict_optional">

<div class="option">

\--no-strict-optional

This flag effectively disables checking of optional types and `None` values. With this option, mypy doesn't generally check the use of `None` values -- it is treated as compatible with every type.

\> **Warning**

</div>

</div>

  - \>  
    `--no-strict-optional` is evil. Avoid using it and definitely do not use it without understanding what it does.

<div id="configuring-warnings">

Configuring warnings `` ` ********************  The following flags enable warnings for code that is sound but is potentially problematic or redundant in some way.  .. option:: --warn-redundant-casts      This flag will make mypy report an error whenever your code uses     an unnecessary cast that can safely be removed.  .. option:: --warn-unused-ignores      This flag will make mypy report an error whenever your code uses     a ``\# type: ignore``comment on a line that is not actually     generating an error message.      This flag, along with the :option:`--warn-redundant-casts` flag, are both     particularly useful when you are upgrading mypy. Previously,     you may have needed to add casts or``\# type: ignore`annotations     to work around bugs in mypy or missing stubs for 3rd party libraries.      These two flags let you discover cases where either workarounds are     no longer necessary.  .. option:: --no-warn-no-return      By default, mypy will generate errors when a function is missing     return statements in some execution paths. The only exceptions     are when:      -   The function has a`None`or`Any``return type     -   The function has an empty body and is marked as an abstract method,         is in a protocol class, or is in a stub file     -  The execution path can never return; for example, if an exception         is always raised      Passing in :option:`--no-warn-no-return` will disable these error     messages in all cases.  .. option:: --warn-return-any      This flag causes mypy to generate a warning when returning a value     with type``Any`from a function declared with a non-`Any`return type.  .. option:: --warn-unreachable      This flag will make mypy report an error whenever it encounters     code determined to be unreachable or redundant after performing type analysis.     This can be a helpful way of detecting certain kinds of bugs in your code.      For example, enabling this flag will make mypy report that the`x \> 7`check is redundant and that the`else`block below is unreachable.`\`python def process(x: int) -\> None: \# Error: Right operand of "or" is never evaluated if isinstance(x, int) or x \> 7: \# Error: Unsupported operand types for + ("int" and "str") print(x + "bad") else: \# Error: 'Statement is unreachable' error print(x + "bad")

</div>

> To help prevent mypy from generating spurious warnings, the "Statement is unreachable" warning will be silenced in exactly two cases:
> 
> 1.  When the unreachable statement is a `raise` statement, is an `assert False` statement, or calls a function that has the :py\`\~typing.NoReturn\` return type hint. In other words, when the unreachable statement throws an error or terminates the program in some way.
> 2.  When the unreachable statement was *intentionally* marked as unreachable using \[version\_and\_platform\_checks\](\#version\_and\_platform\_checks).
> 
> \> **Note**

  - \>  
    Mypy currently cannot detect and report unreachable or redundant code inside any functions using \[type-variable-value-restriction\](\#type-variable-value-restriction).
    
    This limitation will be removed in future releases of mypy.

<div class="option">

\--report-deprecated-as-error

By default, mypy emits notes if your code imports or uses deprecated features. This flag converts such notes to errors, causing mypy to eventually finish with a non-zero exit code. Features are considered deprecated when decorated with `warnings.deprecated`.

</div>

<div id="miscellaneous-strictness-flags">

Miscellaneous strictness flags `` ` ******************************  This section documents any other flags that do not neatly fall under any of the above sections.  .. option:: --allow-untyped-globals      This flag causes mypy to suppress errors caused by not being able to fully     infer the types of global and class variables.  .. option:: --allow-redefinition      By default, mypy won't allow a variable to be redefined with an     unrelated type. This flag enables redefinition of a variable with an     arbitrary type *in some contexts*: only redefinitions within the     same block and nesting depth as the original definition are allowed.     Example where this can be useful: ``\`python def process(items: list\[str\]) -\> None: \# 'items' has type list\[str\] items = \[item.split() for item in items\] \# 'items' now has type list\[list\[str\]\]

</div>

> The variable must be used before it can be redefined:
> 
> ``` python
> def process(items: list[str]) -> None:
>    items = "mypy"  # invalid redefinition to str because the variable hasn't been used yet
>    print(items)
>    items = "100"  # valid, items now has type str
>    items = int(items)  # valid, items now has type int
> ```

<div class="option">

\--local-partial-types

In mypy, the most common cases for partial types are variables initialized using `None`, but without explicit `X | None` annotations. By default, mypy won't check partial types spanning module top level or class top level. This flag changes the behavior to only allow partial types at local level, therefore it disallows inferring variable type for `None` from two assignments in different scopes. For example:

``` python
a = None  # Need type annotation here if using --local-partial-types
b: int | None = None

class Foo:
    bar = None  # Need type annotation here if using --local-partial-types
    baz: int | None = None

    def __init__(self) -> None:
        self.bar = 1

reveal_type(Foo().bar)  # 'int | None' without --local-partial-types
```

Note: this option is always implicitly enabled in mypy daemon and will become enabled by default for mypy in a future release.

</div>

<div class="option">

\--no-implicit-reexport

By default, imported values to a module are treated as exported and mypy allows other modules to import them. This flag changes the behavior to not re-export unless the item is imported using from-as or is included in `__all__`. Note this is always treated as enabled for stub files. For example:

``` python
# This won't re-export the value
from foo import bar

# Neither will this
from foo import bar as bang

# This will re-export it as bar and allow other modules to import it
from foo import bar as bar

# This will also re-export bar
from foo import bar
__all__ = ['bar']
```

</div>

<div class="option">

\--strict-equality

By default, mypy allows always-false comparisons like `42 == 'no'`. Use this flag to prohibit such comparisons of non-overlapping types, and similar identity and container checks:

``` python
items: list[int]
if 'some string' in items:  # Error: non-overlapping container check!
    ...

text: str
if text != b'other bytes':  # Error: non-overlapping equality check!
    ...

assert text is not None  # OK, check against None is allowed as a special case.
```

</div>

<div class="option">

\--extra-checks

This flag enables additional checks that are technically correct but may be impractical in real code. In particular, it prohibits partial overlap in `TypedDict` updates, and makes arguments prepended via `Concatenate` positional-only. For example:

``` python
from typing import TypedDict

class Foo(TypedDict):
    a: int

class Bar(TypedDict):
    a: int
    b: int

def test(foo: Foo, bar: Bar) -> None:
    # This is technically unsafe since foo can have a subtype of Foo at
    # runtime, where type of key "b" is incompatible with int, see below
    bar.update(foo)

class Bad(Foo):
    b: str
bad: Bad = {"a": 0, "b": "no"}
test(bad, bar)
```

</div>

<div class="option">

\--strict

This flag mode enables all optional error checking flags. You can see the list of flags enabled by strict mode in the full `mypy --help` output.

Note: the exact list of flags enabled by running `--strict` may change over time.

</div>

<div class="option">

\--disable-error-code

This flag allows disabling one or multiple error codes globally. See \[error-codes\](\#error-codes) for more information.

``` python
# no flag
x = 'a string'
x.trim()  # error: "str" has no attribute "trim"  [attr-defined]

# When using --disable-error-code attr-defined
x = 'a string'
x.trim()
```

</div>

<div class="option">

\--enable-error-code

This flag allows enabling one or multiple error codes globally. See \[error-codes\](\#error-codes) for more information.

Note: This flag will override disabled error codes from the `--disable-error-code <mypy --disable-error-code>` flag.

``` python
# When using --disable-error-code attr-defined
x = 'a string'
x.trim()

# --disable-error-code attr-defined --enable-error-code attr-defined
x = 'a string'
x.trim()  # error: "str" has no attribute "trim"  [attr-defined]
```

</div>

<div id="configuring-error-messages">

Configuring error messages `` ` **************************  The following flags let you adjust how much detail mypy displays in error messages.  .. option:: --show-error-context      This flag will precede all errors with "note" messages explaining the     context of the error. For example, consider the following program: ``\`python class Test: def foo(self, x: int) -\> int: return x + "bar"

</div>

> Mypy normally displays an error message that looks like this:
> 
>     main.py:3: error: Unsupported operand types for + ("int" and "str")
> 
> If we enable this flag, the error message now looks like this:
> 
>     main.py: note: In member "foo" of class "Test":
>     main.py:3: error: Unsupported operand types for + ("int" and "str")

<div class="option">

\--show-column-numbers

This flag will add column offsets to error messages. For example, the following indicates an error in line 12, column 9 (note that column offsets are 0-based):

    main.py:12:9: error: Unsupported operand types for / ("int" and "str")

</div>

<div class="option">

\--show-error-code-links

This flag will also display a link to error code documentation, anchored to the error code reported by mypy. The corresponding error code will be highlighted within the documentation page. If we enable this flag, the error message now looks like this:

    main.py:3: error: Unsupported operand types for - ("int" and "str")  [operator]
    main.py:3: note: See 'https://mypy.rtfd.io/en/stable/_refs.html#code-operator' for more info

</div>

<div class="option">

\--show-error-end

This flag will make mypy show not just that start position where an error was detected, but also the end position of the relevant expression. This way various tools can easily highlight the whole error span. The format is `file:line:column:end_line:end_column`. This option implies `--show-column-numbers`.

</div>

<div class="option">

\--hide-error-codes

This flag will hide the error code `[<code>]` from error messages. By default, the error code is shown after each error message:

    prog.py:1: error: "str" has no attribute "trim"  [attr-defined]

See \[error-codes\](\#error-codes) for more information.

</div>

<div class="option">

\--pretty

Use visually nicer output in error messages: use soft word wrap, show source code snippets, and show error location markers.

</div>

<div class="option">

\--no-color-output

This flag will disable color output in error messages, enabled by default.

</div>

<div class="option">

\--no-error-summary

This flag will disable error summary. By default mypy shows a summary line including total number of errors, number of files with errors, and number of files checked.

</div>

<div class="option">

\--show-absolute-path

Show absolute paths to files.

</div>

<div class="option">

\--soft-error-limit N

This flag will adjust the limit after which mypy will (sometimes) disable reporting most additional errors. The limit only applies if it seems likely that most of the remaining errors will not be useful or they may be overly noisy. If `N` is negative, there is no limit. The default limit is -1.

</div>

<div class="option">

\--force-uppercase-builtins

Always use `List` instead of `list` in error messages, even on Python 3.9+.

</div>

<div class="option">

\--force-union-syntax

Always use `Union[]` and `Optional[]` for union types in error messages (instead of the `|` operator), even on Python 3.10+.

</div>

<div id="incremental">

Incremental mode `` ` ****************  By default, mypy will store type information into a cache. Mypy will use this information to avoid unnecessary recomputation when it type checks your code again.  This can help speed up the type checking process, especially when most parts of your program have not changed since the previous mypy run.  If you want to speed up how long it takes to recheck your code beyond what incremental mode can offer, try running mypy in [daemon mode <mypy_daemon>](#daemon-mode-<mypy_daemon>).  .. option:: --no-incremental      This flag disables incremental mode: mypy will no longer reference     the cache when re-run.      Note that mypy will still write out to the cache even when     incremental mode is disabled: see the :option:`--cache-dir` flag below     for more details.  .. option:: --cache-dir DIR      By default, mypy stores all cache data inside of a folder named ``.mypy\_cache`in the current directory. This flag lets you     change this folder. This flag can also be useful for controlling     cache use when using [remote caching <remote-cache>](#remote-caching-<remote-cache>).      This setting will override the`MYPY\_CACHE\_DIR`environment     variable if it is set.      Mypy will also always write to the cache even when incremental     mode is disabled so it can "warm up" the cache. To disable     writing to the cache, use`--cache-dir=/dev/null`(UNIX)     or`--cache-dir=nul``(Windows).  .. option:: --sqlite-cache      Use an `SQLite`_ database to store the cache.  .. option:: --cache-fine-grained      Include fine-grained dependency information in the cache for the mypy daemon.  .. option:: --skip-version-check      By default, mypy will ignore cache data generated by a different     version of mypy. This flag disables that behavior.  .. option:: --skip-cache-mtime-checks      Skip cache internal consistency checks based on mtime.   Advanced options ****************  The following flags are useful mostly for people who are interested in developing or debugging mypy internals.  .. option:: --pdb      This flag will invoke the Python debugger when mypy encounters     a fatal error.  .. option:: --show-traceback, --tb      If set, this flag will display a full traceback when mypy     encounters a fatal error.  .. option:: --raise-exceptions      Raise exception on fatal error.  .. option:: --custom-typing-module MODULE      This flag lets you use a custom module as a substitute for the     :py:mod:`typing` module.  .. option:: --custom-typeshed-dir DIR      This flag specifies the directory where mypy looks for standard library typeshed     stubs, instead of the typeshed that ships with mypy.  This is     primarily intended to make it easier to test typeshed changes before     submitting them upstream, but also allows you to use a forked version of     typeshed.      Note that this doesn't affect third-party library stubs. To test third-party stubs,     for example try``MYPYPATH=stubs/six mypy ...``.  .. _warn-incomplete-stub:  .. option:: --warn-incomplete-stub      This flag modifies both the :option:`--disallow-untyped-defs` and     :option:`--disallow-incomplete-defs` flags so they also report errors     if stubs in typeshed are missing type annotations or has incomplete     annotations. If both flags are missing, :option:`--warn-incomplete-stub`     also does nothing.      This flag is mainly intended to be used by people who want contribute     to typeshed and would like a convenient way to find gaps and omissions.      If you want mypy to report an error when your codebase *uses* an untyped     function, whether that function is defined in typeshed or not, use the     :option:`--disallow-untyped-calls` flag. See [untyped-definitions-and-calls](#untyped-definitions-and-calls)     for more details.  .. _shadow-file:  .. option:: --shadow-file SOURCE_FILE SHADOW_FILE      When mypy is asked to type check``SOURCE\_FILE`, this flag makes mypy     read from and type check the contents of`SHADOW\_FILE`instead. However,     diagnostics will continue to refer to`SOURCE\_FILE`.      Specifying this argument multiple times (`--shadow-file X1 Y1 --shadow-file X2 Y2`)     will allow mypy to perform multiple substitutions.      This allows tooling to create temporary files with helpful modifications     without having to change the source file in place. For example, suppose we     have a pipeline that adds`reveal\_type`for certain variables.     This pipeline is run on`original.py`to produce`temp.py`.     Running`mypy --shadow-file original.py temp.py original.py`will then     cause mypy to type check the contents of`temp.py`instead of`original.py`,     but error messages will still reference`original.py`.   Report generation *****************  If these flags are set, mypy will generate a report in the specified format into the specified directory.  .. option:: --any-exprs-report DIR      Causes mypy to generate a text file report documenting how many     expressions of type`Any``are present within your codebase.  .. option:: --cobertura-xml-report DIR      Causes mypy to generate a Cobertura XML type checking coverage report.      To generate this report, you must either manually install the `lxml`_     library or specify mypy installation with the setuptools extra``mypy\[reports\]``.  .. option:: --html-report / --xslt-html-report DIR      Causes mypy to generate an HTML type checking coverage report.      To generate this report, you must either manually install the `lxml`_     library or specify mypy installation with the setuptools extra``mypy\[reports\]``.  .. option:: --linecount-report DIR      Causes mypy to generate a text file report documenting the functions     and lines that are typed and untyped within your codebase.  .. option:: --linecoverage-report DIR      Causes mypy to generate a JSON file that maps each source file's     absolute filename to a list of line numbers that belong to typed     functions in that file.  .. option:: --lineprecision-report DIR      Causes mypy to generate a flat text file report with per-module     statistics of how many lines are typechecked etc.  .. option:: --txt-report / --xslt-txt-report DIR      Causes mypy to generate a text file type checking coverage report.      To generate this report, you must either manually install the `lxml`_     library or specify mypy installation with the setuptools extra``mypy\[reports\]``.  .. option:: --xml-report DIR      Causes mypy to generate an XML type checking coverage report.      To generate this report, you must either manually install the `lxml`_     library or specify mypy installation with the setuptools extra``mypy\[reports\]`.   Enabling incomplete/experimental features *****************************************  .. option:: --enable-incomplete-feature {PreciseTupleTypes, InlineTypedDict}      Some features may require several mypy releases to implement, for example     due to their complexity, potential for backwards incompatibility, or     ambiguous semantics that would benefit from feedback from the community.     You can enable such features for early preview using this flag. Note that     it is not guaranteed that all features will be ultimately enabled by     default. In *rare cases* we may decide to not go ahead with certain     features.  List of currently incomplete/experimental features:  *`PreciseTupleTypes``: this feature will infer more precise tuple types in   various scenarios. Before variadic types were added to the Python type system   by :pep:`646`, it was impossible to express a type like "a tuple with   at least two integers". The best type available was``tuple\[int, ...\]`.   Therefore, mypy applied very lenient checking for variable-length tuples.   Now this type can be expressed as`tuple\[int, int, *tuple\[int, ...\]\]\`\`. For such more precise types (when explicitly*defined\* by a user) mypy, for example, warns about unsafe index access, and generally handles them in a type-safe manner. However, to avoid problems in existing code, mypy does not *infer* these precise types when it technically can. Here are notable examples where `PreciseTupleTypes` infers more precise types:

</div>

>   - \`\`\`python  
>     numbers: tuple\[int, ...\]
>     
>     more\_numbers = (1, *numbers, 1) reveal\_type(more\_numbers) \# Without PreciseTupleTypes: tuple\[int, ...\] \# With PreciseTupleTypes: tuple\[int,*tuple\[int, ...\], int\]
>     
>     other\_numbers = (1, 1) + numbers reveal\_type(other\_numbers) \# Without PreciseTupleTypes: tuple\[int, ...\] \# With PreciseTupleTypes: tuple\[int, int, \*tuple\[int, ...\]\]
>     
>       - if len(numbers) \> 2:  
>         reveal\_type(numbers) \# Without PreciseTupleTypes: tuple\[int, ...\] \# With PreciseTupleTypes: tuple\[int, int, int, \*tuple\[int, ...\]\]
>     
>       - else:  
>         reveal\_type(numbers) \# Without PreciseTupleTypes: tuple\[int, ...\] \# With PreciseTupleTypes: tuple\[()\] | tuple\[int\] | tuple\[int, int\]

  - `InlineTypedDict`: this feature enables non-standard syntax for inline \[TypedDicts \<typeddict\>\](\#typeddicts-\<typeddict\>), for example:
    
    ``` python
    def test_values() -> {"int": int, "str": str}:
        return {"int": 42, "str": "test"}
    ```

Miscellaneous `` ` *************  .. option:: --install-types      This flag causes mypy to install known missing stub packages for     third-party libraries using pip.  It will display the pip command     that will be run, and expects a confirmation before installing     anything. For security reasons, these stubs are limited to only a     small subset of manually selected packages that have been     verified by the typeshed team. These packages include only stub     files and no executable code.      If you use this option without providing any files or modules to     type check, mypy will install stub packages suggested during the     previous mypy run. If there are files or modules to type check,     mypy first type checks those, and proposes to install missing     stubs at the end of the run, but only if any missing modules were     detected.      > **Note** >          This is new in mypy 0.900. Previous mypy versions included a         selection of third-party package stubs, instead of having         them installed separately.  .. option:: --non-interactive     When used together with :option:`--install-types <mypy    --install-types>`, this causes mypy to install all suggested stub    packages using pip without asking for confirmation, and then    continues to perform type checking using the installed stubs, if    some files or modules are provided to type check.     This is implemented as up to two mypy runs internally. The first run    is used to find missing stub packages, and output is shown from    this run only if no missing stub packages were found. If missing    stub packages were found, they are installed and then another run    is performed.  .. option:: --junit-xml JUNIT_XML      Causes mypy to generate a JUnit XML test result document with     type checking results. This can make it easier to integrate mypy     with continuous integration (CI) tools.  .. option:: --find-occurrences CLASS.MEMBER      This flag will make mypy print out all usages of a class member     based on static type information. This feature is experimental.  .. option:: --scripts-are-modules      This flag will give command line arguments that appear to be     scripts (i.e. files whose name does not end in ``.py\`<span class="title-ref">) a module name derived from the script name rather than the fixed name :py:mod:</span>\_\_main\_\_\`.

> This lets you check more than one script in a single mypy invocation. (The default :py`__main__` is technically more correct, but if you have many scripts that import a large package, the behavior enabled by this flag is often more convenient.)

---

common_issues.md

---

# Common issues and solutions

This section has examples of cases when you need to update your code to use static typing, and ideas for working around issues if mypy doesn't work as expected. Statically typed code is often identical to normal Python code (except for type annotations), but sometimes you need to do things slightly differently.

## No errors reported for obviously wrong code

There are several common reasons why obviously wrong code is not flagged as an error.

**The function containing the error is not annotated.**

Functions that do not have any annotations (neither for any argument nor for the return type) are not type-checked, and even the most blatant type errors (e.g. `2 + 'a'`) pass silently. The solution is to add annotations. Where that isn't possible, functions without annotations can be checked using `--check-untyped-defs <mypy --check-untyped-defs>`.

Example:

`` `python     def foo(a):         return '(' + a.split() + ')'  # No error!  This gives no error even though ``a.split()`is "obviously" a list`<span class="title-ref"> (the author probably meant </span><span class="title-ref">a.strip()</span>\`). The error is reported once you add annotations:

`` `python     def foo(a: str) -> str:         return '(' + a.split() + ')'     # error: Unsupported operand types for + ("str" and "list[str]")  If you don't know what types to add, you can use ``Any`, but beware:  **One of the values involved has type 'Any'.**  Extending the above`<span class="title-ref"> example, if we were to leave out the annotation for </span><span class="title-ref">a</span>\`, we'd get no error:

`` `python     def foo(a) -> str:         return '(' + a.split() + ')'  # No error!  The reason is that if the type of ``a`is unknown, the type of`<span class="title-ref"> </span><span class="title-ref">a.split()</span><span class="title-ref"> is also unknown, so it is inferred as having type </span><span class="title-ref">Any</span><span class="title-ref">, and it is no error to add a string to an </span><span class="title-ref">Any</span>\`.

If you're having trouble debugging such situations, \[reveal\_type() \<reveal-type\>\](\#reveal\_type()-\<reveal-type\>) might come in handy.

Note that sometimes library stubs with imprecise type information can be a source of `Any` values.

:py\`\_\_init\_\_ \<object.\_\_init\_\_\>\` **method has no annotated arguments and no return type annotation.**

This is basically a combination of the two cases above, in that `__init__` without annotations can cause `Any` types leak into instance variables:

`` `python     class Bad:         def __init__(self):             self.value = "asdf"             1 + "asdf"  # No error!      bad = Bad()     bad.value + 1           # No error!     reveal_type(bad)        # Revealed type is "__main__.Bad"     reveal_type(bad.value)  # Revealed type is "Any"      class Good:         def __init__(self) -> None:  # Explicitly return None             self.value = value   **Some imports may be silently ignored**.  A common source of unexpected ``Any`values is the`<span class="title-ref"> :option:</span>--ignore-missing-imports \<mypy --ignore-missing-imports\>\` flag.

When you use `--ignore-missing-imports <mypy --ignore-missing-imports>`, any imported module that cannot be found is silently replaced with `Any`.

To help debug this, simply leave out `--ignore-missing-imports <mypy --ignore-missing-imports>`. As mentioned in \[fix-missing-imports\](\#fix-missing-imports), setting `ignore_missing_imports=True` on a per-module basis will make bad surprises less likely and is highly encouraged.

Use of the `--follow-imports=skip <mypy --follow-imports>` flags can also cause problems. Use of these flags is strongly discouraged and only required in relatively niche situations. See \[follow-imports\](\#follow-imports) for more information.

**mypy considers some of your code unreachable**.

See \[unreachable\](\#unreachable) for more information.

**A function annotated as returning a non-optional type returns 'None' and mypy doesn't complain**.

`` `python     def foo() -> str:         return None  # No error!  You may have disabled strict optional checking (see ``\` \[--no-strict-optional \<no\_strict\_optional\>\](\#--no-strict-optional-\<no\_strict\_optional\>) for more).

## Spurious errors and locally silencing the checker

You can use a `# type: ignore` comment to silence the type checker on a particular line. For example, let's say our code is using the C extension module `frobnicate`, and there's no stub available. Mypy will complain about this, as it has no information about the module:

`` `python     import frobnicate  # Error: No module "frobnicate"     frobnicate.start()  You can add a ``\# type: ignore`comment to tell mypy to ignore this`\` error:

`` `python     import frobnicate  # type: ignore     frobnicate.start()  # Okay!  The second line is now fine, since the ignore comment causes the name ``<span class="title-ref"> </span><span class="title-ref">frobnicate</span><span class="title-ref"> to get an implicit </span><span class="title-ref">Any</span>\` type.

\> **Note** \> You can use the form `# type: ignore[<code>]` to only ignore specific errors on the line. This way you are less likely to silence unexpected errors that are not safe to ignore, and this will also document what the purpose of the comment is. See \[error-codes\](\#error-codes) for more information.

<div class="note">

<div class="title">

Note

</div>

The `# type: ignore` comment will only assign the implicit `Any` type if mypy cannot find information about that particular module. So, if we did have a stub available for `frobnicate` then mypy would ignore the `# type: ignore` comment and typecheck the stub as usual.

</div>

Another option is to explicitly annotate values with type `Any` --mypy will let you perform arbitrary operations on `Any` values. Sometimes there is no more precise type you can use for a particular value, especially if you use dynamic Python features such as :py\`\_\_getattr\_\_ \<object.\_\_getattr\_\_\>\`:

`` `python    class Wrapper:        ...        def __getattr__(self, a: str) -> Any:            return getattr(self._wrapped, a)  Finally, you can create a stub file ( ``.pyi`) for a file that`<span class="title-ref"> generates spurious errors. Mypy will only look at the stub file and ignore the implementation, since stub files take precedence over </span><span class="title-ref">.py</span>\` files.

## Ignoring a whole file

  - To only ignore errors, use a top-level `# mypy: ignore-errors` comment instead.
  - To only ignore errors with a specific error code, use a top-level `# mypy: disable-error-code="..."` comment. Example: `# mypy: disable-error-code="truthy-bool, ignore-without-code"`
  - To replace the contents of a module with `Any`, use a per-module `follow_imports = skip`. See \[Following imports \<follow-imports\>\](\#following-imports-\<follow-imports\>) for details.

Note that a `# type: ignore` comment at the top of a module (before any statements, including imports or docstrings) has the effect of ignoring the entire contents of the module. This behaviour can be surprising and result in "Module ... has no attribute ... \[attr-defined\]" errors.

## Issues with code at runtime

Idiomatic use of type annotations can sometimes run up against what a given version of Python considers legal code. These can result in some of the following errors when trying to run your code:

  - `ImportError` from circular imports
  - `NameError: name "X" is not defined` from forward references
  - `TypeError: 'type' object is not subscriptable` from types that are not generic at runtime
  - `ImportError` or `ModuleNotFoundError` from use of stub definitions not available at runtime
  - `TypeError: unsupported operand type(s) for |: 'type' and 'type'` from use of new syntax

For dealing with these, see \[runtime\_troubles\](\#runtime\_troubles).

## Mypy runs are slow

If your mypy runs feel slow, you should probably use the \[mypy daemon \<mypy\_daemon\>\](\#mypy daemon-\<mypy\_daemon\>), which can speed up incremental mypy runtimes by a factor of 10 or more. \[Remote caching \<remote-cache\>\](\#remote-caching-\<remote-cache\>) can make cold mypy runs several times faster.

## Types of empty collections

You often need to specify the type when you assign an empty list or dict to a new variable, as mentioned earlier:

`` `python    a: list[int] = []  Without the annotation mypy can't always figure out the ``<span class="title-ref"> precise type of </span><span class="title-ref">a</span>\`.

You can use a simple empty list literal in a dynamically typed function (as the type of `a` would be implicitly `Any` and need not be inferred), if type of the variable has been declared or inferred before, or if you perform a simple modification operation in the same scope (such as `append` for a list):

`` `python    a = []  # Okay because followed by append, inferred type list[int]    for i in range(n):        a.append(i * i)  However, in more complex cases an explicit type annotation can be ``\` required (mypy will tell you this). Often the annotation can make your code easier to understand, so it doesn't only help mypy but everybody who is reading the code\!

## Redefinitions with incompatible types

Each name within a function only has a single 'declared' type. You can reuse for loop indices etc., but if you want to use a variable with multiple types within a single function, you may need to instead use multiple variables (or maybe declare the variable with an `Any` type).

`` `python    def f() -> None:        n = 1        ...        n = 'x'  # error: Incompatible types in assignment (expression has type "str", variable has type "int")  > **Note** >     Using the :option:`--allow-redefinition <mypy --allow-redefinition>`    flag can suppress this error in several cases.  Note that you can redefine a variable with a more *precise* or a more ``<span class="title-ref"> concrete type. For example, you can redefine a sequence (which does not support </span><span class="title-ref">sort()</span>\`) as a list and sort it in-place:

`` `python     def f(x: Sequence[int]) -> None:         # Type of x is Sequence[int] here; we don't know the concrete type.         x = list(x)         # Type of x is list[int] here.         x.sort()  # Okay!  See [type-narrowing](#type-narrowing) for more information.  .. _variance:  Invariance vs covariance ``\` ------------------------

Most mutable generic collections are invariant, and mypy considers all user-defined generic classes invariant by default (see \[variance-of-generics\](\#variance-of-generics) for motivation). This could lead to some unexpected errors when combined with type inference. For example:

`` `python    class A: ...    class B(A): ...     lst = [A(), A()]  # Inferred type is list[A]    new_lst = [B(), B()]  # inferred type is list[B]    lst = new_lst  # mypy will complain about this, because List is invariant  Possible strategies in such situations are:  * Use an explicit type annotation:    .. code-block:: python       new_lst: list[A] = [B(), B()]      lst = new_lst  # OK  * Make a copy of the right hand side:    .. code-block:: python       lst = list(new_lst) # Also OK  * Use immutable collections as annotations whenever possible:    .. code-block:: python       def f_bad(x: list[A]) -> A:          return x[0]      f_bad(new_lst) # Fails       def f_good(x: Sequence[A]) -> A:          return x[0]      f_good(new_lst) # OK  Declaring a supertype as variable type ``\` --------------------------------------

Sometimes the inferred type is a subtype (subclass) of the desired type. The type inference uses the first assignment to infer the type of a name:

`` `python    class Shape: ...    class Circle(Shape): ...    class Triangle(Shape): ...     shape = Circle()    # mypy infers the type of shape to be Circle    shape = Triangle()  # error: Incompatible types in assignment (expression has type "Triangle", variable has type "Circle")  You can just give an explicit type for the variable in cases such the ``\` above example:

`` `python    shape: Shape = Circle()  # The variable s can be any Shape, not just Circle    shape = Triangle()       # OK  Complex type tests ``\` ------------------

Mypy can usually infer the types correctly when using :py\`isinstance \<isinstance\><span class="title-ref">, :py\`issubclass \<issubclass\></span>, or `type(obj) is some_class` type tests, and even \[user-defined type guards \<type-guards\>\](\#user-defined-type-guards-\<type-guards\>), but for other kinds of checks you may need to add an explicit type cast:

`` `python   from collections.abc import Sequence   from typing import cast    def find_first_str(a: Sequence[object]) -> str:       index = next((i for i, s in enumerate(a) if isinstance(s, str)), -1)       if index < 0:           raise ValueError('No str found')        found = a[index]  # Has type "object", despite the fact that we know it is "str"       return cast(str, found)  # We need an explicit cast to make mypy happy  Alternatively, you can use an ``assert`statement together with some`\` of the supported type inference techniques:

`` `python   def find_first_str(a: Sequence[object]) -> str:       index = next((i for i, s in enumerate(a) if isinstance(s, str)), -1)       if index < 0:           raise ValueError('No str found')        found = a[index]  # Has type "object", despite the fact that we know it is "str"       assert isinstance(found, str)  # Now, "found" will be narrowed to "str"       return found  # No need for the explicit "cast()" anymore  > **Note** >      Note that the :py`object` type used in the above example is similar     to ``Object``in Java: it only supports operations defined for *all*     objects, such as equality and :py`isinstance`. The type``Any`,     in contrast, supports all operations, even if they may fail at     runtime. The cast above would have been unnecessary if the type of`o`was`Any`.  .. note::     You can read more about type narrowing techniques [here <type-narrowing>](#here-<type-narrowing>).  Type inference in Mypy is designed to work well in common cases, to be`\` predictable and to let the type checker give useful error messages. More powerful type inference strategies often have complex and difficult-to-predict failure modes and could result in very confusing error messages. The tradeoff is that you as a programmer sometimes have to give the type checker a little help.

## Python version and system platform checks

Mypy supports the ability to perform Python version checks and platform checks (e.g. Windows vs Posix), ignoring code paths that won't be run on the targeted Python version or platform. This allows you to more effectively typecheck code that supports multiple versions of Python or multiple operating systems.

More specifically, mypy will understand the use of :py\`sys.version\_info\` and :py\`sys.platform\` checks within `if/elif/else` statements. For example:

`` `python    import sys     # Distinguishing between different versions of Python:    if sys.version_info >= (3, 8):        # Python 3.8+ specific definitions and imports    else:        # Other definitions and imports     # Distinguishing between different operating systems:    if sys.platform.startswith("linux"):        # Linux-specific code    elif sys.platform == "darwin":        # Mac-specific code    elif sys.platform == "win32":        # Windows-specific code    else:        # Other systems  As a special case, you can also use one of these checks in a top-level ``<span class="title-ref"> (unindented) </span><span class="title-ref">assert</span>\`; this makes mypy skip the rest of the file. Example:

`` `python    import sys     assert sys.platform != 'win32'     # The rest of this file doesn't apply to Windows.  Some other expressions exhibit similar behavior; in particular, ``<span class="title-ref"> :py</span>\~typing.TYPE\_CHECKING\`, variables named `MYPY`, and any variable whose name is passed to `--always-true <mypy --always-true>` or `--always-false <mypy --always-false>`. (However, `True` and `False` are not treated specially\!)

\> **Note** \> Mypy currently does not support more complex checks, and does not assign any special meaning when assigning a :py\`sys.version\_info\` or :py\`sys.platform\` check to a variable. This may change in future versions of mypy.

By default, mypy will use your current version of Python and your current operating system as default values for :py\`sys.version\_info\` and :py\`sys.platform\`.

To target a different Python version, use the `--python-version X.Y <mypy --python-version>` flag. For example, to verify your code typechecks if were run using Python 3.8, pass in `--python-version 3.8 <mypy --python-version>` from the command line. Note that you do not need to have Python 3.8 installed to perform this check.

To target a different operating system, use the `--platform PLATFORM <mypy --platform>` flag. For example, to verify your code typechecks if it were run in Windows, pass in `--platform win32 <mypy --platform>`. See the documentation for :py\`sys.platform\` for examples of valid platform parameters.

## Displaying the type of an expression

You can use `reveal_type(expr)` to ask mypy to display the inferred static type of an expression. This can be useful when you don't quite understand how mypy handles a particular piece of code. Example:

`` `python    reveal_type((1, 'hello'))  # Revealed type is "tuple[builtins.int, builtins.str]"  You can also use ``reveal\_locals()`at any line in a file`\` to see the types of all local variables at once. Example:

  - `` `python a = 1 b = 'one' reveal_locals() # Revealed local types are: #     a: builtins.int #     b: builtins.str ``<span class="title-ref"> \> \*\*Note\*\* \> </span><span class="title-ref">reveal\_type</span><span class="title-ref"> and </span><span class="title-ref">reveal\_locals</span><span class="title-ref"> are only understood by mypy and don't exist in Python. If you try to run your program, you'll have to remove any </span><span class="title-ref">reveal\_type</span><span class="title-ref"> and </span><span class="title-ref">reveal\_locals</span>\` calls before you can  
    run your code. Both are always available and you don't need to import them.

## Silencing linters

In some cases, linters will complain about unused imports or code. In these cases, you can silence them with a comment after type comments, or on the same line as the import:

`` `python    # to silence complaints about unused imports    from typing import List  # noqa    a = None  # type: List[int]   To silence the linter on the same line as a type comment ``\` put the linter comment *after* the type comment:

`` `python     a = some_complex_thing()  # type: ignore  # noqa  Covariant subtyping of mutable protocol members is rejected ``\` -----------------------------------------------------------

Mypy rejects this because this is potentially unsafe. Consider this example:

`` `python    from typing import Protocol     class P(Protocol):        x: float     def fun(arg: P) -> None:        arg.x = 3.14     class C:        x = 42    c = C()    fun(c)  # This is not safe    c.x << 5  # Since this will fail!  To work around this problem consider whether "mutating" is actually part ``<span class="title-ref"> of a protocol. If not, then one can use a :py</span>@property \<property\>\` in the protocol definition:

`` `python    from typing import Protocol     class P(Protocol):        @property        def x(self) -> float:           pass     def fun(arg: P) -> None:        ...     class C:        x = 42    fun(C())  # OK  Dealing with conflicting names ``\` ------------------------------

Suppose you have a class with a method whose name is the same as an imported (or built-in) type, and you want to use the type in another method signature. E.g.:

`` `python    class Message:        def bytes(self):            ...        def register(self, path: bytes):  # error: Invalid type "mod.Message.bytes"            ...  The third line elicits an error because mypy sees the argument type ``<span class="title-ref"> </span><span class="title-ref">bytes</span>\` as a reference to the method by that name. Other than renaming the method, a workaround is to use an alias:

`` `python    bytes_ = bytes    class Message:        def bytes(self):            ...        def register(self, path: bytes_):            ...  Using a development mypy build ``\` ------------------------------

You can install the latest development version of mypy from source. Clone the [mypy repository on GitHub](https://github.com/python/mypy), and then run `pip install` locally:

`` `text     git clone https://github.com/python/mypy.git     cd mypy     python3 -m pip install --upgrade .  To install a development version of mypy that is mypyc-compiled, see the ``<span class="title-ref"> instructions at the \`mypyc wheels repo \<https://github.com/mypyc/mypy\_mypyc-wheels\></span>\_.

## Variables vs type aliases

Mypy has both *type aliases* and variables with types like `type[...]`. These are subtly different, and it's important to understand how they differ to avoid pitfalls.

1.  A variable with type `type[...]` is defined using an assignment with an explicit type annotation:
    
      - \`\`\`python  
        class A: ... tp: type\[A\] = A

2.  You can define a type alias using an assignment without an explicit type annotation at the top level of a module:
    
    ``` python
    class A: ...
    Alias = A
    ```
    
    You can also use `TypeAlias` (`613`) to define an *explicit type alias*:
    
    ``` python
    from typing import TypeAlias  # "from typing_extensions" in Python 3.9 and earlier
    
    class A: ...
    Alias: TypeAlias = A
    ```
    
    You should always use `TypeAlias` to define a type alias in a class body or inside a function.

The main difference is that the target of an alias is precisely known statically, and this `` ` means that they can be used in type annotations and other *type contexts*. Type aliases can't be defined conditionally (unless using [supported Python version and platform checks <version_and_platform_checks>](#supported-python-version-and-platform-checks-<version_and_platform_checks>)): ``\`python class A: ... class B: ...

>   - if random() \> 0.5:  
>     Alias = A
> 
>   - else:  
>     \# error: Cannot assign multiple types to name "Alias" without an \# explicit "Type\[...\]" annotation Alias = B
> 
> tp: type\[object\] \# "tp" is a variable with a type object value if random() \> 0.5: tp = A else: tp = B \# This is OK
> 
> def fun1(x: Alias) -\> None: ... \# OK def fun2(x: tp) -\> None: ... \# Error: "tp" is not valid as a type

Incompatible overrides `` ` ----------------------  It's unsafe to override a method with a more specific argument type, as it violates the `Liskov substitution principle <https://stackoverflow.com/questions/56860/what-is-an-example-of-the-liskov-substitution-principle>`_. For return types, it's unsafe to override a method with a more general return type.  Other incompatible signature changes in method overrides, such as adding an extra required parameter, or removing an optional parameter, will also generate errors. The signature of a method in a subclass should accept all valid calls to the base class method. Mypy treats a subclass as a subtype of the base class. An instance of a subclass is valid everywhere where an instance of the base class is valid.  This example demonstrates both safe and unsafe overrides: ``\`python from collections.abc import Sequence, Iterable

>   - class A:
>     
>       - def test(self, t: Sequence\[int\]) -\> Sequence\[str\]:  
>         ...
> 
>   - class GeneralizedArgument(A):  
>     \# A more general argument type is okay def test(self, t: Iterable\[int\]) -\> Sequence\[str\]: \# OK ...
> 
>   - class NarrowerArgument(A):  
>     \# A more specific argument type isn't accepted def test(self, t: list\[int\]) -\> Sequence\[str\]: \# Error ...
> 
>   - class NarrowerReturn(A):  
>     \# A more specific return type is fine def test(self, t: Sequence\[int\]) -\> List\[str\]: \# OK ...
> 
>   - class GeneralizedReturn(A):  
>     \# A more general return type is an error def test(self, t: Sequence\[int\]) -\> Iterable\[str\]: \# Error ...

You can use `# type: ignore[override]` to silence the error. Add it `` ` to the line that generates the error, if you decide that type safety is not necessary: ``\`python class NarrowerArgument(A): def test(self, t: List\[int\]) -\> Sequence\[str\]: \# type: ignore\[override\] ...

<div id="unreachable">

Unreachable code `` ` ----------------  Mypy may consider some code as *unreachable*, even if it might not be immediately obvious why.  It's important to note that mypy will *not* type check such code. Consider this example: ``\`python class Foo: bar: str = ''

</div>

>   - def bar() -\> None:  
>     foo: Foo = Foo() return x: int = 'abc' \# Unreachable -- no error

It's easy to see that any statement after `return` is unreachable, `` ` and hence mypy will not complain about the mis-typed code below it. For a more subtle example, consider this code: ``\`python class Foo: bar: str = ''

>   - def bar() -\> None:  
>     foo: Foo = Foo() assert foo.bar is None x: int = 'abc' \# Unreachable -- no error

Again, mypy will not report any errors. The type of `foo.bar` is `` ` ``str`, and mypy reasons that it can never be`None`.  Hence the`assert`statement will always fail and the statement below will never be executed.  (Note that in Python,`None`is not an empty reference but an object of type`None`.)  In this example mypy will go on to check the last line and report an error, since mypy thinks that the condition could be either True or False:`\`python class Foo: bar: str = ''

>   - def bar() -\> None:  
>     foo: Foo = Foo() if not foo.bar: return x: int = 'abc' \# Reachable -- error

If you use the `--warn-unreachable <mypy --warn-unreachable>` flag, mypy will generate `` ` an error about each unreachable code block.  Narrowing and inner functions -----------------------------  Because closures in Python are late-binding (https://docs.python-guide.org/writing/gotchas/#late-binding-closures), mypy will not narrow the type of a captured variable in an inner function. This is best understood via an example: ``\`python def foo(x: int | None) -\> Callable\[\[\], int\]: if x is None: x = 5 print(x + 1) \# mypy correctly deduces x must be an int here def inner() -\> int: return x + 1 \# but (correctly) complains about this line

> x = None \# because x could later be assigned None return inner
> 
> inner = foo(5) inner() \# this will raise an error when called

To get this code to type check, you could assign `y = x` after `x` has been `` ` narrowed, and use ``y\`\` in the inner function, or add an assert in the inner function.

---

config_file.md

---

# The mypy configuration file

Mypy is very configurable. This is most useful when introducing typing to an existing codebase. See \[existing-code\](\#existing-code) for concrete advice for that situation.

Mypy supports reading configuration settings from a file with the following precedence order:

> 1.  `./mypy.ini`
> 2.  `./.mypy.ini`
> 3.  `./pyproject.toml`
> 4.  `./setup.cfg`
> 5.  `$XDG_CONFIG_HOME/mypy/config`
> 6.  `~/.config/mypy/config`
> 7.  `~/.mypy.ini`

It is important to understand that there is no merging of configuration files, as it would lead to ambiguity. The `--config-file <mypy --config-file>` command-line flag has the highest precedence and must be correct; otherwise mypy will report an error and exit. Without the command line option, mypy will look for configuration files in the precedence order above.

Most flags correspond closely to \[command-line flags \<command-line\>\](\#command-line-flags \<command-line\>) but there are some differences in flag names and some flags may take a different value based on the module being processed.

Some flags support user home directory and environment variable expansion. To refer to the user home directory, use `~` at the beginning of the path. To expand environment variables use `$VARNAME` or `${VARNAME}`.

## Config file format

The configuration file format is the usual \[ini file \<python:library/configparser\>\](ini file \<python:library/configparser\>.md) format. It should contain section names in square brackets and flag settings of the form <span class="title-ref">NAME = VALUE</span>. Comments start with `#` characters.

  - A section named `[mypy]` must be present. This specifies the global flags.

  - Additional sections named `[mypy-PATTERN1,PATTERN2,...]` may be present, where `PATTERN1`, `PATTERN2`, etc., are comma-separated patterns of fully-qualified module names, with some components optionally replaced by the '*' character (e.g. \`\`foo.bar\`\`, \`\`foo.bar.*`,`foo.*.baz\`\`). These sections specify additional flags that only apply to*modules\* whose name matches at least one of the patterns.
    
    A pattern of the form `qualified_module_name` matches only the named module, while `dotted_module_name.*` matches `dotted_module_name` and any submodules (so `foo.bar.*` would match all of `foo.bar`, `foo.bar.baz`, and `foo.bar.baz.quux`).
    
    Patterns may also be "unstructured" wildcards, in which stars may appear in the middle of a name (e.g `site.*.migrations.*`). Stars match zero or more module components (so `site.*.migrations.*` can match `site.migrations`).
    
    <div id="config-precedence">
    
    When options conflict, the precedence order for configuration is:
    
    </div>
    
    > 1.  \[Inline configuration \<inline-config\>\](\#inline-configuration-\<inline-config\>) in the source file
    > 2.  Sections with concrete module names (`foo.bar`)
    > 3.  Sections with "unstructured" wildcard patterns (`foo.*.baz`), with sections later in the configuration file overriding sections earlier.
    > 4.  Sections with "well-structured" wildcard patterns (`foo.bar.*`), with more specific overriding more general.
    > 5.  Command line options.
    > 6.  Top-level configuration file options.

The difference in precedence order between "structured" patterns (by specificity) and "unstructured" patterns (by order in the file) is unfortunate, and is subject to change in future versions.

\> **Note** \> The `warn_unused_configs` flag may be useful to debug misspelled section names.

<div class="note">

<div class="title">

Note

</div>

Configuration flags are liable to change between releases.

</div>

## Per-module and global options

Some of the config options may be set either globally (in the `[mypy]` section) or on a per-module basis (in sections like `[mypy-foo.bar]`).

If you set an option both globally and for a specific module, the module configuration options take precedence. This lets you set global defaults and override them on a module-by-module basis. If multiple pattern sections match a module, \[the options from the most specific section are used where they disagree \<config-precedence\>\](\#the-options-from-the most-specific-section-are-used-where-they-disagree-\<config-precedence\>).

Some other options, as specified in their description, may only be set in the global section (`[mypy]`).

## Inverting option values

Options that take a boolean value may be inverted by adding `no_` to their name or by (when applicable) swapping their prefix from `disallow` to `allow` (and vice versa).

## Example `mypy.ini`

Here is an example of a `mypy.ini` file. To use this config file, place it at the root of your repo and run mypy.

`` `ini     # Global options:      [mypy]     warn_return_any = True     warn_unused_configs = True      # Per-module options:      [mypy-mycode.foo.*]     disallow_untyped_defs = True      [mypy-mycode.bar]     warn_return_any = False      [mypy-somelibrary]     ignore_missing_imports = True  This config file specifies two global options in the ``\[mypy\]`section. These two`\` options will:

1.  Report an error whenever a function returns a value that is inferred to have type `Any`.
2.  Report any config options that are unused by mypy. (This will help us catch typos when making changes to our config file).

Next, this module specifies three per-module options. The first two options change how mypy type checks code in `mycode.foo.*` and `mycode.bar`, which we assume here are two modules that you wrote. The final config option changes how mypy type checks `somelibrary`, which we assume here is some 3rd party library you've installed and are importing. These options will:

1.  Selectively disallow untyped function definitions only within the `mycode.foo` package -- that is, only for function definitions defined in the `mycode/foo` directory.
2.  Selectively *disable* the "function is returning any" warnings within `mycode.bar` only. This overrides the global default we set earlier.
3.  Suppress any error messages generated when your codebase tries importing the module `somelibrary`. This is useful if `somelibrary` is some 3rd party library missing type hints.

## Import discovery

For more information, see the \[Import discovery \<import-discovery\>\](\#import-discovery-\<import-discovery\>) section of the command line docs.

<div class="confval">

mypy\_path

  - type  
    string

Specifies the paths to use, after trying the paths from `MYPYPATH` environment variable. Useful if you'd like to keep stubs in your repo, along with the config file. Multiple paths are always separated with a `:` or `,` regardless of the platform. User home directory and environment variables will be expanded.

Relative paths are treated relative to the working directory of the mypy command, not the config file. Use the `MYPY_CONFIG_FILE_DIR` environment variable to refer to paths relative to the config file (e.g. `mypy_path = $MYPY_CONFIG_FILE_DIR/src`).

This option may only be set in the global section (`[mypy]`).

**Note:** On Windows, use UNC paths to avoid using `:` (e.g. `\\127.0.0.1\X$\MyDir` where `X` is the drive letter).

</div>

<div class="confval">

files

  - type  
    comma-separated list of strings

A comma-separated list of paths which should be checked by mypy if none are given on the command line. Supports recursive file globbing using :py`glob`, where `*` (e.g. `*.py`) matches files in the current directory and `**/` (e.g. `**/*.py`) matches files in any directories below the current one. User home directory and environment variables will be expanded.

This option may only be set in the global section (`[mypy]`).

</div>

<div class="confval">

modules

  - type  
    comma-separated list of strings

A comma-separated list of packages which should be checked by mypy if none are given on the command line. Mypy *will not* recursively type check any submodules of the provided module.

This option may only be set in the global section (`[mypy]`).

</div>

<div class="confval">

packages

  - type  
    comma-separated list of strings

A comma-separated list of packages which should be checked by mypy if none are given on the command line. Mypy *will* recursively type check any submodules of the provided package. This flag is identical to `modules` apart from this behavior.

This option may only be set in the global section (`[mypy]`).

</div>

<div class="confval">

exclude

  - type  
    regular expression

A regular expression that matches file names, directory names and paths which mypy should ignore while recursively discovering files to check. Use forward slashes (`/`) as directory separators on all platforms.

`` `ini   [mypy]   exclude = (?x)(       ^one\.py$    # files named "one.py"       | two\.pyi$  # or files ending with "two.pyi"       | ^three\.   # or files starting with "three."     )  Crafting a single regular expression that excludes multiple files while remaining human-readable can be a challenge. The above example demonstrates one approach. ``(?x)`enables the`VERBOSE``flag for the subsequent regular expression, which :py`ignores most whitespace and supports comments <re.VERBOSE>`. The above is equivalent to:``(^one.py$^three.)``.  For more details, see :option:`--exclude <mypy --exclude>`.  This option may only be set in the global section (``\[mypy\]\`\`).

\> **Note**

</div>

  - \>  
    Note that the TOML equivalent differs slightly. It can be either a single string (including a multi-line string) -- which is treated as a single regular expression -- or an array of such strings. The following TOML examples are equivalent to the above INI example.
    
    Array of strings:
    
    ``` toml
    [tool.mypy]
    exclude = [
        "^one\\.py$",  # TOML's double-quoted strings require escaping backslashes
        'two\.pyi$',  # but TOML's single-quoted strings do not
        '^three\.',
    ]
    ```
    
    A single, multi-line string:
    
    ``` toml
    [tool.mypy]
    exclude = '''(?x)(
        ^one\.py$    # files named "one.py"
        | two\.pyi$  # or files ending with "two.pyi"
        | ^three\.   # or files starting with "three."
    )'''  # TOML's single-quoted strings do not require escaping backslashes
    ```
    
    See \[using-a-pyproject-toml\](\#using-a-pyproject-toml).

<div class="confval">

namespace\_packages

  - type  
    boolean

  - default  
    True

Enables `420` style namespace packages. See the corresponding flag `--no-namespace-packages <mypy --no-namespace-packages>` for more information.

This option may only be set in the global section (`[mypy]`).

</div>

<div class="confval">

explicit\_package\_bases

  - type  
    boolean

  - default  
    False

This flag tells mypy that top-level packages will be based in either the current directory, or a member of the `MYPYPATH` environment variable or `mypy_path` config option. This option is only useful in the absence of <span class="title-ref">\_\_init\_\_.py</span>. See \[Mapping file paths to modules \<mapping-paths-to-modules\>\](\#mapping-file

</div>

\----paths-to-modules-\<mapping-paths-to-modules\>) for details.

> This option may only be set in the global section (`[mypy]`).

<div class="confval">

ignore\_missing\_imports

  - type  
    boolean

  - default  
    False

Suppresses error messages about imports that cannot be resolved.

If this option is used in a per-module section, the module name should match the name of the *imported* module, not the module containing the import statement.

</div>

<div class="confval">

follow\_imports

  - type  
    string

  - default  
    `normal`

Directs what to do with imports when the imported module is found as a `.py` file and not part of the files, modules and packages provided on the command line.

The four possible values are `normal`, `silent`, `skip` and `error`. For explanations see the discussion for the `--follow-imports <mypy --follow-imports>` command line flag.

Using this option in a per-module section (potentially with a wildcard, as described at the top of this page) is a good way to prevent mypy from checking portions of your code.

If this option is used in a per-module section, the module name should match the name of the *imported* module, not the module containing the import statement.

</div>

<div class="confval">

follow\_imports\_for\_stubs

  - type  
    boolean

  - default  
    False

Determines whether to respect the `follow_imports` setting even for stub (`.pyi`) files.

Used in conjunction with `follow_imports=skip <follow_imports>`, this can be used to suppress the import of a module from `typeshed`, replacing it with `Any`.

Used in conjunction with `follow_imports=error <follow_imports>`, this can be used to make any use of a particular `typeshed` module an error.

<div class="note">

<div class="title">

Note

</div>

This is not supported by the mypy daemon.

</div>

</div>

<div class="confval">

python\_executable

  - type  
    string

Specifies the path to the Python executable to inspect to collect a list of available \[PEP 561 packages \<installed-packages\>\](\#pep-561-packages-\<installed-packages\>). User home directory and environment variables will be expanded. Defaults to the executable used to run mypy.

This option may only be set in the global section (`[mypy]`).

</div>

<div class="confval">

no\_site\_packages

  - type  
    boolean

  - default  
    False

Disables using type information in installed packages (see `561`). This will also disable searching for a usable Python executable. This acts the same as `--no-site-packages <mypy --no-site-packages>` command line flag.

</div>

<div class="confval">

no\_silence\_site\_packages

  - type  
    boolean

  - default  
    False

Enables reporting error messages generated within installed packages (see `561` for more details on distributing type information). Those error messages are suppressed by default, since you are usually not able to control errors in 3rd party code.

This option may only be set in the global section (`[mypy]`).

</div>

Platform configuration `` ` **********************  .. confval:: python_version      :type: string      Specifies the Python version used to parse and check the target     program.  The string should be in the format ``MAJOR.MINOR`--     for example`2.7`.  The default is the version of the Python     interpreter used to run mypy.      This option may only be set in the global section (`\[mypy\]`).  .. confval:: platform      :type: string      Specifies the OS platform for the target program, for example`darwin`or`win32``(meaning OS X or Windows, respectively).     The default is the current platform as revealed by Python's     :py`sys.platform` variable.      This option may only be set in the global section (``\[mypy\]`).  .. confval:: always_true      :type: comma-separated list of strings      Specifies a list of variables that mypy will treat as     compile-time constants that are always true.  .. confval:: always_false      :type: comma-separated list of strings      Specifies a list of variables that mypy will treat as     compile-time constants that are always false.   Disallow dynamic typing ***********************  For more information, see the [Disallow dynamic typing <disallow-dynamic-typing>](#disallow-dynamic-typing-<disallow-dynamic-typing>) section of the command line docs.  .. confval:: disallow_any_unimported      :type: boolean     :default: False      Disallows usage of types that come from unfollowed imports (anything imported from     an unfollowed import is automatically given a type of`Any`).  .. confval:: disallow_any_expr      :type: boolean     :default: False      Disallows all expressions in the module that have type`Any`.  .. confval:: disallow_any_decorated      :type: boolean     :default: False      Disallows functions that have`Any`in their signature after decorator transformation.  .. confval:: disallow_any_explicit      :type: boolean     :default: False      Disallows explicit`Any`in type positions such as type annotations and generic     type parameters.  .. confval:: disallow_any_generics      :type: boolean     :default: False      Disallows usage of generic types that do not specify explicit type parameters.  .. confval:: disallow_subclassing_any      :type: boolean     :default: False      Disallows subclassing a value of type`Any`.   Untyped definitions and calls *****************************  For more information, see the [Untyped definitions and calls <untyped-definitions-and-calls>](#untyped-definitions-and-calls-<untyped-definitions-and-calls>) section of the command line docs.  .. confval:: disallow_untyped_calls      :type: boolean     :default: False      Disallows calling functions without type annotations from functions with type     annotations. Note that when used in per-module options, it enables/disables     this check **inside** the module(s) specified, not for functions that come     from that module(s), for example config like this:`\`ini \[mypy\] disallow\_untyped\_calls = True

> \[mypy-some.library.\*\] disallow\_untyped\_calls = False
> 
> will disable this check inside `some.library`, not for your code that imports `some.library`. If you want to selectively disable this check for all your code that imports `some.library` you should instead use `untyped_calls_exclude`, for example:
> 
> ``` ini
> ```
> 
> \[mypy\] disallow\_untyped\_calls = True untyped\_calls\_exclude = some.library

<div class="confval">

untyped\_calls\_exclude

  - type  
    comma-separated list of strings

Selectively excludes functions and methods defined in specific packages, modules, and classes from action of `disallow_untyped_calls`. This also applies to all submodules of packages (i.e. everything inside a given prefix). Note, this option does not support per-file configuration, the exclusions list is defined globally for all your code.

</div>

<div class="confval">

disallow\_untyped\_defs

  - type  
    boolean

  - default  
    False

Disallows defining functions without type annotations or with incomplete type annotations (a superset of `disallow_incomplete_defs`).

For example, it would report an error for `def f(a, b)` and `def f(a: int, b)`.

</div>

<div class="confval">

disallow\_incomplete\_defs

  - type  
    boolean

  - default  
    False

Disallows defining functions with incomplete type annotations, while still allowing entirely unannotated definitions.

For example, it would report an error for `def f(a: int, b)` but not `def f(a, b)`.

</div>

<div class="confval">

check\_untyped\_defs

  - type  
    boolean

  - default  
    False

Type-checks the interior of functions without type annotations.

</div>

<div class="confval">

disallow\_untyped\_decorators

  - type  
    boolean

  - default  
    False

Reports an error whenever a function with type annotations is decorated with a decorator without annotations.

</div>

<div id="config-file-none-and-optional-handling">

None and Optional handling `` ` **************************  For more information, see the [None and Optional handling <none-and-optional-handling>](#none-and-optional-handling-<none-and-optional-handling>) section of the command line docs.  .. confval:: implicit_optional      :type: boolean     :default: False      Causes mypy to treat parameters with a ``None`default value as having an implicit optional type (`T | None`).      **Note:** This was True by default in mypy versions 0.980 and earlier.  .. confval:: strict_optional      :type: boolean     :default: True      Effectively disables checking of optional     types and`None`values. With this option, mypy doesn't     generally check the use of`None`values -- it is treated     as compatible with every type.      > **Warning** >`strict\_optional = false`is evil. Avoid using it and definitely do         not use it without understanding what it does.   Configuring warnings ********************  For more information, see the [Configuring warnings <configuring-warnings>](#configuring-warnings-<configuring-warnings>) section of the command line docs.  .. confval:: warn_redundant_casts      :type: boolean     :default: False      Warns about casting an expression to its inferred type.      This option may only be set in the global section (`\[mypy\]`).  .. confval:: warn_unused_ignores      :type: boolean     :default: False      Warns about unneeded`\# type: ignore`comments.  .. confval:: warn_no_return      :type: boolean     :default: True      Shows errors for missing return statements on some execution paths.  .. confval:: warn_return_any      :type: boolean     :default: False      Shows a warning when returning a value with type`Any`from a function     declared with a non-`Any`return type.  .. confval:: warn_unreachable      :type: boolean     :default: False      Shows a warning when encountering any code inferred to be unreachable or     redundant after performing type analysis.   Suppressing errors ******************  Note: these configuration options are available in the config file only. There is no analog available via the command line options.  .. confval:: ignore_errors      :type: boolean     :default: False      Ignores all non-fatal errors.   Miscellaneous strictness flags ******************************  For more information, see the [Miscellaneous strictness flags <miscellaneous-strictness-flags>](#miscellaneous-strictness-flags-<miscellaneous-strictness-flags>) section of the command line docs.  .. confval:: allow_untyped_globals      :type: boolean     :default: False      Causes mypy to suppress errors caused by not being able to fully     infer the types of global and class variables.  .. confval:: allow_redefinition      :type: boolean     :default: False      Allows variables to be redefined with an arbitrary type, as long as the redefinition     is in the same block and nesting level as the original definition.     Example where this can be useful:`\`python def process(items: list\[str\]) -\> None: \# 'items' has type list\[str\] items = \[item.split() for item in items\] \# 'items' now has type list\[list\[str\]\]

</div>

> The variable must be used before it can be redefined:
> 
> ``` python
> def process(items: list[str]) -> None:
>    items = "mypy"  # invalid redefinition to str because the variable hasn't been used yet
>    print(items)
>    items = "100"  # valid, items now has type str
>    items = int(items)  # valid, items now has type int
> ```

<div class="confval">

local\_partial\_types

  - type  
    boolean

  - default  
    False

Disallows inferring variable type for `None` from two assignments in different scopes. This is always implicitly enabled when using the \[mypy daemon \<mypy\_daemon\>\](\#mypy-daemon-\<mypy\_daemon\>).

</div>

<div class="confval">

disable\_error\_code

  - type  
    comma-separated list of strings

Allows disabling one or multiple error codes globally.

</div>

<div class="confval">

enable\_error\_code

  - type  
    comma-separated list of strings

Allows enabling one or multiple error codes globally.

Note: This option will override disabled error codes from the disable\_error\_code option.

</div>

<div class="confval">

extra\_checks

  - type  
    boolean

  - default  
    False

This flag enables additional checks that are technically correct but may be impractical in real code. See `mypy --extra-checks` for more info.

</div>

<div class="confval">

implicit\_reexport

  - type  
    boolean

  - default  
    True

By default, imported values to a module are treated as exported and mypy allows other modules to import them. When false, mypy will not re-export unless the item is imported using from-as or is included in `__all__`. Note that mypy treats stub files as if this is always disabled. For example:

``` python
# This won't re-export the value
from foo import bar
# This will re-export it as bar and allow other modules to import it
from foo import bar as bar
# This will also re-export bar
from foo import bar
__all__ = ['bar']
```

</div>

<div class="confval">

strict\_concatenate

  - type  
    boolean

  - default  
    False

Make arguments prepended via `Concatenate` be truly positional-only.

</div>

<div class="confval">

strict\_equality

  - type  
    boolean

  - default  
    False

Prohibit equality checks, identity checks, and container checks between non-overlapping types.

</div>

<div class="confval">

strict

  - type  
    boolean

  - default  
    False

Enable all optional error checking flags. You can see the list of flags enabled by strict mode in the full `mypy --help` output.

Note: the exact list of flags enabled by `strict` may change over time.

</div>

Configuring error messages `` ` **************************  For more information, see the [Configuring error messages <configuring-error-messages>](#configuring-error-messages-<configuring-error-messages>) section of the command line docs.  These options may only be set in the global section ( ``\[mypy\]`).  .. confval:: show_error_context      :type: boolean     :default: False      Prefixes each error with the relevant context.  .. confval:: show_column_numbers      :type: boolean     :default: False      Shows column numbers in error messages.  .. confval:: show_error_code_links      :type: boolean     :default: False      Shows documentation link to corresponding error code.  .. confval:: hide_error_codes      :type: boolean     :default: False      Hides error codes in error messages. See [error-codes](#error-codes) for more information.  .. confval:: pretty      :type: boolean     :default: False      Use visually nicer output in error messages: use soft word wrap,     show source code snippets, and show error location markers.  .. confval:: color_output      :type: boolean     :default: True      Shows error messages with color enabled.  .. confval:: error_summary      :type: boolean     :default: True      Shows a short summary line after error messages.  .. confval:: show_absolute_path      :type: boolean     :default: False      Show absolute paths to files.  .. confval:: force_uppercase_builtins      :type: boolean     :default: False      Always use`List`instead of`list`in error messages,     even on Python 3.9+.  .. confval:: force_union_syntax      :type: boolean     :default: False      Always use`Union\[\]`and`Optional\[\]`for union types     in error messages (instead of the`|`operator),     even on Python 3.10+.  Incremental mode ****************  These options may only be set in the global section (`\[mypy\]`).  .. confval:: incremental      :type: boolean     :default: True      Enables [incremental mode <incremental>](#incremental-mode-<incremental>).  .. confval:: cache_dir      :type: string     :default:`.mypy\_cache`Specifies the location where mypy stores incremental cache info.     User home directory and environment variables will be expanded.     This setting will be overridden by the`MYPY\_CACHE\_DIR`environment     variable.      Note that the cache is only read when incremental mode is enabled     but is always written to, unless the value is set to`/dev/null`(UNIX) or`nul``(Windows).  .. confval:: sqlite_cache      :type: boolean     :default: False      Use an `SQLite`_ database to store the cache.  .. confval:: cache_fine_grained      :type: boolean     :default: False      Include fine-grained dependency information in the cache for the mypy daemon.  .. confval:: skip_version_check      :type: boolean     :default: False      Makes mypy use incremental cache data even if it was generated by a     different version of mypy. (By default, mypy will perform a version     check and regenerate the cache if it was written by older versions of mypy.)  .. confval:: skip_cache_mtime_checks      :type: boolean     :default: False      Skip cache internal consistency checks based on mtime.   Advanced options ****************  These options may only be set in the global section (``\[mypy\]``).  .. confval:: plugins      :type: comma-separated list of strings      A comma-separated list of mypy plugins. See [extending-mypy-using-plugins](#extending-mypy-using-plugins).  .. confval:: pdb      :type: boolean     :default: False      Invokes :mod:`pdb` on fatal error.  .. confval:: show_traceback      :type: boolean     :default: False      Shows traceback on fatal error.  .. confval:: raise_exceptions      :type: boolean     :default: False      Raise exception on fatal error.  .. confval:: custom_typing_module      :type: string      Specifies a custom module to use as a substitute for the :py:mod:`typing` module.  .. confval:: custom_typeshed_dir      :type: string      This specifies the directory where mypy looks for standard library typeshed     stubs, instead of the typeshed that ships with mypy.  This is     primarily intended to make it easier to test typeshed changes before     submitting them upstream, but also allows you to use a forked version of     typeshed.      User home directory and environment variables will be expanded.      Note that this doesn't affect third-party library stubs. To test third-party stubs,     for example try``MYPYPATH=stubs/six mypy ...``.  .. confval:: warn_incomplete_stub      :type: boolean     :default: False      Warns about missing type annotations in typeshed.  This is only relevant     in combination with :confval:`disallow_untyped_defs` or :confval:`disallow_incomplete_defs`.   Report generation *****************  If these options are set, mypy will generate a report in the specified format into the specified directory.  > **Warning** >    Generating reports disables incremental mode and can significantly slow down   your workflow. It is recommended to enable reporting only for specific runs   (e.g. in CI).  .. confval:: any_exprs_report      :type: string      Causes mypy to generate a text file report documenting how many     expressions of type``Any``are present within your codebase.  .. confval:: cobertura_xml_report      :type: string      Causes mypy to generate a Cobertura XML type checking coverage report.      To generate this report, you must either manually install the `lxml`_     library or specify mypy installation with the setuptools extra``mypy\[reports\]``.  .. confval:: html_report / xslt_html_report      :type: string      Causes mypy to generate an HTML type checking coverage report.      To generate this report, you must either manually install the `lxml`_     library or specify mypy installation with the setuptools extra``mypy\[reports\]``.  .. confval:: linecount_report      :type: string      Causes mypy to generate a text file report documenting the functions     and lines that are typed and untyped within your codebase.  .. confval:: linecoverage_report      :type: string      Causes mypy to generate a JSON file that maps each source file's     absolute filename to a list of line numbers that belong to typed     functions in that file.  .. confval:: lineprecision_report      :type: string      Causes mypy to generate a flat text file report with per-module     statistics of how many lines are typechecked etc.  .. confval:: txt_report / xslt_txt_report      :type: string      Causes mypy to generate a text file type checking coverage report.      To generate this report, you must either manually install the `lxml`_     library or specify mypy installation with the setuptools extra``mypy\[reports\]``.  .. confval:: xml_report      :type: string      Causes mypy to generate an XML type checking coverage report.      To generate this report, you must either manually install the `lxml`_     library or specify mypy installation with the setuptools extra``mypy\[reports\]`.   Miscellaneous *************  These options may only be set in the global section (`\[mypy\]`).  .. confval:: junit_xml      :type: string      Causes mypy to generate a JUnit XML test result document with     type checking results. This can make it easier to integrate mypy     with continuous integration (CI) tools.  .. confval:: scripts_are_modules      :type: boolean     :default: False      Makes script`x`become module`x`instead of`\_\_main\_\_``.  This is     useful when checking multiple scripts in a single run.  .. confval:: warn_unused_configs      :type: boolean     :default: False      Warns about per-module sections in the config file that do not     match any files processed when invoking mypy.     (This requires turning off incremental mode using :confval:`incremental = False <incremental>`.)  .. confval:: verbosity      :type: integer     :default: 0      Controls how much debug output will be generated.  Higher numbers are more verbose.   .. _using-a-pyproject-toml:  Using a pyproject.toml file ***************************  Instead of using a``mypy.ini`file, a`pyproject.toml``file (as specified by `PEP 518`_) may be used instead. A few notes on doing so:  * The``\[mypy\]`section should have`tool.`prepended to its name:    * I.e.,`\[mypy\]`would become`\[tool.mypy\]`* The module specific sections should be moved into`\[\[tool.mypy.overrides\]\]`sections:    * For example,`\[mypy-packagename\]`would become:`\`toml \[\[tool.mypy.overrides\]\] module = 'packagename' ...

  - Multi-module specific sections can be moved into a single `[[tool.mypy.overrides]]` section with a module property set to an array of modules:
      - For example, `[mypy-packagename,packagename2]` would become:

<!-- end list -->

``` toml
[[tool.mypy.overrides]]
module = [
    'packagename',
    'packagename2'
]
...
```

  - The following care should be given to values in the `pyproject.toml` files as compared to `ini` files:
      - Strings must be wrapped in double quotes, or single quotes if the string contains special characters
      - Boolean values should be all lower case

Please see the [TOML Documentation]() for more details and information on `` ` what is allowed in a ``toml``file. See `PEP 518`_ for more information on the layout and structure of the``pyproject.toml`file.  Example`pyproject.toml`**************************  Here is an example of a`pyproject.toml`file. To use this config file, place it at the root of your repo (or append it to the end of an existing`pyproject.toml`file) and run mypy.`\`toml \# mypy global options:

> \[tool.mypy\] python\_version = "2.7" warn\_return\_any = true warn\_unused\_configs = true exclude = \[ '^file1.py$', \# TOML literal string (single-quotes, no escaping necessary) "^file2\\.py$", \# TOML basic string (double-quotes, backslash and other characters need escaping) \]
> 
> \# mypy per-module options:
> 
> \[\[tool.mypy.overrides\]\] module = "mycode.foo.\*" disallow\_untyped\_defs = true
> 
> \[\[tool.mypy.overrides\]\] module = "mycode.bar" warn\_return\_any = false
> 
> \[\[tool.mypy.overrides\]\] module = \[ "somelibrary", "some\_other\_library" \] ignore\_missing\_imports = true

\`\`\` .. \_SQLite: <https://www.sqlite.org/> .. \_PEP 518: <https://www.python.org/dev/peps/pep-0518/> .. \_TOML Documentation: <https://toml.io/>

---

duck_type_compatibility.md

---

# Duck type compatibility

In Python, certain types are compatible even though they aren't subclasses of each other. For example, `int` objects are valid whenever `float` objects are expected. Mypy supports this idiom via *duck type compatibility*. This is supported for a small set of built-in types:

  - `int` is duck type compatible with `float` and `complex`.
  - `float` is duck type compatible with `complex`.
  - `bytearray` and `memoryview` are duck type compatible with `bytes`.

For example, mypy considers an `int` object to be valid whenever a `float` object is expected. Thus code like this is nice and clean and also behaves as expected:

`` `python    import math     def degrees_to_radians(degrees: float) -> float:        return math.pi * degrees / 180     n = 90  # Inferred type 'int'    print(degrees_to_radians(n))  # Okay!  You can also often use [protocol-types](#protocol-types) to achieve a similar effect in ``<span class="title-ref"> a more principled and extensible fashion. Protocols don't apply to cases like </span><span class="title-ref">int</span><span class="title-ref"> being compatible with </span><span class="title-ref">float</span><span class="title-ref">, since </span><span class="title-ref">float</span><span class="title-ref"> is not a protocol class but a regular, concrete class, and many standard library functions expect concrete instances of </span><span class="title-ref">float</span><span class="title-ref"> (or </span><span class="title-ref">int</span>\`).

---

dynamic_typing.md

---

# Dynamically typed code

In \[getting-started-dynamic-vs-static\](\#getting-started-dynamic-vs-static), we discussed how bodies of functions that don't have any explicit type annotations in their function are "dynamically typed" and that mypy will not check them. In this section, we'll talk a little bit more about what that means and how you can enable dynamic typing on a more fine grained basis.

In cases where your code is too magical for mypy to understand, you can make a variable or parameter dynamically typed by explicitly giving it the type `Any`. Mypy will let you do basically anything with a value of type `Any`, including assigning a value of type `Any` to a variable of any type (or vice versa).

`` `python    from typing import Any     num = 1         # Statically typed (inferred to be int)    num = 'x'       # error: Incompatible types in assignment (expression has type "str", variable has type "int")     dyn: Any = 1    # Dynamically typed (type Any)    dyn = 'x'       # OK     num = dyn       # No error, mypy will let you assign a value of type Any to any variable    num += 1        # Oops, mypy still thinks num is an int  You can think of ``Any`as a way to locally disable type checking.`\` See \[silencing-type-errors\](\#silencing-type-errors) for other ways you can shut up the type checker.

## Operations on Any values

You can do anything using a value with type `Any`, and the type checker will not complain:

`` `python     def f(x: Any) -> int:         # All of these are valid!         x.foobar(1, y=2)         print(x[3] + 'f')         if x:             x.z = x(2)         open(x).read()         return x  Values derived from an ``Any`value also usually have the type`Any`  `<span class="title-ref"> implicitly, as mypy can't infer a more precise result type. For example, if you get the attribute of an </span><span class="title-ref">Any</span><span class="title-ref"> value or call a </span><span class="title-ref">Any</span><span class="title-ref"> value the result is </span><span class="title-ref">Any</span>\`:

`` `python     def f(x: Any) -> None:         y = x.foo()         reveal_type(y)  # Revealed type is "Any"         z = y.bar("mypy will let you do anything to y")         reveal_type(z)  # Revealed type is "Any" ``Any`types may propagate through your program, making type checking`\` less effective, unless you are careful.

Function parameters without annotations are also implicitly `Any`:

`` `python     def f(x) -> None:         reveal_type(x)  # Revealed type is "Any"         x.can.do["anything", x]("wants", 2)  You can make mypy warn you about untyped function parameters using the ``<span class="title-ref"> :option:</span>--disallow-untyped-defs \<mypy --disallow-untyped-defs\>\` flag.

Generic types missing type parameters will have those parameters implicitly treated as `Any`:

`` `python     def f(x: list) -> None:         reveal_type(x)        # Revealed type is "builtins.list[Any]"         reveal_type(x[0])     # Revealed type is "Any"         x[0].anything_goes()  # OK  You can make mypy warn you about missing generic parameters using the ``<span class="title-ref"> :option:</span>--disallow-any-generics \<mypy --disallow-any-generics\>\` flag.

Finally, another major source of `Any` types leaking into your program is from third party libraries that mypy does not know about. This is particularly the case when using the `--ignore-missing-imports <mypy --ignore-missing-imports>` flag. See \[fix-missing-imports\](\#fix-missing-imports) for more information about this.

## Any vs. object

The type :py\`object\` is another type that can have an instance of arbitrary type as a value. Unlike `Any`, :py\`object\` is an ordinary static type (it is similar to `Object` in Java), and only operations valid for *all* types are accepted for :py\`object\` values. These are all valid:

`` `python     def f(o: object) -> None:         if o:             print(o)         print(isinstance(o, int))         o = 2         o = 'foo'  These are, however, flagged as errors, since not all objects support these ``\` operations:

`` `python     def f(o: object) -> None:         o.foo()       # Error!         o + 2         # Error!         open(o)       # Error!         n: int = 1         n = o         # Error!   If you're not sure whether you need to use :py`object` or ``Any`, use`<span class="title-ref"> :py\`object</span> -- only switch to using `Any` if you get a type checker complaint.

You can use different \[type narrowing \<type-narrowing\>\](\#type-narrowing-\<type-narrowing\>) techniques to narrow :py\`object\` to a more specific type (subtype) such as `int`. Type narrowing is not needed with dynamically typed values (values with type `Any`).

---

error_code_list.md

---

# Error codes enabled by default

This section documents various errors codes that mypy can generate with default options. See \[error-codes\](\#error-codes) for general documentation about error codes. \[error-codes-optional\](\#error-codes-optional) documents additional error codes that you can enable.

## Check that attribute exists \[attr-defined\]

Mypy checks that an attribute is defined in the target class or module when using the dot operator. This applies to both getting and setting an attribute. New attributes are defined by assignments in the class body, or assignments to `self.x` in methods. These assignments don't generate `attr-defined` errors.

Example:

`` `python    class Resource:        def __init__(self, name: str) -> None:            self.name = name     r = Resource('x')    print(r.name)  # OK    print(r.id)  # Error: "Resource" has no attribute "id"  [attr-defined]    r.id = 5  # Error: "Resource" has no attribute "id"  [attr-defined]  This error code is also generated if an imported name is not defined ``<span class="title-ref"> in the module in a </span><span class="title-ref">from ... import</span>\` statement (as long as the target module can be found):

`` `python     # Error: Module "os" has no attribute "non_existent"  [attr-defined]     from os import non_existent  A reference to a missing attribute is given the ``Any`type. In the`<span class="title-ref"> above example, the type of </span><span class="title-ref">non\_existent</span><span class="title-ref"> will be </span><span class="title-ref">Any</span>\`, which can be important if you silence the error.

## Check that attribute exists in each union item \[union-attr\]

If you access the attribute of a value with a union type, mypy checks that the attribute is defined for *every* type in that union. Otherwise the operation can fail at runtime. This also applies to optional types.

Example:

`` `python    class Cat:        def sleep(self) -> None: ...        def miaow(self) -> None: ...     class Dog:        def sleep(self) -> None: ...        def follow_me(self) -> None: ...     def func(animal: Cat | Dog) -> None:        # OK: 'sleep' is defined for both Cat and Dog        animal.sleep()        # Error: Item "Cat" of "Cat | Dog" has no attribute "follow_me"  [union-attr]        animal.follow_me()  You can often work around these errors by using ``assert isinstance(obj, ClassName)`  `<span class="title-ref"> or </span><span class="title-ref">assert obj is not None</span>\` to tell mypy that you know that the type is more specific than what mypy thinks.

## Check that name is defined \[name-defined\]

Mypy expects that all references to names have a corresponding definition in an active scope, such as an assignment, function definition or an import. This can catch missing definitions, missing imports, and typos.

This example accidentally calls `sort()` instead of :py\`sorted\`:

`` `python     x = sort([3, 2, 4])  # Error: Name "sort" is not defined  [name-defined]  .. _code-used-before-def:  Check that a variable is not used before it's defined [used-before-def] ``\` -----------------------------------------------------------------------

Mypy will generate an error if a name is used before it's defined. While the name-defined check will catch issues with names that are undefined, it will not flag if a variable is used and then defined later in the scope. used-before-def check will catch such cases.

Example:

`` `python     print(x)  # Error: Name "x" is used before definition [used-before-def]     x = 123  .. _code-call-arg:  Check arguments in calls [call-arg] ``\` -----------------------------------

Mypy expects that the number and names of arguments match the called function. Note that argument type checks have a separate error code `arg-type`.

Example:

`` `python     def greet(name: str) -> None:          print('hello', name)      greet('jack')  # OK     greet('jill', 'jack')  # Error: Too many arguments for "greet"  [call-arg]  .. _code-arg-type:  Check argument types [arg-type] ``\` -------------------------------

Mypy checks that argument types in a call match the declared argument types in the signature of the called function (if one exists).

Example:

`` `python     def first(x: list[int]) -> int:         return x[0] if x else 0      t = (5, 4)     # Error: Argument 1 to "first" has incompatible type "tuple[int, int]";     #        expected "list[int]"  [arg-type]     print(first(t))  .. _code-call-overload:  Check calls to overloaded functions [call-overload] ``\` ---------------------------------------------------

When you call an overloaded function, mypy checks that at least one of the signatures of the overload items match the argument types in the call.

Example:

`` `python    from typing import overload     @overload    def inc_maybe(x: None) -> None: ...     @overload    def inc_maybe(x: int) -> int: ...     def inc_maybe(x: int | None) -> int | None:         if x is None:             return None         else:             return x + 1     inc_maybe(None)  # OK    inc_maybe(5)  # OK     # Error: No overload variant of "inc_maybe" matches argument type "float"  [call-overload]    inc_maybe(1.2)  .. _code-valid-type:  Check validity of types [valid-type] ``\` ------------------------------------

Mypy checks that each type annotation and any expression that represents a type is a valid type. Examples of valid types include classes, union types, callable types, type aliases, and literal types. Examples of invalid types include bare integer literals, functions, variables, and modules.

This example incorrectly uses the function `log` as a type:

`` `python     def log(x: object) -> None:         print('log:', repr(x))      # Error: Function "t.log" is not valid as a type  [valid-type]     def log_all(objs: list[object], f: log) -> None:         for x in objs:             f(x)  You can use :py`~collections.abc.Callable` as the type for callable objects:  .. code-block:: python      from collections.abc import Callable      # OK     def log_all(objs: list[object], f: Callable[[object], None]) -> None:         for x in objs:             f(x)  .. _code-var-annotated:  Require annotation if variable type is unclear [var-annotated] ``\` --------------------------------------------------------------

In some cases mypy can't infer the type of a variable without an explicit annotation. Mypy treats this as an error. This typically happens when you initialize a variable with an empty collection or `None`. If mypy can't infer the collection item type, mypy replaces any parts of the type it couldn't infer with `Any` and generates an error.

Example with an error:

`` `python     class Bundle:         def __init__(self) -> None:             # Error: Need type annotation for "items"             #        (hint: "items: list[<type>] = ...")  [var-annotated]             self.items = []      reveal_type(Bundle().items)  # list[Any]  To address this, we add an explicit annotation:  .. code-block:: python      class Bundle:         def __init__(self) -> None:             self.items: list[str] = []  # OK     reveal_type(Bundle().items)  # list[str]  .. _code-override:  Check validity of overrides [override] ``\` --------------------------------------

Mypy checks that an overridden method or attribute is compatible with the base class. A method in a subclass must accept all arguments that the base class method accepts, and the return type must conform to the return type in the base class (Liskov substitution principle).

Argument types can be more general is a subclass (i.e., they can vary contravariantly). The return type can be narrowed in a subclass (i.e., it can vary covariantly). It's okay to define additional arguments in a subclass method, as long all extra arguments have default values or can be left out (`*args`, for example).

Example:

`` `python    class Base:        def method(self,                   arg: int) -> int | None:            ...     class Derived(Base):        def method(self,                   arg: int | str) -> int:  # OK            ...     class DerivedBad(Base):        # Error: Argument 1 of "method" is incompatible with "Base"  [override]        def method(self,                   arg: bool) -> int:            ...  .. _code-return:  Check that function returns a value [return] ``\` --------------------------------------------

If a function has a non-`None` return type, mypy expects that the function always explicitly returns a value (or raises an exception). The function should not fall off the end of the function, since this is often a bug.

Example:

`` `python     # Error: Missing return statement  [return]     def show(x: int) -> int:         print(x)      # Error: Missing return statement  [return]     def pred1(x: int) -> int:         if x > 0:             return x - 1      # OK     def pred2(x: int) -> int:         if x > 0:             return x - 1         else:             raise ValueError('not defined for zero')  .. _code-empty-body:  Check that functions don't have empty bodies outside stubs [empty-body] ``\` -----------------------------------------------------------------------

This error code is similar to the `[return]` code but is emitted specifically for functions and methods with empty bodies (if they are annotated with non-trivial return type). Such a distinction exists because in some contexts an empty body can be valid, for example for an abstract method or in a stub file. Also old versions of mypy used to unconditionally allow functions with empty bodies, so having a dedicated error code simplifies cross-version compatibility.

Note that empty bodies are allowed for methods in *protocols*, and such methods are considered implicitly abstract:

`` `python    from abc import abstractmethod    from typing import Protocol     class RegularABC:        @abstractmethod        def foo(self) -> int:            pass  # OK        def bar(self) -> int:            pass  # Error: Missing return statement  [empty-body]     class Proto(Protocol):        def bar(self) -> int:            pass  # OK  .. _code-return-value:  Check that return value is compatible [return-value] ``\` ----------------------------------------------------

Mypy checks that the returned value is compatible with the type signature of the function.

Example:

`` `python    def func(x: int) -> str:        # Error: Incompatible return value type (got "int", expected "str")  [return-value]        return x + 1  .. _code-assignment:  Check types in assignment statement [assignment] ``\` ------------------------------------------------

Mypy checks that the assigned expression is compatible with the assignment target (or targets).

Example:

`` `python     class Resource:         def __init__(self, name: str) -> None:             self.name = name      r = Resource('A')      r.name = 'B'  # OK      # Error: Incompatible types in assignment (expression has type "int",     #        variable has type "str")  [assignment]     r.name = 5  .. _code-method-assign:  Check that assignment target is not a method [method-assign] ``\` ------------------------------------------------------------

In general, assigning to a method on class object or instance (a.k.a. monkey-patching) is ambiguous in terms of types, since Python's static type system cannot express the difference between bound and unbound callable types. Consider this example:

`` `python    class A:        def f(self) -> None: pass        def g(self) -> None: pass     def h(self: A) -> None: pass     A.f = h  # Type of h is Callable[[A], None]    A().f()  # This works    A.f = A().g  # Type of A().g is Callable[[], None]    A().f()  # ...but this also works at runtime  To prevent the ambiguity, mypy will flag both assignments by default. If this ``\` error code is disabled, mypy will treat the assigned value in all method assignments as unbound, so only the second assignment will still generate an error.

\> **Note** \> This error code is a subcode of the more general `[assignment]` code.

## Check type variable values \[type-var\]

Mypy checks that value of a type variable is compatible with a value restriction or the upper bound type.

Example (Python 3.12 syntax):

`` `python     def add[T1: (int, float)](x: T1, y: T1) -> T1:         return x + y      add(4, 5.5)  # OK      # Error: Value of type variable "T1" of "add" cannot be "str"  [type-var]     add('x', 'y')  .. _code-operator:  Check uses of various operators [operator] ``\` ------------------------------------------

Mypy checks that operands support a binary or unary operation, such as `+` or `~`. Indexing operations are so common that they have their own error code `index` (see below).

Example:

`` `python    # Error: Unsupported operand types for + ("int" and "str")  [operator]    1 + 'x'  .. _code-index:  Check indexing operations [index] ``\` ---------------------------------

Mypy checks that the indexed value in indexing operation such as `x[y]` supports indexing, and that the index expression has a valid type.

Example:

`` `python    a = {'x': 1, 'y': 2}     a['x']  # OK     # Error: Invalid index type "int" for "dict[str, int]"; expected type "str"  [index]    print(a[1])     # Error: Invalid index type "bytes" for "dict[str, int]"; expected type "str"  [index]    a[b'x'] = 4  .. _code-list-item:  Check list items [list-item] ``\` ----------------------------

When constructing a list using `[item, ...]`, mypy checks that each item is compatible with the list type that is inferred from the surrounding context.

Example:

`` `python     # Error: List item 0 has incompatible type "int"; expected "str"  [list-item]     a: list[str] = [0]  .. _code-dict-item:  Check dict items [dict-item] ``\` ----------------------------

When constructing a dictionary using `{key: value, ...}` or `dict(key=value, ...)`, mypy checks that each key and value is compatible with the dictionary type that is inferred from the surrounding context.

Example:

`` `python     # Error: Dict entry 0 has incompatible type "str": "str"; expected "str": "int"  [dict-item]     d: dict[str, int] = {'key': 'value'}  .. _code-typeddict-item:  Check TypedDict items [typeddict-item] ``\` --------------------------------------

When constructing a TypedDict object, mypy checks that each key and value is compatible with the TypedDict type that is inferred from the surrounding context.

When getting a TypedDict item, mypy checks that the key exists. When assigning to a TypedDict, mypy checks that both the key and the value are valid.

Example:

`` `python     from typing import TypedDict      class Point(TypedDict):         x: int         y: int      # Error: Incompatible types (expression has type "float",     #        TypedDict item "x" has type "int")  [typeddict-item]     p: Point = {'x': 1.2, 'y': 4}  .. _code-typeddict-unknown-key:  Check TypedDict Keys [typeddict-unknown-key] ``\` --------------------------------------------

When constructing a TypedDict object, mypy checks whether the definition contains unknown keys, to catch invalid keys and misspellings. On the other hand, mypy will not generate an error when a previously constructed TypedDict value with extra keys is passed to a function as an argument, since TypedDict values support structural subtyping ("static duck typing") and the keys are assumed to have been validated at the point of construction. Example:

`` `python     from typing import TypedDict      class Point(TypedDict):         x: int         y: int      class Point3D(Point):         z: int      def add_x_coordinates(a: Point, b: Point) -> int:         return a["x"] + b["x"]      a: Point = {"x": 1, "y": 4}     b: Point3D = {"x": 2, "y": 5, "z": 6}      add_x_coordinates(a, b)  # OK      # Error: Extra key "z" for TypedDict "Point"  [typeddict-unknown-key]     add_x_coordinates(a, {"x": 1, "y": 4, "z": 5})  Setting a TypedDict item using an unknown key will also generate this ``\` error, since it could be a misspelling:

`` `python     a: Point = {"x": 1, "y": 2}     # Error: Extra key "z" for TypedDict "Point"  [typeddict-unknown-key]     a["z"] = 3  Reading an unknown key will generate the more general (and serious) ``<span class="title-ref"> </span><span class="title-ref">typeddict-item</span>\` error, which is likely to result in an exception at runtime:

`` `python     a: Point = {"x": 1, "y": 2}     # Error: TypedDict "Point" has no key "z"  [typeddict-item]     _ = a["z"]  > **Note** >      This error code is a subcode of the wider ``\[typeddict-item\]`code.  .. _code-has-type:  Check that type of target is known [has-type]`\` ---------------------------------------------

Mypy sometimes generates an error when it hasn't inferred any type for a variable being referenced. This can happen for references to variables that are initialized later in the source file, and for references across modules that form an import cycle. When this happens, the reference gets an implicit `Any` type.

In this example the definitions of `x` and `y` are circular:

`` `python    class Problem:        def set_x(self) -> None:            # Error: Cannot determine type of "y"  [has-type]            self.x = self.y         def set_y(self) -> None:            self.y = self.x  To work around this error, you can add an explicit type annotation to ``\` the target variable or attribute. Sometimes you can also reorganize the code so that the definition of the variable is placed earlier than the reference to the variable in a source file. Untangling cyclic imports may also help.

We add an explicit annotation to the `y` attribute to work around the issue:

`` `python    class Problem:        def set_x(self) -> None:            self.x = self.y  # OK         def set_y(self) -> None:            self.y: int = self.x  # Added annotation here  .. _code-import:  Check for an issue with imports [import] ``\` ----------------------------------------

Mypy generates an error if it can't resolve an <span class="title-ref">import</span> statement. This is a parent error code of <span class="title-ref">import-not-found</span> and <span class="title-ref">import-untyped</span>

See \[ignore-missing-imports\](\#ignore-missing-imports) for how to work around these errors.

## Check that import target can be found \[import-not-found\]

Mypy generates an error if it can't find the source code or a stub file for an imported module.

Example:

`` `python     # Error: Cannot find implementation or library stub for module named "m0dule_with_typo"  [import-not-found]     import m0dule_with_typo  See [ignore-missing-imports](#ignore-missing-imports) for how to work around these errors.  .. _code-import-untyped:  Check that import target can be found [import-untyped] ``\` --------------------------------------------------------

Mypy generates an error if it can find the source code for an imported module, but that module does not provide type annotations (via \[PEP 561 \<installed-packages\>\](\#pep-561-\<installed-packages\>)).

Example:

`` `python     # Error: Library stubs not installed for "bs4"  [import-untyped]     import bs4     # Error: Skipping analyzing "no_py_typed": module is installed, but missing library stubs or py.typed marker  [import-untyped]     import no_py_typed  In some cases, these errors can be fixed by installing an appropriate ``\` stub package. See \[ignore-missing-imports\](\#ignore-missing-imports) for more details.

## Check that each name is defined once \[no-redef\]

Mypy may generate an error if you have multiple definitions for a name in the same namespace. The reason is that this is often an error, as the second definition may overwrite the first one. Also, mypy often can't be able to determine whether references point to the first or the second definition, which would compromise type checking.

If you silence this error, all references to the defined name refer to the *first* definition.

Example:

`` `python    class A:        def __init__(self, x: int) -> None: ...     class A:  # Error: Name "A" already defined on line 1  [no-redef]        def __init__(self, x: str) -> None: ...     # Error: Argument 1 to "A" has incompatible type "str"; expected "int"    #        (the first definition wins!)    A('x')  .. _code-func-returns-value:  Check that called function returns a value [func-returns-value] ``\` ---------------------------------------------------------------

Mypy reports an error if you call a function with a `None` return type and don't ignore the return value, as this is usually (but not always) a programming error.

In this example, the `if f()` check is always false since `f` returns `None`:

`` `python    def f() -> None:        ...     # OK: we don't do anything with the return value    f()     # Error: "f" does not return a value (it only ever returns None)  [func-returns-value]    if f():         print("not false")  .. _code-abstract:  Check instantiation of abstract classes [abstract] ``\` --------------------------------------------------

Mypy generates an error if you try to instantiate an abstract base class (ABC). An abstract base class is a class with at least one abstract method or attribute. (See also :py`abc` module documentation)

Sometimes a class is made accidentally abstract, often due to an unimplemented abstract method. In a case like this you need to provide an implementation for the method to make the class concrete (non-abstract).

Example:

`` `python     from abc import ABCMeta, abstractmethod      class Persistent(metaclass=ABCMeta):         @abstractmethod         def save(self) -> None: ...      class Thing(Persistent):         def __init__(self) -> None:             ...          ...  # No "save" method      # Error: Cannot instantiate abstract class "Thing" with abstract attribute "save"  [abstract]     t = Thing()  .. _code-type-abstract:  Safe handling of abstract type object types [type-abstract] ``\` -----------------------------------------------------------

Mypy always allows instantiating (calling) type objects typed as `type[t]`, even if it is not known that `t` is non-abstract, since it is a common pattern to create functions that act as object factories (custom constructors). Therefore, to prevent issues described in the above section, when an abstract type object is passed where `type[t]` is expected, mypy will give an error. Example (Python 3.12 syntax):

`` `python    from abc import ABCMeta, abstractmethod     class Config(metaclass=ABCMeta):        @abstractmethod        def get_value(self, attr: str) -> str: ...     def make_many[T](typ: type[T], n: int) -> list[T]:        return [typ() for _ in range(n)]  # This will raise if typ is abstract     # Error: Only concrete class can be given where "type[Config]" is expected [type-abstract]    make_many(Config, 5)  .. _code-safe-super:  Check that call to an abstract method via super is valid [safe-super] ``\` ---------------------------------------------------------------------

Abstract methods often don't have any default implementation, i.e. their bodies are just empty. Calling such methods in subclasses via `super()` will cause runtime errors, so mypy prevents you from doing so:

`` `python    from abc import abstractmethod    class Base:        @abstractmethod        def foo(self) -> int: ...    class Sub(Base):        def foo(self) -> int:            return super().foo() + 1  # error: Call to abstract method "foo" of "Base" with                                      # trivial body via super() is unsafe  [safe-super]    Sub().foo()  # This will crash at runtime.  Mypy considers the following as trivial bodies: a ``pass`statement, a literal`<span class="title-ref"> ellipsis </span><span class="title-ref">...</span><span class="title-ref">, a docstring, and a </span><span class="title-ref">raise NotImplementedError</span>\` statement.

## Check the target of NewType \[valid-newtype\]

The target of a :py\`\~typing.NewType\` definition must be a class type. It can't be a union type, `Any`, or various other special types.

You can also get this error if the target has been imported from a module whose source mypy cannot find, since any such definitions are treated by mypy as values with `Any` types. Example:

`` `python    from typing import NewType     # The source for "acme" is not available for mypy    from acme import Entity  # type: ignore     # Error: Argument 2 to NewType(...) must be subclassable (got "Any")  [valid-newtype]    UserEntity = NewType('UserEntity', Entity)  To work around the issue, you can either give mypy access to the sources ``<span class="title-ref"> for </span><span class="title-ref">acme</span>\` or create a stub file for the module. See \[ignore-missing-imports\](\#ignore-missing-imports) for more information.

## Check the return type of \_\_exit\_\_ \[exit-return\]

If mypy can determine that :py\`\_\_exit\_\_ \<object.\_\_exit\_\_\><span class="title-ref"> always returns </span><span class="title-ref">False</span><span class="title-ref">, mypy checks that the return type is \*not\* </span><span class="title-ref">bool</span><span class="title-ref">. The boolean value of the return type affects which lines mypy thinks are reachable after a </span><span class="title-ref">with</span><span class="title-ref"> statement, since any :py</span>\_\_exit\_\_ \<object.\_\_exit\_\_\><span class="title-ref"> method that can return </span><span class="title-ref">True</span><span class="title-ref"> may swallow exceptions. An imprecise return type can result in mysterious errors reported near </span><span class="title-ref">with</span>\` statements.

To fix this, use either `typing.Literal[False]` or `None` as the return type. Returning `None` is equivalent to returning `False` in this context, since both are treated as false values.

Example:

`` `python    class MyContext:        ...        def __exit__(self, exc, value, tb) -> bool:  # Error            print('exit')            return False  This produces the following output from mypy:  .. code-block:: text     example.py:3: error: "bool" is invalid as return type for "__exit__" that always returns False    example.py:3: note: Use "typing_extensions.Literal[False]" as the return type or change it to        "None"    example.py:3: note: If return type of "__exit__" implies that it may return True, the context        manager may swallow exceptions  You can use ``Literal\[False\]`to fix the error:  .. code-block:: python     from typing import Literal     class MyContext:        ...        def __exit__(self, exc, value, tb) -> Literal[False]:  # OK            print('exit')            return False  You can also use`None`:  .. code-block:: python     class MyContext:        ...        def __exit__(self, exc, value, tb) -> None:  # Also OK            print('exit')  .. _code-name-match:  Check that naming is consistent [name-match]`\` --------------------------------------------

The definition of a named tuple or a TypedDict must be named consistently when using the call-based syntax. Example:

`` `python     from typing import NamedTuple      # Error: First argument to namedtuple() should be "Point2D", not "Point"     Point2D = NamedTuple("Point", [("x", int), ("y", int)])  .. _code-literal-required:  Check that literal is used where expected [literal-required] ``\` ------------------------------------------------------------

There are some places where only a (string) literal value is expected for the purposes of static type checking, for example a `TypedDict` key, or a `__match_args__` item. Providing a `str`-valued variable in such contexts will result in an error. Note that in many cases you can also use `Final` or `Literal` variables. Example:

`` `python    from typing import Final, Literal, TypedDict     class Point(TypedDict):        x: int        y: int     def test(p: Point) -> None:        X: Final = "x"        p[X]  # OK         Y: Literal["y"] = "y"        p[Y]  # OK         key = "x"  # Inferred type of key is `str`        # Error: TypedDict key must be a string literal;        #   expected one of ("x", "y")  [literal-required]        p[key]  .. _code-no-overload-impl:  Check that overloaded functions have an implementation [no-overload-impl] ``\` -------------------------------------------------------------------------

Overloaded functions outside of stub files must be followed by a non overloaded implementation.

`` `python    from typing import overload     @overload    def func(value: int) -> int:        ...     @overload    def func(value: str) -> str:        ...     # presence of required function below is checked    def func(value):        pass  # actual implementation  .. _code-unused-coroutine:  Check that coroutine return value is used [unused-coroutine] ``\` ------------------------------------------------------------

Mypy ensures that return values of async def functions are not ignored, as this is usually a programming error, as the coroutine won't be executed at the call site.

`` `python    async def f() -> None:        ...     async def g() -> None:        f()  # Error: missing await        await f()  # OK  You can work around this error by assigning the result to a temporary, ``\` otherwise unused variable:

`` `python        _ = f()  # No error  .. _code-top-level-await:  Warn about top level await expressions [top-level-await] ``\` --------------------------------------------------------

This error code is separate from the general `[syntax]` errors, because in some environments (e.g. IPython) a top level `await` is allowed. In such environments a user may want to use `--disable-error-code=top-level-await`, that allows to still have errors for other improper uses of `await`, for example:

`` `python    async def f() -> None:        ...     top = await f()  # Error: "await" outside function  [top-level-await]  .. _code-await-not-async:  Warn about await expressions used outside of coroutines [await-not-async] ``\` -------------------------------------------------------------------------

`await` must be used inside a coroutine.

`` `python    async def f() -> None:        ...     def g() -> None:        await f()  # Error: "await" outside coroutine ("async def")  [await-not-async]  .. _code-assert-type:  Check types in assert_type [assert-type] ``\` ----------------------------------------

The inferred type for an expression passed to `assert_type` must match the provided type.

`` `python    from typing_extensions import assert_type     assert_type([1], list[int])  # OK     assert_type([1], list[str])  # Error  .. _code-truthy-function:  Check that function isn't used in boolean context [truthy-function] ``\` -------------------------------------------------------------------

Functions will always evaluate to true in boolean contexts.

`` `python     def f():         ...      if f:  # Error: Function "Callable[[], Any]" could always be true in boolean context  [truthy-function]         pass  .. _code-str-format:  Check that string formatting/interpolation is type-safe [str-format] ``\` --------------------------------------------------------------------

Mypy will check that f-strings, `str.format()` calls, and `%` interpolations are valid (when corresponding template is a literal string). This includes checking number and types of replacements, for example:

`` `python     # Error: Cannot find replacement for positional format specifier 1 [str-format]     "{} and {}".format("spam")     "{} and {}".format("spam", "eggs")  # OK     # Error: Not all arguments converted during string formatting [str-format]     "{} and {}".format("spam", "eggs", "cheese")      # Error: Incompatible types in string interpolation     # (expression has type "float", placeholder has type "int") [str-format]     "{:d}".format(3.14)  .. _code-str-bytes-safe:  Check for implicit bytes coercions [str-bytes-safe] ``\` -------------------------------------------------------------------

Warn about cases where a bytes object may be converted to a string in an unexpected manner.

`` `python     b = b"abc"      # Error: If x = b'abc' then f"{x}" or "{}".format(x) produces "b'abc'", not "abc".     # If this is desired behavior, use f"{x!r}" or "{!r}".format(x).     # Otherwise, decode the bytes [str-bytes-safe]     print(f"The alphabet starts with {b}")      # Okay     print(f"The alphabet starts with {b!r}")  # The alphabet starts with b'abc'     print(f"The alphabet starts with {b.decode('utf-8')}")  # The alphabet starts with abc  .. _code-overload-overlap:  Check that overloaded functions don't overlap [overload-overlap] ``\` ----------------------------------------------------------------

Warn if multiple `@overload` variants overlap in potentially unsafe ways. This guards against the following situation:

`` `python     from typing import overload      class A: ...     class B(A): ...      @overload     def foo(x: B) -> int: ...  # Error: Overloaded function signatures 1 and 2 overlap with incompatible return types  [overload-overlap]     @overload     def foo(x: A) -> str: ...     def foo(x): ...      def takes_a(a: A) -> str:         return foo(a)      a: A = B()     value = takes_a(a)     # mypy will think that value is a str, but it could actually be an int     reveal_type(value) # Revealed type is "builtins.str"   Note that in cases where you ignore this error, mypy will usually still infer the ``\` types you expect.

See \[overloading \<function-overloading\>\](\#overloading-\<function-overloading\>) for more explanation.

## Check for overload signatures that cannot match \[overload-cannot-match\]

Warn if an `@overload` variant can never be matched, because an earlier overload has a wider signature. For example, this can happen if the two overloads accept the same parameters and each parameter on the first overload has the same type or a wider type than the corresponding parameter on the second overload.

Example:

`` `python     from typing import overload, Union      @overload     def process(response1: object, response2: object) -> object:         ...     @overload     def process(response1: int, response2: int) -> int: # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader  [overload-cannot-match]         ...      def process(response1: object, response2: object) -> object:         return response1 + response2  .. _code-annotation-unchecked:  Notify about an annotation in an unchecked function [annotation-unchecked] ``\` --------------------------------------------------------------------------

Sometimes a user may accidentally omit an annotation for a function, and mypy will not check the body of this function (unless one uses `--check-untyped-defs <mypy --check-untyped-defs>` or `--disallow-untyped-defs <mypy --disallow-untyped-defs>`). To avoid such situations go unnoticed, mypy will show a note, if there are any type annotations in an unchecked function:

`` `python     def test_assignment():  # "-> None" return annotation is missing         # Note: By default the bodies of untyped functions are not checked,         # consider using --check-untyped-defs [annotation-unchecked]         x: int = "no way"  Note that mypy will still exit with return code ``0`, since such behaviour is`<span class="title-ref"> specified by :pep:\`484</span>.

## Decorator preceding property not supported \[prop-decorator\]

Mypy does not yet support analysis of decorators that precede the property decorator. If the decorator does not preserve the declared type of the property, mypy will not infer the correct type for the declaration. If the decorator cannot be moved after the `@property` decorator, then you must use a type ignore comment:

`` `python     class MyClass:         @special  # type: ignore[prop-decorator]         @property         def magic(self) -> str:             return "xyzzy"  > **Note** >      For backward compatibility, this error code is a subcode of the generic ``\[misc\]`code.  .. _code-syntax:  Report syntax errors [syntax]`\` -----------------------------

If the code being checked is not syntactically valid, mypy issues a syntax error. Most, but not all, syntax errors are *blocking errors*: they can't be ignored with a `# type: ignore` comment.

## ReadOnly key of a TypedDict is mutated \[typeddict-readonly-mutated\]

Consider this example:

`` `python     from datetime import datetime     from typing import TypedDict     from typing_extensions import ReadOnly      class User(TypedDict):         username: ReadOnly[str]         last_active: datetime      user: User = {'username': 'foobar', 'last_active': datetime.now()}     user['last_active'] = datetime.now()  # ok     user['username'] = 'other'  # error: ReadOnly TypedDict key "key" TypedDict is mutated  [typeddict-readonly-mutated]  `PEP 705 <https://peps.python.org/pep-0705>`_ specifies ``<span class="title-ref"> how </span><span class="title-ref">ReadOnly</span><span class="title-ref"> special form works for </span><span class="title-ref">TypedDict</span>\` objects.

## Miscellaneous checks \[misc\]

Mypy performs numerous other, less commonly failing checks that don't have specific error codes. These use the `misc` error code. Other than being used for multiple unrelated errors, the `misc` error code is not special. For example, you can ignore all errors in this category by using `# type: ignore[misc]` comment. Since these errors are not expected to be common, it's unlikely that you'll see two *different* errors with the `misc` code on a single line -- though this can certainly happen once in a while.

\> **Note** \> Future mypy versions will likely add new error codes for some errors that currently use the `misc` error code.

---

error_code_list2.md

---

# Error codes for optional checks

This section documents various errors codes that mypy generates only if you enable certain options. See \[error-codes\](\#error-codes) for general documentation about error codes and their configuration. \[error-code-list\](\#error-code-list) documents error codes that are enabled by default.

\> **Note** \> The examples in this section use \[inline configuration \<inline-config\>\](\#inline-configuration ---\<inline-config\>) to specify mypy options. You can also set the same options by using a \[configuration file \<config-file\>\](\#configuration-file-\<config-file\>) or \[command-line options \<command-line\>\](\#command-line-options-\<command-line\>).

## Check that type arguments exist \[type-arg\]

If you use `--disallow-any-generics <mypy --disallow-any-generics>`, mypy requires that each generic type has values for each type argument. For example, the types `list` or `dict` would be rejected. You should instead use types like `list[int]` or `dict[str, int]`. Any omitted generic type arguments get implicit `Any` values. The type `list` is equivalent to `list[Any]`, and so on.

Example:

`` `python     # mypy: disallow-any-generics      # Error: Missing type parameters for generic type "list"  [type-arg]     def remove_dups(items: list) -> list:         ...  .. _code-no-untyped-def:  Check that every function has an annotation [no-untyped-def] ``\` ------------------------------------------------------------

If you use `--disallow-untyped-defs <mypy --disallow-untyped-defs>`, mypy requires that all functions have annotations (either a Python 3 annotation or a type comment).

Example:

`` `python     # mypy: disallow-untyped-defs      def inc(x):  # Error: Function is missing a type annotation  [no-untyped-def]         return x + 1      def inc_ok(x: int) -> int:  # OK         return x + 1      class Counter:          # Error: Function is missing a type annotation  [no-untyped-def]          def __init__(self):              self.value = 0      class CounterOk:          # OK: An explicit "-> None" is needed if "__init__" takes no arguments          def __init__(self) -> None:              self.value = 0  .. _code-redundant-cast:  Check that cast is not redundant [redundant-cast] ``\` -------------------------------------------------

If you use `--warn-redundant-casts <mypy --warn-redundant-casts>`, mypy will generate an error if the source type of a cast is the same as the target type.

Example:

`` `python     # mypy: warn-redundant-casts      from typing import cast      Count = int      def example(x: Count) -> int:         # Error: Redundant cast to "int"  [redundant-cast]         return cast(int, x)  .. _code-redundant-self:  Check that methods do not have redundant Self annotations [redundant-self] ``\` --------------------------------------------------------------------------

If a method uses the `Self` type in the return type or the type of a non-self argument, there is no need to annotate the `self` argument explicitly. Such annotations are allowed by `673` but are redundant. If you enable this error code, mypy will generate an error if there is a redundant `Self` type.

Example:

`` `python    # mypy: enable-error-code="redundant-self"     from typing import Self     class C:        # Error: Redundant "Self" annotation for the first method argument        def copy(self: Self) -> Self:            return type(self)()  .. _code-comparison-overlap:  Check that comparisons are overlapping [comparison-overlap] ``\` -----------------------------------------------------------

If you use `--strict-equality <mypy --strict-equality>`, mypy will generate an error if it thinks that a comparison operation is always true or false. These are often bugs. Sometimes mypy is too picky and the comparison can actually be useful. Instead of disabling strict equality checking everywhere, you can use `# type: ignore[comparison-overlap]` to ignore the issue on a particular line only.

Example:

`` `python     # mypy: strict-equality      def is_magic(x: bytes) -> bool:         # Error: Non-overlapping equality check (left operand type: "bytes",         #        right operand type: "str")  [comparison-overlap]         return x == 'magic'  We can fix the error by changing the string literal to a bytes ``\` literal:

`` `python     # mypy: strict-equality      def is_magic(x: bytes) -> bool:         return x == b'magic'  # OK  .. _code-no-untyped-call:  Check that no untyped functions are called [no-untyped-call] ``\` ------------------------------------------------------------

If you use `--disallow-untyped-calls <mypy --disallow-untyped-calls>`, mypy generates an error when you call an unannotated function in an annotated function.

Example:

`` `python     # mypy: disallow-untyped-calls      def do_it() -> None:         # Error: Call to untyped function "bad" in typed context  [no-untyped-call]         bad()      def bad():         ...  .. _code-no-any-return:  Check that function does not return Any value [no-any-return] ``\` -------------------------------------------------------------

If you use `--warn-return-any <mypy --warn-return-any>`, mypy generates an error if you return a value with an `Any` type in a function that is annotated to return a non-`Any` value.

Example:

`` `python     # mypy: warn-return-any      def fields(s):          return s.split(',')      def first_field(x: str) -> str:         # Error: Returning Any from function declared to return "str"  [no-any-return]         return fields(x)[0]  .. _code-no-any-unimported:  Check that types have no Any components due to missing imports [no-any-unimported] ``\` ----------------------------------------------------------------------------------

If you use `--disallow-any-unimported <mypy --disallow-any-unimported>`, mypy generates an error if a component of a type becomes `Any` because mypy couldn't resolve an import. These "stealth" `Any` types can be surprising and accidentally cause imprecise type checking.

In this example, we assume that mypy can't find the module `animals`, which means that `Cat` falls back to `Any` in a type annotation:

`` `python     # mypy: disallow-any-unimported      from animals import Cat  # type: ignore      # Error: Argument 1 to "feed" becomes "Any" due to an unfollowed import  [no-any-unimported]     def feed(cat: Cat) -> None:         ...  .. _code-unreachable:  Check that statement or expression is unreachable [unreachable] ``\` ---------------------------------------------------------------

If you use `--warn-unreachable <mypy --warn-unreachable>`, mypy generates an error if it thinks that a statement or expression will never be executed. In most cases, this is due to incorrect control flow or conditional checks that are accidentally always true or false.

`` `python     # mypy: warn-unreachable      def example(x: int) -> None:         # Error: Right operand of "or" is never evaluated  [unreachable]         assert isinstance(x, int) or x == 'unused'          return         # Error: Statement is unreachable  [unreachable]         print('unreachable')  .. _code-deprecated:  Check that imported or used feature is deprecated [deprecated] ``\` --------------------------------------------------------------

By default, mypy generates a note if your code imports a deprecated feature explicitly with a `from mod import depr` statement or uses a deprecated feature imported otherwise or defined locally. Features are considered deprecated when decorated with `warnings.deprecated`, as specified in [PEP 702](https://peps.python.org/pep-0702). You can silence single notes via `# type: ignore[deprecated]` or turn off this check completely via `--disable-error-code=deprecated`. Use the `--report-deprecated-as-error <mypy --report-deprecated-as-error>` option for more strictness, which turns all such notes into errors.

\> **Note** \> The `warnings` module provides the `@deprecated` decorator since Python 3.13. To use it with older Python versions, import it from `typing_extensions` instead.

Examples:

`` `python     # mypy: report-deprecated-as-error      # Error: abc.abstractproperty is deprecated: Deprecated, use 'property' with 'abstractmethod' instead     from abc import abstractproperty      from typing_extensions import deprecated      @deprecated("use new_function")     def old_function() -> None:         print("I am old")      # Error: __main__.old_function is deprecated: use new_function     old_function()     old_function()  # type: ignore[deprecated]   .. _code-redundant-expr:  Check that expression is redundant [redundant-expr] ``\` ---------------------------------------------------

If you use `--enable-error-code redundant-expr <mypy --enable-error-code>`, mypy generates an error if it thinks that an expression is redundant.

`` `python     # mypy: enable-error-code="redundant-expr"      def example(x: int) -> None:         # Error: Left operand of "and" is always true  [redundant-expr]         if isinstance(x, int) and x > 0:             pass          # Error: If condition is always true  [redundant-expr]         1 if isinstance(x, int) else 0          # Error: If condition in comprehension is always true  [redundant-expr]         [i for i in range(x) if isinstance(i, int)]   .. _code-possibly-undefined:  Warn about variables that are defined only in some execution paths [possibly-undefined] ``\` ---------------------------------------------------------------------------------------

If you use `--enable-error-code possibly-undefined <mypy --enable-error-code>`, mypy generates an error if it cannot verify that a variable will be defined in all execution paths. This includes situations when a variable definition appears in a loop, in a conditional branch, in an except handler, etc. For example:

`` `python     # mypy: enable-error-code="possibly-undefined"      from collections.abc import Iterable      def test(values: Iterable[int], flag: bool) -> None:         if flag:             a = 1         z = a + 1  # Error: Name "a" may be undefined [possibly-undefined]          for v in values:             b = v         z = b + 1  # Error: Name "b" may be undefined [possibly-undefined]  .. _code-truthy-bool:  Check that expression is not implicitly true in boolean context [truthy-bool] ``\` -----------------------------------------------------------------------------

Warn when the type of an expression in a boolean context does not implement `__bool__` or `__len__`. Unless one of these is implemented by a subtype, the expression will always be considered true, and there may be a bug in the condition.

As an exception, the `object` type is allowed in a boolean context. Using an iterable value in a boolean context has a separate error code (see below).

`` `python     # mypy: enable-error-code="truthy-bool"      class Foo:         pass     foo = Foo()     # Error: "foo" has type "Foo" which does not implement __bool__ or __len__ so it could always be true in boolean context     if foo:          ...  .. _code-truthy-iterable:  Check that iterable is not implicitly true in boolean context [truthy-iterable] ``\` -------------------------------------------------------------------------------

Generate an error if a value of type `Iterable` is used as a boolean condition, since `Iterable` does not implement `__len__` or `__bool__`.

Example:

`` `python     from collections.abc import Iterable      def transform(items: Iterable[int]) -> list[int]:         # Error: "items" has type "Iterable[int]" which can always be true in boolean context. Consider using "Collection[int]" instead.  [truthy-iterable]         if not items:             return [42]         return [x + 1 for x in items]  If ``transform`is called with a`Generator`argument, such as`<span class="title-ref"> </span><span class="title-ref">int(x) for x in \[\]</span><span class="title-ref">, this function would not return </span><span class="title-ref">\[42\]</span><span class="title-ref"> unlike what might be intended. Of course, it's possible that </span><span class="title-ref">transform</span><span class="title-ref"> is only called with </span><span class="title-ref">list</span><span class="title-ref"> or other container objects, and the </span><span class="title-ref">if not items</span><span class="title-ref"> check is actually valid. If that is the case, it is recommended to annotate </span><span class="title-ref">items</span><span class="title-ref"> as </span><span class="title-ref">Collection\[int\]</span><span class="title-ref"> instead of </span><span class="title-ref">Iterable\[int\]</span>\`.

## Check that `# type: ignore` include an error code \[ignore-without-code\]

Warn when a `# type: ignore` comment does not specify any error codes. This clarifies the intent of the ignore and ensures that only the expected errors are silenced.

Example:

`` `python     # mypy: enable-error-code="ignore-without-code"      class Foo:         def __init__(self, name: str) -> None:             self.name = name      f = Foo('foo')      # This line has a typo that mypy can't help with as both:     # - the expected error 'assignment', and     # - the unexpected error 'attr-defined'     # are silenced.     # Error: "type: ignore" comment without error code (consider "type: ignore[attr-defined]" instead)     f.nme = 42  # type: ignore      # This line warns correctly about the typo in the attribute name     # Error: "Foo" has no attribute "nme"; maybe "name"?     f.nme = 42  # type: ignore[assignment]  .. _code-unused-awaitable:  Check that awaitable return value is used [unused-awaitable] ``\` ------------------------------------------------------------

If you use `--enable-error-code unused-awaitable <mypy --enable-error-code>`, mypy generates an error if you don't use a returned value that defines `__await__`.

Example:

`` `python     # mypy: enable-error-code="unused-awaitable"      import asyncio      async def f() -> int: ...      async def g() -> None:         # Error: Value of type "Task[int]" must be used         #        Are you missing an await?         asyncio.create_task(f())  You can assign the value to a temporary, otherwise unused variable to ``\` silence the error:

`` `python     async def g() -> None:         _ = asyncio.create_task(f())  # No error  .. _code-unused-ignore:  Check that ``\# type: ignore`comment is used [unused-ignore]`\` -------------------------------------------------------------

If you use `--enable-error-code unused-ignore <mypy --enable-error-code>`, or `--warn-unused-ignores <mypy --warn-unused-ignores>` mypy generates an error if you don't use a `# type: ignore` comment, i.e. if there is a comment, but there would be no error generated by mypy on this line anyway.

Example:

`` `python     # Use "mypy --warn-unused-ignores ..."      def add(a: int, b: int) -> int:         # Error: unused "type: ignore" comment         return a + b  # type: ignore  Note that due to a specific nature of this comment, the only way to selectively ``<span class="title-ref"> silence it, is to include the error code explicitly. Also note that this error is not shown if the </span><span class="title-ref">\# type: ignore</span>\` is not used due to code being statically unreachable (e.g. due to platform or version checks).

Example:

`` `python     # Use "mypy --warn-unused-ignores ..."      import sys      try:         # The "[unused-ignore]" is needed to get a clean mypy run         # on both Python 3.8, and 3.9 where this module was added         import graphlib  # type: ignore[import,unused-ignore]     except ImportError:         pass      if sys.version_info >= (3, 9):         # The following will not generate an error on either         # Python 3.8, or Python 3.9         42 + "testing..."  # type: ignore  .. _code-explicit-override:  Check that ``@override`is used when overriding a base class method [explicit-override]`\` ----------------------------------------------------------------------------------------

If you use `--enable-error-code explicit-override <mypy --enable-error-code>` mypy generates an error if you override a base class method without using the `@override` decorator. An error will not be emitted for overrides of `__init__` or `__new__`. See [PEP 698](https://peps.python.org/pep-0698/#strict-enforcement-per-project).

\> **Note** \> Starting with Python 3.12, the `@override` decorator can be imported from `typing`. To use it with older Python versions, import it from `typing_extensions` instead.

Example:

`` `python     # mypy: enable-error-code="explicit-override"      from typing import override      class Parent:         def f(self, x: int) -> None:             pass          def g(self, y: int) -> None:             pass       class Child(Parent):         def f(self, x: int) -> None:  # Error: Missing @override decorator             pass          @override         def g(self, y: int) -> None:             pass  .. _code-mutable-override:  Check that overrides of mutable attributes are safe [mutable-override] ``\` ----------------------------------------------------------------------

<span class="title-ref">mutable-override</span> will enable the check for unsafe overrides of mutable attributes. For historical reasons, and because this is a relatively common pattern in Python, this check is not enabled by default. The example below is unsafe, and will be flagged when this error code is enabled:

`` `python     from typing import Any      class C:         x: float         y: float         z: float      class D(C):         x: int  # Error: Covariant override of a mutable attribute                 # (base class "C" defined the type as "float",                 # expression has type "int")  [mutable-override]         y: float  # OK         z: Any  # OK      def f(c: C) -> None:         c.x = 1.1     d = D()     f(d)     d.x >> 1  # This will crash at runtime, because d.x is now float, not an int  .. _code-unimported-reveal:  Check that ``reveal\_type`is imported from typing or typing_extensions [unimported-reveal]`\` -------------------------------------------------------------------------------------------

Mypy used to have `reveal_type` as a special builtin that only existed during type-checking. In runtime it fails with expected `NameError`, which can cause real problem in production, hidden from mypy.

But, in Python3.11 :py\`typing.reveal\_type\` was added. `typing_extensions` ported this helper to all supported Python versions.

Now users can actually import `reveal_type` to make the runtime code safe.

\> **Note** \> Starting with Python 3.11, the `reveal_type` function can be imported from `typing`. To use it with older Python versions, import it from `typing_extensions` instead.

`` `python     # mypy: enable-error-code="unimported-reveal"      x = 1     reveal_type(x)  # Note: Revealed type is "builtins.int" \                     # Error: Name "reveal_type" is not defined  Correct usage:  .. code-block:: python      # mypy: enable-error-code="unimported-reveal"     from typing import reveal_type   # or `typing_extensions`      x = 1     # This won't raise an error:     reveal_type(x)  # Note: Revealed type is "builtins.int"  When this code is enabled, using ``reveal\_locals`is always an error,`\` because there's no way one can import it.

## Check that `TypeIs` narrows types \[narrowed-type-not-subtype\]

`742` requires that when `TypeIs` is used, the narrowed type must be a subtype of the original type:

    from typing_extensions import TypeIs
    
    def f(x: int) -> TypeIs[str]:  # Error, str is not a subtype of int
        ...
    
    def g(x: object) -> TypeIs[str]:  # OK
        ...

---

error_codes.md

---

# Error codes

Mypy can optionally display an error code such as `[attr-defined]` after each error message. Error codes serve two purposes:

1.  It's possible to silence specific error codes on a line using `# type: ignore[code]`. This way you won't accidentally ignore other, potentially more serious errors.
2.  The error code can be used to find documentation about the error. The next two topics (\[error-code-list\](\#error-code-list) and \[error-codes-optional\](\#error-codes-optional)) document the various error codes mypy can report.

Most error codes are shared between multiple related error messages. Error codes may change in future mypy releases.

## Silencing errors based on error codes

You can use a special comment `# type: ignore[code, ...]` to only ignore errors with a specific error code (or codes) on a particular line. This can be used even if you have not configured mypy to show error codes.

This example shows how to ignore an error about an imported name mypy thinks is undefined:

`` `python    # 'foo' is defined in 'foolib', even though mypy can't see the    # definition.    from foolib import foo  # type: ignore[attr-defined]  Enabling/disabling specific error codes globally ``\` ------------------------------------------------

There are command-line flags and config file settings for enabling certain optional error codes, such as `--disallow-untyped-defs <mypy --disallow-untyped-defs>`, which enables the `no-untyped-def` error code.

You can use `--enable-error-code <mypy --enable-error-code>` and `--disable-error-code <mypy --disable-error-code>` to enable or disable specific error codes that don't have a dedicated command-line flag or config file setting.

## Per-module enabling/disabling error codes

You can use \[configuration file \<config-file\>\](\#configuration-file-\<config-file\>) sections to enable or disable specific error codes only in some modules. For example, this `mypy.ini` config will enable non-annotated empty containers in tests, while keeping other parts of code checked in strict mode:

`` `ini    [mypy]    strict = True     [mypy-tests.*]    allow_untyped_defs = True    allow_untyped_calls = True    disable_error_code = var-annotated, has-type  Note that per-module enabling/disabling acts as override over the global ``\` options. So that you don't need to repeat the error code lists for each module if you have them in global config section. For example:

`` `ini    [mypy]    enable_error_code = truthy-bool, ignore-without-code, unused-awaitable     [mypy-extensions.*]    disable_error_code = unused-awaitable  The above config will allow unused awaitables in extension modules, but will ``\` still keep the other two error codes enabled. The overall logic is following:

  - Command line and/or config main section set global error codes
  - Individual config sections *adjust* them per glob/module
  - Inline `# mypy: disable-error-code="..."` and `# mypy: enable-error-code="..."` comments can further *adjust* them for a specific file. For example:

`` `python   # mypy: enable-error-code="truthy-bool, ignore-without-code"  So one can e.g. enable some code globally, disable it for all tests in ``\` the corresponding config section, and then re-enable it with an inline comment in some specific test.

## Subcodes of error codes

In some cases, mostly for backwards compatibility reasons, an error code may be covered also by another, wider error code. For example, an error with code `[method-assign]` can be ignored by `# type: ignore[assignment]`. Similar logic works for disabling error codes globally. If a given error code is a subcode of another one, it will be mentioned in the documentation for the narrower code. This hierarchy is not nested: there cannot be subcodes of other subcodes.

## Requiring error codes

It's possible to require error codes be specified in `type: ignore` comments. See \[ignore-without-code\<code-ignore-without-code\>\](\#ignore-without-code\<code-ignore-without-code\>) for more information.

---

existing_code.md

---

# Using mypy with an existing codebase

This section explains how to get started using mypy with an existing, significant codebase that has little or no type annotations. If you are a beginner, you can skip this section.

## Start small

If your codebase is large, pick a subset of your codebase (say, 5,000 to 50,000 lines) and get mypy to run successfully only on this subset at first, *before adding annotations*. This should be doable in a day or two. The sooner you get some form of mypy passing on your codebase, the sooner you benefit.

You'll likely need to fix some mypy errors, either by inserting annotations requested by mypy or by adding `# type: ignore` comments to silence errors you don't want to fix now.

We'll mention some tips for getting mypy passing on your codebase in various sections below.

## Run mypy consistently and prevent regressions

Make sure all developers on your codebase run mypy the same way. One way to ensure this is adding a small script with your mypy invocation to your codebase, or adding your mypy invocation to existing tools you use to run tests, like `tox`.

  - Make sure everyone runs mypy with the same options. Checking a mypy \[configuration file \<config-file\>\](\#configuration-file-\<config-file\>) into your codebase is the easiest way to do this.
  - Make sure everyone type checks the same set of files. See \[specifying-code-to-be-checked\](\#specifying-code-to-be-checked) for details.
  - Make sure everyone runs mypy with the same version of mypy, for instance by pinning mypy with the rest of your dev requirements.

In particular, you'll want to make sure to run mypy as part of your Continuous Integration (CI) system as soon as possible. This will prevent new type errors from being introduced into your codebase.

A simple CI script could look something like this:

`` `text     python3 -m pip install mypy==1.8     # Run your standardised mypy invocation, e.g.     mypy my_project     # This could also look like `scripts/run_mypy.sh`, `tox run -e mypy`, `make mypy`, etc  Ignoring errors from certain modules ``\` ------------------------------------

By default mypy will follow imports in your code and try to check everything. This means even if you only pass in a few files to mypy, it may still process a large number of imported files. This could potentially result in lots of errors you don't want to deal with at the moment.

One way to deal with this is to ignore errors in modules you aren't yet ready to type check. The `ignore_errors` option is useful for this, for instance, if you aren't yet ready to deal with errors from `package_to_fix_later`:

`` `text    [mypy-package_to_fix_later.*]    ignore_errors = True  You could even invert this, by setting ``ignore\_errors = True`in your global`<span class="title-ref"> config section and only enabling error reporting with </span><span class="title-ref">ignore\_errors = False</span>\` for the set of modules you are ready to type check.

The per-module configuration that mypy's configuration file allows can be extremely useful. Many configuration options can be enabled or disabled only for specific modules. In particular, you can also enable or disable various error codes on a per-module basis, see \[error-codes\](\#error-codes).

## Fixing errors related to imports

A common class of error you will encounter is errors from mypy about modules that it can't find, that don't have types, or don't have stub files:

`` `text     core/config.py:7: error: Cannot find implementation or library stub for module named 'frobnicate'     core/model.py:9: error: Cannot find implementation or library stub for module named 'acme'     ...  Sometimes these can be fixed by installing the relevant packages or ``<span class="title-ref"> stub libraries in the environment you're running </span><span class="title-ref">mypy</span>\` in.

See \[fix-missing-imports\](\#fix-missing-imports) for a complete reference on these errors and the ways in which you can fix them.

You'll likely find that you want to suppress all errors from importing a given module that doesn't have types. If you only import that module in one or two places, you can use `# type: ignore` comments. For example, here we ignore an error about a third-party module `frobnicate` that doesn't have stubs using `# type: ignore`:

`` `python    import frobnicate  # type: ignore    ...    frobnicate.initialize()  # OK (but not checked)  But if you import the module in many places, this becomes unwieldy. In this ``<span class="title-ref"> case, we recommend using a \[configuration file \<config-file\>\](\#configuration-file-\<config-file\>). For example, to disable errors about importing </span><span class="title-ref">frobnicate</span><span class="title-ref"> and </span><span class="title-ref">acme</span>\` everywhere in your codebase, use a config like this:

`` `text    [mypy-frobnicate.*]    ignore_missing_imports = True     [mypy-acme.*]    ignore_missing_imports = True  If you get a large number of errors, you may want to ignore all errors ``<span class="title-ref"> about missing imports, for instance by setting :option:</span>--disable-error-code=import-untyped \<mypy --ignore-missing-imports\><span class="title-ref">. or setting :confval:\`ignore\_missing\_imports</span> to true globally. This can hide errors later on, so we recommend avoiding this if possible.

Finally, mypy allows fine-grained control over specific import following behaviour. It's very easy to silently shoot yourself in the foot when playing around with these, so this should be a last resort. For more details, look \[here \<follow-imports\>\](\#here-\<follow-imports\>).

## Prioritise annotating widely imported modules

Most projects have some widely imported modules, such as utilities or model classes. It's a good idea to annotate these pretty early on, since this allows code using these modules to be type checked more effectively.

Mypy is designed to support gradual typing, i.e. letting you add annotations at your own pace, so it's okay to leave some of these modules unannotated. The more you annotate, the more useful mypy will be, but even a little annotation coverage is useful.

## Write annotations as you go

Consider adding something like these in your code style conventions:

1.  Developers should add annotations for any new code.
2.  It's also encouraged to write annotations when you modify existing code.

This way you'll gradually increase annotation coverage in your codebase without much effort.

## Automate annotation of legacy code

There are tools for automatically adding draft annotations based on simple static analysis or on type profiles collected at runtime. Tools include \[monkeytype:index\](monkeytype:index.md), [autotyping](https://github.com/JelleZijlstra/autotyping) and [PyAnnotate](https://github.com/dropbox/pyannotate).

A simple approach is to collect types from test runs. This may work well if your test coverage is good (and if your tests aren't very slow).

Another approach is to enable type collection for a small, random fraction of production network requests. This clearly requires more care, as type collection could impact the reliability or the performance of your service.

## Introduce stricter options

Mypy is very configurable. Once you get started with static typing, you may want to explore the various strictness options mypy provides to catch more bugs. For example, you can ask mypy to require annotations for all functions in certain modules to avoid accidentally introducing code that won't be type checked using `disallow_untyped_defs`. Refer to \[config-file\](\#config-file) for the details.

An excellent goal to aim for is to have your codebase pass when run against `mypy --strict`. This basically ensures that you will never have a type related error without an explicit circumvention somewhere (such as a `# type: ignore` comment).

The following config is equivalent to `--strict` (as of mypy 1.0):

`` `text    # Start off with these    warn_unused_configs = True    warn_redundant_casts = True    warn_unused_ignores = True     # Getting these passing should be easy    strict_equality = True    strict_concatenate = True     # Strongly recommend enabling this one as soon as you can    check_untyped_defs = True     # These shouldn't be too much additional work, but may be tricky to    # get passing if you use a lot of untyped libraries    disallow_subclassing_any = True    disallow_untyped_decorators = True    disallow_any_generics = True     # These next few are various gradations of forcing use of type annotations    disallow_untyped_calls = True    disallow_incomplete_defs = True    disallow_untyped_defs = True     # This one isn't too hard to get passing, but return on investment is lower    no_implicit_reexport = True     # This one can be tricky to get passing if you use a lot of untyped libraries    warn_return_any = True  Note that you can also start with ``--strict`and subtract, for instance:  .. code-block:: text     strict = True    warn_return_any = False  Remember that many of these options can be enabled on a per-module basis. For instance,`<span class="title-ref"> you may want to enable </span><span class="title-ref">disallow\_untyped\_defs</span>\` for modules which you've completed annotations for, in order to prevent new code from being added without annotations.

And if you want, it doesn't stop at `--strict`. Mypy has additional checks that are not part of `--strict` that can be useful. See the complete \[command-line\](\#command-line) reference and \[error-codes-optional\](\#error-codes-optional).

## Speed up mypy runs

You can use \[mypy daemon \<mypy\_daemon\>\](\#mypy-daemon-\<mypy\_daemon\>) to get much faster incremental mypy runs. The larger your project is, the more useful this will be. If your project has at least 100,000 lines of code or so, you may also want to set up \[remote caching \<remote-cache\>\](\#remote-caching-\<remote-cache\>) for further speedups.

---

extending_mypy.md

---

# Extending and integrating mypy

## Integrating mypy into another Python application

It is possible to integrate mypy into another Python 3 application by importing `mypy.api` and calling the `run` function with a parameter of type `list[str]`, containing what normally would have been the command line arguments to mypy.

Function `run` returns a `tuple[str, str, int]`, namely `(<normal_report>, <error_report>, <exit_status>)`, in which `<normal_report>` is what mypy normally writes to :py\`sys.stdout\`, `<error_report>` is what mypy normally writes to :py\`sys.stderr\` and `exit_status` is the exit status mypy normally returns to the operating system.

A trivial example of using the api is the following

`` `python     import sys     from mypy import api      result = api.run(sys.argv[1:])      if result[0]:         print('\nType checking report:\n')         print(result[0])  # stdout      if result[1]:         print('\nError report:\n')         print(result[1])  # stderr      print('\nExit status:', result[2])   .. _extending-mypy-using-plugins:  Extending mypy using plugins ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Python is a highly dynamic language and has extensive metaprogramming capabilities. Many popular libraries use these to create APIs that may be more flexible and/or natural for humans, but are hard to express using static types. Extending the `484` type system to accommodate all existing dynamic patterns is impractical and often just impossible.

Mypy supports a plugin system that lets you customize the way mypy type checks code. This can be useful if you want to extend mypy so it can type check code that uses a library that is difficult to express using just `484` types.

The plugin system is focused on improving mypy's understanding of *semantics* of third party frameworks. There is currently no way to define new first class kinds of types.

\> **Note** \> The plugin system is experimental and prone to change. If you want to write a mypy plugin, we recommend you start by contacting the mypy core developers on [gitter](https://gitter.im/python/typing). In particular, there are no guarantees about backwards compatibility.

> Backwards incompatible changes may be made without a deprecation period, but we will announce them in [the plugin API changes announcement issue](https://github.com/python/mypy/issues/6617).

## Configuring mypy to use plugins

Plugins are Python files that can be specified in a mypy \[config file \<config-file\>\](\#config-file-\<config-file\>) using the `plugins` option and one of the two formats: relative or absolute path to the plugin file, or a module name (if the plugin is installed using `pip install` in the same virtual environment where mypy is running). The two formats can be mixed, for example:

`` `ini     [mypy]     plugins = /one/plugin.py, other.plugin  Mypy will try to import the plugins and will look for an entry point function ``<span class="title-ref"> named </span><span class="title-ref">plugin</span>\`. If the plugin entry point function has a different name, it can be specified after colon:

`` `ini     [mypy]     plugins = custom_plugin:custom_entry_point  In the following sections we describe the basics of the plugin system with ``<span class="title-ref"> some examples. For more technical details, please read the docstrings in \`mypy/plugin.py \<https://github.com/python/mypy/blob/master/mypy/plugin.py\></span>\_ in mypy source code. Also you can find good examples in the bundled plugins located in [mypy/plugins](https://github.com/python/mypy/tree/master/mypy/plugins).

## High-level overview

Every entry point function should accept a single string argument that is a full mypy version and return a subclass of `mypy.plugin.Plugin`:

`` `python    from mypy.plugin import Plugin     class CustomPlugin(Plugin):        def get_type_analyze_hook(self, fullname: str):            # see explanation below            ...     def plugin(version: str):        # ignore version argument if the plugin works with all mypy versions.        return CustomPlugin  During different phases of analyzing the code (first in semantic analysis, ``<span class="title-ref"> and then in type checking) mypy calls plugin methods such as </span><span class="title-ref">get\_type\_analyze\_hook()</span>\` on user plugins. This particular method, for example, can return a callback that mypy will use to analyze unbound types with the given full name. See the full plugin hook method list \[below \<plugin\_hooks\>\](\#below-\<plugin\_hooks\>).

Mypy maintains a list of plugins it gets from the config file plus the default (built-in) plugin that is always enabled. Mypy calls a method once for each plugin in the list until one of the methods returns a non-`None` value. This callback will be then used to customize the corresponding aspect of analyzing/checking the current abstract syntax tree node.

The callback returned by the `get_xxx` method will be given a detailed current context and an API to create new nodes, new types, emit error messages, etc., and the result will be used for further processing.

Plugin developers should ensure that their plugins work well in incremental and daemon modes. In particular, plugins should not hold global state due to caching of plugin hook results.

## Current list of plugin hooks

**get\_type\_analyze\_hook()** customizes behaviour of the type analyzer. For example, `484` doesn't support defining variadic generic types:

`` `python    from lib import Vector     a: Vector[int, int]    b: Vector[int, int, int]  When analyzing this code, mypy will call ``get\_type\_analyze\_hook("lib.Vector")`,`\` so the plugin can return some valid type for each variable.

**get\_function\_hook()** is used to adjust the return type of a function call. This hook will be also called for instantiation of classes. This is a good choice if the return type is too complex to be expressed by regular python typing.

**get\_function\_signature\_hook()** is used to adjust the signature of a function.

**get\_method\_hook()** is the same as `get_function_hook()` but for methods instead of module level functions.

**get\_method\_signature\_hook()** is used to adjust the signature of a method. This includes special Python methods except :py\`\~object.\_\_init\_\_<span class="title-ref"> and :py</span>\~object.\_\_new\_\_\`. For example in this code:

`` `python    from ctypes import Array, c_int     x: Array[c_int]    x[0] = 42  mypy will call ``get\_method\_signature\_hook("ctypes.Array.\_\_setitem\_\_")`  `<span class="title-ref"> so that the plugin can mimic the :py:mod:\`ctypes</span> auto-convert behavior.

**get\_attribute\_hook()** overrides instance member field lookups and property access (not method calls). This hook is only called for fields which already exist on the class. *Exception:* if :py\`\_\_getattr\_\_ \<object.\_\_getattr\_\_\><span class="title-ref"> or :py</span>\_\_getattribute\_\_ \<object.\_\_getattribute\_\_\>\` is a method on the class, the hook is called for all fields which do not refer to methods.

**get\_class\_attribute\_hook()** is similar to above, but for attributes on classes rather than instances. Unlike above, this does not have special casing for :py\`\_\_getattr\_\_ \<object.\_\_getattr\_\_\><span class="title-ref"> or :py</span>\_\_getattribute\_\_ \<object.\_\_getattribute\_\_\>\`.

**get\_class\_decorator\_hook()** can be used to update class definition for given class decorators. For example, you can add some attributes to the class to match runtime behaviour:

`` `python    from dataclasses import dataclass     @dataclass  # built-in plugin adds `__init__` method here    class User:        name: str     user = User(name='example')  # mypy can understand this using a plugin  **get_metaclass_hook()** is similar to above, but for metaclasses.  **get_base_class_hook()** is similar to above, but for base classes.  **get_dynamic_class_hook()** can be used to allow dynamic class definitions ``\` in mypy. This plugin hook is called for every assignment to a simple name where right hand side is a function call:

`` `python    from lib import dynamic_class     X = dynamic_class('X', [])  For such definition, mypy will call ``get\_dynamic\_class\_hook("lib.dynamic\_class")`.`<span class="title-ref"> The plugin should create the corresponding </span><span class="title-ref">mypy.nodes.TypeInfo</span>\` object, and place it into a relevant symbol table. (Instances of this class represent classes in mypy and hold essential information such as qualified name, method resolution order, etc.)

**get\_customize\_class\_mro\_hook()** can be used to modify class MRO (for example insert some entries there) before the class body is analyzed.

**get\_additional\_deps()** can be used to add new dependencies for a module. It is called before semantic analysis. For example, this can be used if a library has dependencies that are dynamically loaded based on configuration information.

**report\_config\_data()** can be used if the plugin has some sort of per-module configuration that can affect typechecking. In that case, when the configuration for a module changes, we want to invalidate mypy's cache for that module so that it can be rechecked. This hook should be used to report to mypy any relevant configuration data, so that mypy knows to recheck the module if the configuration changes. The hooks should return data encodable as JSON.

## Useful tools

Mypy ships `mypy.plugins.proper_plugin` plugin which can be useful for plugin authors, since it finds missing `get_proper_type()` calls, which is a pretty common mistake.

It is recommended to enable it is a part of your plugin's CI.

---

faq.md

---

# Frequently Asked Questions

## Why have both dynamic and static typing?

Dynamic typing can be flexible, powerful, convenient and easy. But it's not always the best approach; there are good reasons why many developers choose to use statically typed languages or static typing for Python.

Here are some potential benefits of mypy-style static typing:

  - Static typing can make programs easier to understand and maintain. Type declarations can serve as machine-checked documentation. This is important as code is typically read much more often than modified, and this is especially important for large and complex programs.
  - Static typing can help you find bugs earlier and with less testing and debugging. Especially in large and complex projects this can be a major time-saver.
  - Static typing can help you find difficult-to-find bugs before your code goes into production. This can improve reliability and reduce the number of security issues.
  - Static typing makes it practical to build very useful development tools that can improve programming productivity or software quality, including IDEs with precise and reliable code completion, static analysis tools, etc.
  - You can get the benefits of both dynamic and static typing in a single language. Dynamic typing can be perfect for a small project or for writing the UI of your program, for example. As your program grows, you can adapt tricky application logic to static typing to help maintenance.

See also the [front page](https://www.mypy-lang.org) of the mypy web site.

## Would my project benefit from static typing?

For many projects dynamic typing is perfectly fine (we think that Python is a great language). But sometimes your projects demand bigger guns, and that's when mypy may come in handy.

If some of these ring true for your projects, mypy (and static typing) may be useful:

  - Your project is large or complex.
  - Your codebase must be maintained for a long time.
  - Multiple developers are working on the same code.
  - Running tests takes a lot of time or work (type checking helps you find errors quickly early in development, reducing the number of testing iterations).
  - Some project members (devs or management) don't like dynamic typing, but others prefer dynamic typing and Python syntax. Mypy could be a solution that everybody finds easy to accept.
  - You want to future-proof your project even if currently none of the above really apply. The earlier you start, the easier it will be to adopt static typing.

## Can I use mypy to type check my existing Python code?

Mypy supports most Python features and idioms, and many large Python projects are using mypy successfully. Code that uses complex introspection or metaprogramming may be impractical to type check, but it should still be possible to use static typing in other parts of a codebase that are less dynamic.

## Will static typing make my programs run faster?

Mypy only does static type checking and it does not improve performance. It has a minimal performance impact. In the future, there could be other tools that can compile statically typed mypy code to C modules or to efficient JVM bytecode, for example, but this is outside the scope of the mypy project.

## Is mypy free?

Yes. Mypy is free software, and it can also be used for commercial and proprietary projects. Mypy is available under the MIT license.

## Can I use duck typing with mypy?

Mypy provides support for both [nominal subtyping](https://en.wikipedia.org/wiki/Nominative_type_system) and [structural subtyping](https://en.wikipedia.org/wiki/Structural_type_system). Structural subtyping can be thought of as "static duck typing". Some argue that structural subtyping is better suited for languages with duck typing such as Python. Mypy however primarily uses nominal subtyping, leaving structural subtyping mostly opt-in (except for built-in protocols such as :py\`\~collections.abc.Iterable\` that always support structural subtyping). Here are some reasons why:

1.  It is easy to generate short and informative error messages when using a nominal type system. This is especially important when using type inference.
2.  Python provides built-in support for nominal :py\`isinstance\` tests and they are widely used in programs. Only limited support for structural :py\`isinstance\` is available, and it's less type safe than nominal type tests.
3.  Many programmers are already familiar with static, nominal subtyping and it has been successfully used in languages such as Java, C++ and C\#. Fewer languages use structural subtyping.

However, structural subtyping can also be useful. For example, a "public API" may be more flexible if it is typed with protocols. Also, using protocol types removes the necessity to explicitly declare implementations of ABCs. As a rule of thumb, we recommend using nominal classes where possible, and protocols where necessary. For more details about protocol types and structural subtyping see \[protocol-types\](\#protocol-types) and `544`.

## I like Python and I have no need for static typing

The aim of mypy is not to convince everybody to write statically typed Python -- static typing is entirely optional, now and in the future. The goal is to give more options for Python programmers, to make Python a more competitive alternative to other statically typed languages in large projects, to improve programmer productivity, and to improve software quality.

## How are mypy programs different from normal Python?

Since you use a vanilla Python implementation to run mypy programs, mypy programs are also Python programs. The type checker may give warnings for some valid Python code, but the code is still always runnable. Also, a few Python features are still not supported by mypy, but this is gradually improving.

The obvious difference is the availability of static type checking. The section \[common\_issues\](\#common\_issues) mentions some modifications to Python code that may be required to make code type check without errors. Also, your code must make defined attributes explicit.

Mypy supports modular, efficient type checking, and this seems to rule out type checking some language features, such as arbitrary monkey patching of methods.

## How is mypy different from Cython?

\[Cython \<cython:index\>\](Cython \<cython:index\>.md) is a variant of Python that supports compilation to CPython C modules. It can give major speedups to certain classes of programs compared to CPython, and it provides static typing (though this is different from mypy). Mypy differs in the following aspects, among others:

  - Cython is much more focused on performance than mypy. Mypy is only about static type checking, and increasing performance is not a direct goal.
  - The mypy syntax is arguably simpler and more "Pythonic" (no cdef/cpdef, etc.) for statically typed code.
  - The mypy syntax is compatible with Python. Mypy programs are normal Python programs that can be run using any Python implementation. Cython has many incompatible extensions to Python syntax, and Cython programs generally cannot be run without first compiling them to CPython extension modules via C. Cython also has a pure Python mode, but it seems to support only a subset of Cython functionality, and the syntax is quite verbose.
  - Mypy has a different set of type system features. For example, mypy has genericity (parametric polymorphism), function types and bidirectional type inference, which are not supported by Cython. (Cython has fused types that are different but related to mypy generics. Mypy also has a similar feature as an extension of generics.)
  - The mypy type checker knows about the static types of many Python stdlib modules and can effectively type check code that uses them.
  - Cython supports accessing C functions directly and many features are defined in terms of translating them to C or C++. Mypy just uses Python semantics, and mypy does not deal with accessing C library functionality.

## Does it run on PyPy?

Somewhat. With PyPy 3.8, mypy is at least able to type check itself. With older versions of PyPy, mypy relies on [typed-ast](https://github.com/python/typed_ast), which uses several APIs that PyPy does not support (including some internal CPython APIs).

## Mypy is a cool project. Can I help?

Any help is much appreciated\! [Contact](https://www.mypy-lang.org/contact.html) the developers if you would like to contribute. Any help related to development, design, publicity, documentation, testing, web site maintenance, financing, etc. can be helpful. You can learn a lot by contributing, and anybody can help, even beginners\! However, some knowledge of compilers and/or type systems is essential if you want to work on mypy internals.

---

final_attrs.md

---

# Final names, methods and classes

This section introduces these related features:

1.  *Final names* are variables or attributes that should not be reassigned after initialization. They are useful for declaring constants.
2.  *Final methods* should not be overridden in a subclass.
3.  *Final classes* should not be subclassed.

All of these are only enforced by mypy, and only in annotated code. There is no runtime enforcement by the Python runtime.

\> **Note** \> The examples in this page import `Final` and `final` from the `typing` module. These types were added to `typing` in Python 3.8, but are also available for use in Python 3.4 - 3.7 via the `typing_extensions` package.

## Final names

You can use the `typing.Final` qualifier to indicate that a name or attribute should not be reassigned, redefined, or overridden. This is often useful for module and class-level constants to prevent unintended modification. Mypy will prevent further assignments to final names in type-checked code:

`` `python    from typing import Final     RATE: Final = 3_000     class Base:        DEFAULT_ID: Final = 0     RATE = 300  # Error: can't assign to final attribute    Base.DEFAULT_ID = 1  # Error: can't override a final attribute  Another use case for final attributes is to protect certain attributes ``\` from being overridden in a subclass:

`` `python    from typing import Final     class Window:        BORDER_WIDTH: Final = 2.5        ...     class ListView(Window):        BORDER_WIDTH = 3  # Error: can't override a final attribute  You can use :py`@property <property>` to make an attribute read-only, but unlike ``Final`,`\` it doesn't work with module attributes, and it doesn't prevent overriding in subclasses.

### Syntax variants

You can use `Final` in one of these forms:

  - You can provide an explicit type using the syntax `Final[<type>]`. Example:
    
    `` `python    ID: Final[int] = 1  Here, mypy will infer type ``int`for`ID\`\`.

  - You can omit the type:
    
    ``` python
    ID: Final = 1
    ```
    
    Here, mypy will infer type `Literal[1]` for `ID`. Note that unlike for generic classes, this is *not* the same as `Final[Any]`.

  - In class bodies and stub files, you can omit the right-hand side and just write `ID: Final[int]`.

  - Finally, you can write `self.id: Final = 1` (also optionally with a type in square brackets). This is allowed *only* in :py\`\_\_init\_\_ \<object.\_\_init\_\_\>\` methods so the final instance attribute is assigned only once when an instance is created.

Details of using `Final` `` ` **************************  These are the two main rules for defining a final name:  * There can be *at most one* final declaration per module or class for   a given attribute. There can't be separate class-level and instance-level   constants with the same name.  * There must be *exactly one* assignment to a final name.  A final attribute declared in a class body without an initializer must be initialized in the :py`__init__ <object.__init__>` method (you can skip the initializer in stub files): ``\`python class ImmutablePoint: x: Final\[int\] y: Final\[int\] \# Error: final attribute without an initializer

>   - def \_\_init\_\_(self) -\> None:  
>     self.x = 1 \# Good

`Final` can only be used as the outermost type in assignments or variable `` ` annotations. Using it in any other position is an error. In particular, ``Final`can't be used in annotations for function arguments:`\`python x: list\[Final\[int\]\] = \[\] \# Error\!

>   - def fun(x: Final\[list\[int\]\]) -\> None: \# Error\!  
>     ...

`Final` and :py\`\~typing.ClassVar\` should not be used together. Mypy will infer `` ` the scope of a final declaration automatically depending on whether it was initialized in the class body or in :py`__init__ <object.__init__>`.  A final attribute can't be overridden by a subclass (even with another explicit final declaration). Note, however, that a final attribute can override a read-only property: ``\`python class Base: @property def ID(self) -\> int: ...

>   - class Derived(Base):  
>     ID: Final = 1 \# OK

Declaring a name as final only guarantees that the name will not be re-bound `` ` to another value. It doesn't make the value immutable. You can use immutable ABCs and containers to prevent mutating such values: ``\`python x: Final = \['a', 'b'\] x.append('c') \# OK

> y: Final\[Sequence\[str\]\] = \['a', 'b'\] y.append('x') \# Error: Sequence is immutable z: Final = ('a', 'b') \# Also an option

Final methods `` ` -------------  Like with attributes, sometimes it is useful to protect a method from overriding. You can use the ``typing.final`decorator for this purpose:`\`python from typing import final

>   - class Base:  
>     @final def common\_name(self) -\> None: ...
> 
>   - class Derived(Base):
>     
>       - def common\_name(self) -\> None: \# Error: cannot override a final method  
>         ...

This `@final` decorator can be used with instance methods, class methods, `` ` static methods, and properties.  For overloaded methods, you should add ``@final`on the implementation to make it final (or on the first overload in stubs):`\`python from typing import final, overload

>   - class Base:  
>     @overload def method(self) -\> None: ... @overload def method(self, arg: int) -\> int: ... @final def method(self, x=None): ...

Final classes `` ` -------------  You can apply the ``typing.final`decorator to a class to indicate to mypy that it should not be subclassed:`\`python from typing import final

> @final class Leaf: ...
> 
>   - class MyLeaf(Leaf): \# Error: Leaf can't be subclassed  
>     ...

The decorator acts as a declaration for mypy (and as documentation for `` ` humans), but it doesn't actually prevent subclassing at runtime.  Here are some situations where using a final class may be useful:  * A class wasn't designed to be subclassed. Perhaps subclassing would not   work as expected, or subclassing would be error-prone. * Subclassing would make code harder to understand or maintain.   For example, you may want to prevent unnecessarily tight coupling between   base classes and subclasses. * You want to retain the freedom to arbitrarily change the class implementation   in the future, and these changes might break subclasses.  An abstract class that defines at least one abstract method or property and has ``@final`decorator will generate an error from mypy since those attributes could never be implemented.`\`python from abc import ABCMeta, abstractmethod from typing import final

@final class A(metaclass=ABCMeta): \# error: Final class A has abstract attributes "f" @abstractmethod def f(self, x: int) -\> None: pass \`\`\`

---

generics.md

---

# Generics

This section explains how you can define your own generic classes that take one or more type arguments, similar to built-in types such as `list[T]`. User-defined generics are a moderately advanced feature and you can get far without ever using them -- feel free to skip this section and come back later.

## Defining generic classes

The built-in collection classes are generic classes. Generic types accept one or more type arguments within `[...]`, which can be arbitrary types. For example, the type `dict[int, str]` has the type arguments `int` and `str`, and `list[int]` has the type argument `int`.

Programs can also define new generic classes. Here is a very simple generic class that represents a stack (using the syntax introduced in Python 3.12):

`` `python    class Stack[T]:        def __init__(self) -> None:            # Create an empty list with items of type T            self.items: list[T] = []         def push(self, item: T) -> None:            self.items.append(item)         def pop(self) -> T:            return self.items.pop()         def empty(self) -> bool:            return not self.items  There are two syntax variants for defining generic classes in Python. ``<span class="title-ref"> Python 3.12 introduced a \`new dedicated syntax \<https://docs.python.org/3/whatsnew/3.12.html\#pep-695-type-parameter-syntax\></span>\_ for defining generic classes (and also functions and type aliases, which we will discuss later). The above example used the new syntax. Most examples are given using both the new and the old (or legacy) syntax variants. Unless mentioned otherwise, they work the same -- but the new syntax is more readable and more convenient.

Here is the same example using the old syntax (required for Python 3.11 and earlier, but also supported on newer Python versions):

`` `python    from typing import TypeVar, Generic     T = TypeVar('T')  # Define type variable "T"     class Stack(Generic[T]):        def __init__(self) -> None:            # Create an empty list with items of type T            self.items: list[T] = []         def push(self, item: T) -> None:            self.items.append(item)         def pop(self) -> T:            return self.items.pop()         def empty(self) -> bool:            return not self.items  > **Note** >      There are currently no plans to deprecate the legacy syntax.     You can freely mix code using the new and old syntax variants,     even within a single file (but *not* within a single class).  The ``Stack`class can be used to represent a stack of any type:`<span class="title-ref"> </span><span class="title-ref">Stack\[int\]</span><span class="title-ref">, </span><span class="title-ref">Stack\[tuple\[int, str\]\]</span><span class="title-ref">, etc. You can think of </span><span class="title-ref">Stack\[int\]</span><span class="title-ref"> as referring to the definition of </span><span class="title-ref">Stack</span><span class="title-ref"> above, but with all instances of </span><span class="title-ref">T</span><span class="title-ref"> replaced with </span><span class="title-ref">int</span>\`.

Using `Stack` is similar to built-in container types:

`` `python    # Construct an empty Stack[int] instance    stack = Stack[int]()    stack.push(2)    stack.pop()     # error: Argument 1 to "push" of "Stack" has incompatible type "str"; expected "int"    stack.push('x')     stack2: Stack[str] = Stack()    stack2.append('x')  Construction of instances of generic types is type checked (Python 3.12 syntax):  .. code-block:: python     class Box[T]:        def __init__(self, content: T) -> None:            self.content = content     Box(1)       # OK, inferred type is Box[int]    Box[int](1)  # Also OK     # error: Argument 1 to "Box" has incompatible type "str"; expected "int"    Box[int]('some string')  Here is the definition of ``Box`using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python     from typing import TypeVar, Generic     T = TypeVar('T')     class Box(Generic[T]):        def __init__(self, content: T) -> None:            self.content = content  > **Note** >      Before moving on, let's clarify some terminology.     The name`T`in`class Stack\[T\]`or`class Stack(Generic\[T\])`declares a *type parameter*`T`(of class`Stack`).`T`is also called a *type variable*, especially in a type annotation,     such as in the signature of`push`above.     When the type`Stack\[...\]`is used in a type annotation, the type     within square brackets is called a *type argument*.     This is similar to the distinction between function parameters and arguments.  .. _generic-subclasses:  Defining subclasses of generic classes`\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

User-defined generic classes and generic classes defined in :py`typing` can be used as a base class for another class (generic or non-generic). For example (Python 3.12 syntax):

`` `python    from typing import Mapping, Iterator     # This is a generic subclass of Mapping    class MyMap[KT, VT](Mapping[KT, VT]):        def __getitem__(self, k: KT) -> VT: ...        def __iter__(self) -> Iterator[KT]: ...        def __len__(self) -> int: ...     items: MyMap[str, int]  # OK     # This is a non-generic subclass of dict    class StrDict(dict[str, str]):        def __str__(self) -> str:            return f'StrDict({super().__str__()})'     data: StrDict[int, int]  # Error! StrDict is not generic    data2: StrDict  # OK     # This is a user-defined generic class    class Receiver[T]:        def accept(self, value: T) -> None: ...     # This is a generic subclass of Receiver    class AdvancedReceiver[T](Receiver[T]): ...  Here is the above example using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python     from typing import Generic, TypeVar, Mapping, Iterator     KT = TypeVar('KT')    VT = TypeVar('VT')     # This is a generic subclass of Mapping    class MyMap(Mapping[KT, VT]):        def __getitem__(self, k: KT) -> VT: ...        def __iter__(self) -> Iterator[KT]: ...        def __len__(self) -> int: ...     items: MyMap[str, int]  # OK     # This is a non-generic subclass of dict    class StrDict(dict[str, str]):        def __str__(self) -> str:            return f'StrDict({super().__str__()})'     data: StrDict[int, int]  # Error! StrDict is not generic    data2: StrDict  # OK     # This is a user-defined generic class    class Receiver(Generic[T]):        def accept(self, value: T) -> None: ...     # This is a generic subclass of Receiver    class AdvancedReceiver(Receiver[T]): ...  > **Note** >      You have to add an explicit :py`~collections.abc.Mapping` base class     if you want mypy to consider a user-defined class as a mapping (and     :py`~collections.abc.Sequence` for sequences, etc.). This is because     mypy doesn't use *structural subtyping* for these ABCs, unlike simpler protocols     like :py`~collections.abc.Iterable`, which use     [structural subtyping <protocol-types>](#structural-subtyping-<protocol-types>).  When using the legacy syntax, :py`Generic <typing.Generic>` can be omitted ``<span class="title-ref"> from bases if there are other base classes that include type variables, such as </span><span class="title-ref">Mapping\[KT, VT\]</span><span class="title-ref"> in the above example. If you include </span><span class="title-ref">Generic\[...\]</span>\` in bases, then it should list all type variables present in other bases (or more, if needed). The order of type parameters is defined by the following rules:

  - If `Generic[...]` is present, then the order of parameters is always determined by their order in `Generic[...]`.
  - If there are no `Generic[...]` in bases, then all type parameters are collected in the lexicographic order (i.e. by first appearance).

Example:

`` `python    from typing import Generic, TypeVar, Any     T = TypeVar('T')    S = TypeVar('S')    U = TypeVar('U')     class One(Generic[T]): ...    class Another(Generic[T]): ...     class First(One[T], Another[S]): ...    class Second(One[T], Another[S], Generic[S, U, T]): ...     x: First[int, str]        # Here T is bound to int, S is bound to str    y: Second[int, str, Any]  # Here T is Any, S is int, and U is str  When using the Python 3.12 syntax, all type parameters must always be ``<span class="title-ref"> explicitly defined immediately after the class name within </span><span class="title-ref">\[...\]</span><span class="title-ref">, and the </span><span class="title-ref">Generic\[...\]</span>\` base class is never used.

## Generic functions

Functions can also be generic, i.e. they can have type parameters (Python 3.12 syntax):

`` `python    from collections.abc import Sequence     # A generic function!    def first[T](seq: Sequence[T]) -> T:        return seq[0]  Here is the same example using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python     from typing import TypeVar, Sequence     T = TypeVar('T')     # A generic function!    def first(seq: Sequence[T]) -> T:        return seq[0]  As with generic classes, the type parameter ``T`can be replaced with any`<span class="title-ref"> type. That means </span><span class="title-ref">first</span>\` can be passed an argument with any sequence type, and the return type is derived from the sequence item type. Example:

`` `python    reveal_type(first([1, 2, 3]))   # Revealed type is "builtins.int"    reveal_type(first(('a', 'b')))  # Revealed type is "builtins.str"  When using the legacy syntax, a single definition of a type variable ``<span class="title-ref"> (such as </span><span class="title-ref">T</span>\` above) can be used in multiple generic functions or classes. In this example we use the same type variable in two generic functions to declarare type parameters:

`` `python    from typing import TypeVar, Sequence     T = TypeVar('T')      # Define type variable     def first(seq: Sequence[T]) -> T:        return seq[0]     def last(seq: Sequence[T]) -> T:        return seq[-1]  Since the Python 3.12 syntax is more concise, it doesn't need (or have) ``\` an equivalent way of sharing type parameter definitions.

A variable cannot have a type variable in its type unless the type variable is bound in a containing generic class or function.

When calling a generic function, you can't explicitly pass the values of type parameters as type arguments. The values of type parameters are always inferred by mypy. This is not valid:

`` `python     first[int]([1, 2])  # Error: can't use [...] with generic function  If you really need this, you can define a generic class with a ``\_\_call\_\_`  `\` method.

## Type variables with upper bounds

A type variable can also be restricted to having values that are subtypes of a specific type. This type is called the upper bound of the type variable, and it is specified using `T: <bound>` when using the Python 3.12 syntax. In the definition of a generic function or a generic class that uses such a type variable `T`, the type represented by `T` is assumed to be a subtype of its upper bound, so you can use methods of the upper bound on values of type `T` (Python 3.12 syntax):

`` `python    from typing import SupportsAbs     def max_by_abs[T: SupportsAbs[float]](*xs: T) -> T:        # We can use abs(), because T is a subtype of SupportsAbs[float].        return max(xs, key=abs)  An upper bound can also be specified with the ``bound=...`keyword`<span class="title-ref"> argument to :py</span>\~typing.TypeVar\`. Here is the example using the legacy syntax (Python 3.11 and earlier):

`` `python    from typing import TypeVar, SupportsAbs     T = TypeVar('T', bound=SupportsAbs[float])     def max_by_abs(*xs: T) -> T:        return max(xs, key=abs)  In a call to such a function, the type ``T`must be replaced by a`\` type that is a subtype of its upper bound. Continuing the example above:

`` `python    max_by_abs(-3.5, 2)   # Okay, has type 'float'    max_by_abs(5+6j, 7)   # Okay, has type 'complex'    max_by_abs('a', 'b')  # Error: 'str' is not a subtype of SupportsAbs[float]  Type parameters of generic classes may also have upper bounds, which ``\` restrict the valid values for the type parameter in the same way.

## Generic methods and generic self

You can also define generic methods. In particular, the `self` parameter may also be generic, allowing a method to return the most precise type known at the point of access. In this way, for example, you can type check a chain of setter methods (Python 3.12 syntax):

`` `python    class Shape:        def set_scale[T: Shape](self: T, scale: float) -> T:            self.scale = scale            return self     class Circle(Shape):        def set_radius(self, r: float) -> 'Circle':            self.radius = r            return self     class Square(Shape):        def set_width(self, w: float) -> 'Square':            self.width = w            return self     circle: Circle = Circle().set_scale(0.5).set_radius(2.7)    square: Square = Square().set_scale(0.5).set_width(3.2)  Without using generic ``self`, the last two lines could not be type`<span class="title-ref"> checked properly, since the return type of </span><span class="title-ref">set\_scale</span><span class="title-ref"> would be </span><span class="title-ref">Shape</span><span class="title-ref">, which doesn't define </span><span class="title-ref">set\_radius</span><span class="title-ref"> or </span><span class="title-ref">set\_width</span>\`.

When using the legacy syntax, just use a type variable in the method signature that is different from class type parameters (if any are defined). Here is the above example using the legacy syntax (3.11 and earlier):

`` `python    from typing import TypeVar     T = TypeVar('T', bound='Shape')     class Shape:        def set_scale(self: T, scale: float) -> T:            self.scale = scale            return self     class Circle(Shape):        def set_radius(self, r: float) -> 'Circle':            self.radius = r            return self     class Square(Shape):        def set_width(self, w: float) -> 'Square':            self.width = w            return self     circle: Circle = Circle().set_scale(0.5).set_radius(2.7)    square: Square = Square().set_scale(0.5).set_width(3.2)  Other uses include factory methods, such as copy and deserialization methods. ``<span class="title-ref"> For class methods, you can also define generic </span><span class="title-ref">cls</span><span class="title-ref">, using </span><span class="title-ref">type\[T\]</span><span class="title-ref"> or :py\`Type\[T\] \<typing.Type\></span> (Python 3.12 syntax):

`` `python    class Friend:        other: "Friend | None" = None         @classmethod        def make_pair[T: Friend](cls: type[T]) -> tuple[T, T]:            a, b = cls(), cls()            a.other = b            b.other = a            return a, b     class SuperFriend(Friend):        pass     a, b = SuperFriend.make_pair()  Here is the same example using the legacy syntax (3.11 and earlier):  .. code-block:: python     from typing import TypeVar     T = TypeVar('T', bound='Friend')     class Friend:        other: "Friend | None" = None         @classmethod        def make_pair(cls: type[T]) -> tuple[T, T]:            a, b = cls(), cls()            a.other = b            b.other = a            return a, b     class SuperFriend(Friend):        pass     a, b = SuperFriend.make_pair()  Note that when overriding a method with generic ``self`, you must either`<span class="title-ref"> return a generic </span><span class="title-ref">self</span>\` too, or return an instance of the current class. In the latter case, you must implement this method in all future subclasses.

Note also that mypy cannot always verify that the implementation of a copy or a deserialization method returns the actual type of self. Therefore you may need to silence mypy inside these methods (but not at the call site), possibly by making use of the `Any` type or a `# type: ignore` comment.

Mypy lets you use generic self types in certain unsafe ways in order to support common idioms. For example, using a generic self type in an argument type is accepted even though it's unsafe (Python 3.12 syntax):

`` `python    class Base:        def compare[T: Base](self: T, other: T) -> bool:            return False     class Sub(Base):        def __init__(self, x: int) -> None:            self.x = x         # This is unsafe (see below) but allowed because it's        # a common pattern and rarely causes issues in practice.        def compare(self, other: 'Sub') -> bool:            return self.x > other.x     b: Base = Sub(42)    b.compare(Base())  # Runtime error here: 'Base' object has no attribute 'x'  For some advanced uses of self types, see [additional examples <advanced_self>](#additional-examples-<advanced_self>).  Automatic self types using typing.Self ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Since the patterns described above are quite common, mypy supports a simpler syntax, introduced in `673`, to make them easier to use. Instead of introducing a type parameter and using an explicit annotation for `self`, you can import the special type `typing.Self` that is automatically transformed into a method-level type parameter with the current class as the upper bound, and you don't need an annotation for `self` (or `cls` in class methods). The example from the previous section can be made simpler by using `Self`:

`` `python    from typing import Self     class Friend:        other: Self | None = None         @classmethod        def make_pair(cls) -> tuple[Self, Self]:            a, b = cls(), cls()            a.other = b            b.other = a            return a, b     class SuperFriend(Friend):        pass     a, b = SuperFriend.make_pair()  This is more compact than using explicit type parameters. Also, you can ``<span class="title-ref"> use </span><span class="title-ref">Self</span>\` in attribute annotations in addition to methods.

\> **Note** \> To use this feature on Python versions earlier than 3.11, you will need to import `Self` from `typing_extensions` (version 4.0 or newer).

## Variance of generic types

There are three main kinds of generic types with respect to subtype relations between them: invariant, covariant, and contravariant. Assuming that we have a pair of types `A` and `B`, and `B` is a subtype of `A`, these are defined as follows:

  - A generic class `MyCovGen[T]` is called covariant in type variable `T` if `MyCovGen[B]` is always a subtype of `MyCovGen[A]`.
  - A generic class `MyContraGen[T]` is called contravariant in type variable `T` if `MyContraGen[A]` is always a subtype of `MyContraGen[B]`.
  - A generic class `MyInvGen[T]` is called invariant in `T` if neither of the above is true.

Let us illustrate this by few simple examples:

`` `python     # We'll use these classes in the examples below     class Shape: ...     class Triangle(Shape): ...     class Square(Shape): ...  * Most immutable container types, such as :py`~collections.abc.Sequence`   and :py`~frozenset` are covariant. Union types are   also covariant in all union items: ``Triangle | int`is   a subtype of`Shape | int``.    .. code-block:: python      def count_lines(shapes: Sequence[Shape]) -> int:         return sum(shape.num_sides for shape in shapes)      triangles: Sequence[Triangle]     count_lines(triangles)  # OK      def foo(triangle: Triangle, num: int) -> None:         shape_or_number: Union[Shape, int]         # a Triangle is a Shape, and a Shape is a valid Union[Shape, int]         shape_or_number = triangle    Covariance should feel relatively intuitive, but contravariance and invariance   can be harder to reason about.  * :py`~collections.abc.Callable` is an example of type that behaves contravariant   in types of arguments. That is,``Callable\[\[Shape\], int\]`is a subtype of`Callable\[\[Triangle\], int\]`, despite`Shape`being a supertype of`Triangle`. To understand this, consider:    .. code-block:: python      def cost_of_paint_required(         triangle: Triangle,         area_calculator: Callable[[Triangle], float]     ) -> float:         return area_calculator(triangle) * DOLLAR_PER_SQ_FT      # This straightforwardly works     def area_of_triangle(triangle: Triangle) -> float: ...     cost_of_paint_required(triangle, area_of_triangle)  # OK      # But this works as well!     def area_of_any_shape(shape: Shape) -> float: ...     cost_of_paint_required(triangle, area_of_any_shape)  # OK`cost\_of\_paint\_required`needs a callable that can calculate the area of a   triangle. If we give it a callable that can calculate the area of an   arbitrary shape (not just triangles), everything still works.  *`list``is an invariant generic type. Naively, one would think   that it is covariant, like :py`~collections.abc.Sequence` above, but consider this code:    .. code-block:: python       class Circle(Shape):          # The rotate method is only defined on Circle, not on Shape          def rotate(self): ...       def add_one(things: list[Shape]) -> None:          things.append(Shape())       my_circles: list[Circle] = []      add_one(my_circles)     # This may appear safe, but...      my_circles[-1].rotate()  # ...this will fail, since my_circles[0] is now a Shape, not a Circle    Another example of invariant type is``dict`. Most mutable containers   are invariant.  When using the Python 3.12 syntax for generics, mypy will automatically`<span class="title-ref"> infer the most flexible variance for each class type variable. Here </span><span class="title-ref">Box</span>\` will be inferred as covariant:

`` `python    class Box[T]:  # this type is implicitly covariant        def __init__(self, content: T) -> None:            self._content = content         def get_content(self) -> T:            return self._content     def look_into(box: Box[Shape]): ...     my_box = Box(Square())    look_into(my_box)  # OK, but mypy would complain here for an invariant type  Here the underscore prefix for ``\_content`is significant. Without an`<span class="title-ref"> underscore prefix, the class would be invariant, as the attribute would be understood as a public, mutable attribute (a single underscore prefix has no special significance for mypy in most other contexts). By declaring the attribute as </span><span class="title-ref">Final</span>\`, the class could still be made covariant:

`` `python    from typing import Final     class Box[T]:  # this type is implicitly covariant        def __init__(self, content: T) -> None:            self.content: Final = content         def get_content(self) -> T:            return self.content  When using the legacy syntax, mypy assumes that all user-defined generics ``<span class="title-ref"> are invariant by default. To declare a given generic class as covariant or contravariant, use type variables defined with special keyword arguments </span><span class="title-ref">covariant</span><span class="title-ref"> or </span><span class="title-ref">contravariant</span>\`. For example (Python 3.11 or earlier):

`` `python    from typing import Generic, TypeVar     T_co = TypeVar('T_co', covariant=True)     class Box(Generic[T_co]):  # this type is declared covariant        def __init__(self, content: T_co) -> None:            self._content = content         def get_content(self) -> T_co:            return self._content     def look_into(box: Box[Shape]): ...     my_box = Box(Square())    look_into(my_box)  # OK, but mypy would complain here for an invariant type  .. _type-variable-value-restriction:  Type variables with value restriction ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

By default, a type variable can be replaced with any type -- or any type that is a subtype of the upper bound, which defaults to `object`. However, sometimes it's useful to have a type variable that can only have some specific types as its value. A typical example is a type variable that can only have values `str` and `bytes`. This lets us define a function that can concatenate two strings or bytes objects, but it can't be called with other argument types (Python 3.12 syntax):

`` `python    def concat[S: (str, bytes)](x: S, y: S) -> S:        return x + y     concat('a', 'b')    # Okay    concat(b'a', b'b')  # Okay    concat(1, 2)        # Error!   The same thing is also possibly using the legacy syntax (Python 3.11 or earlier):  .. code-block:: python     from typing import TypeVar     AnyStr = TypeVar('AnyStr', str, bytes)     def concat(x: AnyStr, y: AnyStr) -> AnyStr:        return x + y  No matter which syntax you use, such a type variable is called a type variable ``<span class="title-ref"> with a value restriction. Importantly, this is different from a union type, since combinations of </span><span class="title-ref">str</span><span class="title-ref"> and </span><span class="title-ref">bytes</span>\` are not accepted:

`` `python    concat('string', b'bytes')   # Error!  In this case, this is exactly what we want, since it's not possible ``\` to concatenate a string and a bytes object\! If we tried to use a union type, the type checker would complain about this possibility:

`` `python    def union_concat(x: str | bytes, y: str | bytes) -> str | bytes:        return x + y  # Error: can't concatenate str and bytes  Another interesting special case is calling ``concat()`with a`<span class="title-ref"> subtype of </span><span class="title-ref">str</span>\`:

`` `python     class S(str): pass      ss = concat(S('foo'), S('bar'))     reveal_type(ss)  # Revealed type is "builtins.str"  You may expect that the type of ``ss`is`S`, but the type is`<span class="title-ref"> actually </span><span class="title-ref">str</span><span class="title-ref">: a subtype gets promoted to one of the valid values for the type variable, which in this case is </span><span class="title-ref">str</span>\`.

This is thus subtly different from using `str | bytes` as an upper bound, where the return type would be `S` (see \[type-variable-upper-bound\](\#type-variable-upper-bound)). Using a value restriction is correct for `concat`, since `concat` actually returns a `str` instance in the above example:

`` `python     >>> print(type(ss))     <class 'str'>  You can also use type variables with a restricted set of possible ``<span class="title-ref"> values when defining a generic class. For example, the type :py\`Pattern\[S\] \<typing.Pattern\></span> is used for the return value of :py\`re.compile\`, where `S` can be either `str` or `bytes`. Regular expressions can be based on a string or a bytes pattern.

A type variable may not have both a value restriction and an upper bound.

Note that you may come across :py\`\~typing.AnyStr\` imported from :py`typing`. This feature is now deprecated, but it means the same as our definition of `AnyStr` above.

## Declaring decorators

Decorators are typically functions that take a function as an argument and return another function. Describing this behaviour in terms of types can be a little tricky; we'll show how you can use type variables and a special kind of type variable called a *parameter specification* to do so.

Suppose we have the following decorator, not type annotated yet, that preserves the original function's signature and merely prints the decorated function's name:

`` `python    def printing_decorator(func):        def wrapper(*args, **kwds):            print("Calling", func)            return func(*args, **kwds)        return wrapper  We can use it to decorate function ``add\_forty\_two`:  .. code-block:: python     # A decorated function.    @printing_decorator    def add_forty_two(value: int) -> int:        return value + 42     a = add_forty_two(3)  Since`printing\_decorator`is not type-annotated, the following won't get type checked:  .. code-block:: python     reveal_type(a)        # Revealed type is "Any"    add_forty_two('foo')  # No type checker error :(  This is a sorry state of affairs! If you run with`--strict`, mypy will`<span class="title-ref"> even alert you to this fact: </span><span class="title-ref">Untyped decorator makes function "add\_forty\_two" untyped</span>\`

Note that class decorators are handled differently than function decorators in mypy: decorating a class does not erase its type, even if the decorator has incomplete type annotations.

Here's how one could annotate the decorator (Python 3.12 syntax):

`` `python    from collections.abc import Callable    from typing import Any, cast     # A decorator that preserves the signature.    def printing_decorator[F: Callable[..., Any]](func: F) -> F:        def wrapper(*args, **kwds):            print("Calling", func)            return func(*args, **kwds)        return cast(F, wrapper)     @printing_decorator    def add_forty_two(value: int) -> int:        return value + 42     a = add_forty_two(3)    reveal_type(a)      # Revealed type is "builtins.int"    add_forty_two('x')  # Argument 1 to "add_forty_two" has incompatible type "str"; expected "int"  Here is the example using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python     from collections.abc import Callable    from typing import Any, TypeVar, cast     F = TypeVar('F', bound=Callable[..., Any])     # A decorator that preserves the signature.    def printing_decorator(func: F) -> F:        def wrapper(*args, **kwds):            print("Calling", func)            return func(*args, **kwds)        return cast(F, wrapper)     @printing_decorator    def add_forty_two(value: int) -> int:        return value + 42     a = add_forty_two(3)    reveal_type(a)      # Revealed type is "builtins.int"    add_forty_two('x')  # Argument 1 to "add_forty_two" has incompatible type "str"; expected "int"  This still has some shortcomings. First, we need to use the unsafe ``<span class="title-ref"> :py</span>\~typing.cast\` to convince mypy that `wrapper()` has the same signature as `func` (see \[casts \<casts\>\](\#casts-\<casts\>)).

Second, the `wrapper()` function is not tightly type checked, although wrapper functions are typically small enough that this is not a big problem. This is also the reason for the :py\`\~typing.cast\` call in the `return` statement in `printing_decorator()`.

However, we can use a parameter specification, introduced using `**P`, for a more faithful type annotation (Python 3.12 syntax):

`` `python    from collections.abc import Callable     def printing_decorator[**P, T](func: Callable[P, T]) -> Callable[P, T]:        def wrapper(*args: P.args, **kwds: P.kwargs) -> T:            print("Calling", func)            return func(*args, **kwds)        return wrapper  The same is possible using the legacy syntax with :py`~typing.ParamSpec` ``\` (Python 3.11 and earlier):

`` `python    from collections.abc import Callable    from typing import TypeVar    from typing_extensions import ParamSpec     P = ParamSpec('P')    T = TypeVar('T')     def printing_decorator(func: Callable[P, T]) -> Callable[P, T]:        def wrapper(*args: P.args, **kwds: P.kwargs) -> T:            print("Calling", func)            return func(*args, **kwds)        return wrapper  Parameter specifications also allow you to describe decorators that ``\` alter the signature of the input function (Python 3.12 syntax):

`` `python    from collections.abc import Callable     # We reuse 'P' in the return type, but replace 'T' with 'str'    def stringify[**P, T](func: Callable[P, T]) -> Callable[P, str]:        def wrapper(*args: P.args, **kwds: P.kwargs) -> str:            return str(func(*args, **kwds))        return wrapper      @stringify     def add_forty_two(value: int) -> int:         return value + 42      a = add_forty_two(3)     reveal_type(a)      # Revealed type is "builtins.str"     add_forty_two('x')  # error: Argument 1 to "add_forty_two" has incompatible type "str"; expected "int"  Here is the above example using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python     from collections.abc import Callable    from typing import TypeVar    from typing_extensions import ParamSpec     P = ParamSpec('P')    T = TypeVar('T')     # We reuse 'P' in the return type, but replace 'T' with 'str'    def stringify(func: Callable[P, T]) -> Callable[P, str]:        def wrapper(*args: P.args, **kwds: P.kwargs) -> str:            return str(func(*args, **kwds))        return wrapper  You can also insert an argument in a decorator (Python 3.12 syntax):  .. code-block:: python      from collections.abc import Callable     from typing import Concatenate      def printing_decorator[**P, T](func: Callable[P, T]) -> Callable[Concatenate[str, P], T]:         def wrapper(msg: str, /, *args: P.args, **kwds: P.kwargs) -> T:             print("Calling", func, "with", msg)             return func(*args, **kwds)         return wrapper      @printing_decorator     def add_forty_two(value: int) -> int:         return value + 42      a = add_forty_two('three', 3)  Here is the same function using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python      from collections.abc import Callable     from typing import TypeVar     from typing_extensions import Concatenate, ParamSpec      P = ParamSpec('P')     T = TypeVar('T')      def printing_decorator(func: Callable[P, T]) -> Callable[Concatenate[str, P], T]:         def wrapper(msg: str, /, *args: P.args, **kwds: P.kwargs) -> T:             print("Calling", func, "with", msg)             return func(*args, **kwds)         return wrapper  .. _decorator-factories:  Decorator factories ``\` -------------------

Functions that take arguments and return a decorator (also called second-order decorators), are similarly supported via generics (Python 3.12 syntax):

`` `python     from colletions.abc import Callable     from typing import Any      def route[F: Callable[..., Any]](url: str) -> Callable[[F], F]:         ...      @route(url='/')     def index(request: Any) -> str:         return 'Hello world'  Note that mypy infers that ``F`is used to make the`Callable`return value`<span class="title-ref"> of </span><span class="title-ref">route</span><span class="title-ref"> generic, instead of making </span><span class="title-ref">route</span><span class="title-ref"> itself generic, since </span><span class="title-ref">F</span><span class="title-ref"> is only used in the return type. Python has no explicit syntax to mark that </span><span class="title-ref">F</span>\` is only bound in the return value.

Here is the example using the legacy syntax (Python 3.11 and earlier):

`` `python     from collections.abc import Callable     from typing import Any, TypeVar      F = TypeVar('F', bound=Callable[..., Any])      def route(url: str) -> Callable[[F], F]:         ...      @route(url='/')     def index(request: Any) -> str:         return 'Hello world'  Sometimes the same decorator supports both bare calls and calls with arguments. This can be ``<span class="title-ref"> achieved by combining with :py</span>@overload \<typing.overload\>\` (Python 3.12 syntax):

`` `python     from collections.abc import Callable     from typing import Any, overload      # Bare decorator usage     @overload     def atomic[F: Callable[..., Any]](func: F, /) -> F: ...     # Decorator with arguments     @overload     def atomic[F: Callable[..., Any]](*, savepoint: bool = True) -> Callable[[F], F]: ...      # Implementation     def atomic(func: Callable[..., Any] | None = None, /, *, savepoint: bool = True):         def decorator(func: Callable[..., Any]):             ...  # Code goes here         if __func is not None:             return decorator(__func)         else:             return decorator      # Usage     @atomic     def func1() -> None: ...      @atomic(savepoint=False)     def func2() -> None: ...  Here is the decorator from the example using the legacy syntax ``\` (Python 3.11 and earlier):

`` `python     from collections.abc import Callable     from typing import Any, Optional, TypeVar, overload      F = TypeVar('F', bound=Callable[..., Any])      # Bare decorator usage     @overload     def atomic(func: F, /) -> F: ...     # Decorator with arguments     @overload     def atomic(*, savepoint: bool = True) -> Callable[[F], F]: ...      # Implementation     def atomic(func: Optional[Callable[..., Any]] = None, /, *, savepoint: bool = True):         ...  # Same as above  Generic protocols ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Mypy supports generic protocols (see also \[protocol-types\](\#protocol-types)). Several \[predefined protocols \<predefined\_protocols\>\](\#predefined-protocols-\<predefined\_protocols\>) are generic, such as :py\`Iterable\[T\] \<collections.abc.Iterable\>\`, and you can define additional generic protocols. Generic protocols mostly follow the normal rules for generic classes. Example (Python 3.12 syntax):

`` `python    from typing import Protocol     class Box[T](Protocol):        content: T     def do_stuff(one: Box[str], other: Box[bytes]) -> None:        ...     class StringWrapper:        def __init__(self, content: str) -> None:            self.content = content     class BytesWrapper:        def __init__(self, content: bytes) -> None:            self.content = content     do_stuff(StringWrapper('one'), BytesWrapper(b'other'))  # OK     x: Box[float] = ...    y: Box[int] = ...    x = y  # Error -- Box is invariant  Here is the definition of ``Box`from the above example using the legacy`\` syntax (Python 3.11 and earlier):

`` `python    from typing import Protocol, TypeVar     T = TypeVar('T')     class Box(Protocol[T]):        content: T  Note that ``class ClassName(Protocol\[T\])`is allowed as a shorthand for`<span class="title-ref"> </span><span class="title-ref">class ClassName(Protocol, Generic\[T\])</span><span class="title-ref"> when using the legacy syntax, as per :pep:\`PEP 544: Generic protocols \<544\#generic-protocols\></span>. This form is only valid when using the legacy syntax.

When using the legacy syntax, there is an important difference between generic protocols and ordinary generic classes: mypy checks that the declared variances of generic type variables in a protocol match how they are used in the protocol definition. The protocol in this example is rejected, since the type variable `T` is used covariantly as a return type, but the type variable is invariant:

`` `python    from typing import Protocol, TypeVar     T = TypeVar('T')     class ReadOnlyBox(Protocol[T]):  # error: Invariant type variable "T" used in protocol where covariant one is expected        def content(self) -> T: ...  This example correctly uses a covariant type variable:  .. code-block:: python     from typing import Protocol, TypeVar     T_co = TypeVar('T_co', covariant=True)     class ReadOnlyBox(Protocol[T_co]):  # OK        def content(self) -> T_co: ...     ax: ReadOnlyBox[float] = ...    ay: ReadOnlyBox[int] = ...    ax = ay  # OK -- ReadOnlyBox is covariant  See [variance-of-generics](#variance-of-generics) for more about variance.  Generic protocols can also be recursive. Example (Python 3.12 synta):  .. code-block:: python     class Linked[T](Protocol):        val: T        def next(self) -> 'Linked[T]': ...     class L:        val: int        def next(self) -> 'L': ...     def last(seq: Linked[T]) -> T: ...     result = last(L())    reveal_type(result)  # Revealed type is "builtins.int"  Here is the definition of ``Linked`using the legacy syntax`\` (Python 3.11 and earlier):

`` `python    from typing import TypeVar     T = TypeVar('T')     class Linked(Protocol[T]):        val: T        def next(self) -> 'Linked[T]': ...  .. _generic-type-aliases:  Generic type aliases ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Type aliases can be generic. In this case they can be used in two ways. First, subscripted aliases are equivalent to original types with substituted type variables. Second, unsubscripted aliases are treated as original types with type parameters replaced with `Any`.

The `type` statement introduced in Python 3.12 is used to define generic type aliases (it also supports non-generic type aliases):

`` `python     from collections.abc import Callable, Iterable      type TInt[S] = tuple[int, S]     type UInt[S] = S | int     type CBack[S] = Callable[..., S]      def response(query: str) -> UInt[str]:  # Same as str | int         ...     def activate[S](cb: CBack[S]) -> S:        # Same as Callable[..., S]         ...     table_entry: TInt  # Same as tuple[int, Any]      type Vec[T: (int, float, complex)] = Iterable[tuple[T, T]]      def inproduct[T: (int, float, complex)](v: Vec[T]) -> T:         return sum(x*y for x, y in v)      def dilate[T: (int, float, complex)](v: Vec[T], scale: T) -> Vec[T]:         return ((x * scale, y * scale) for x, y in v)      v1: Vec[int] = []      # Same as Iterable[tuple[int, int]]     v2: Vec = []           # Same as Iterable[tuple[Any, Any]]     v3: Vec[int, int] = [] # Error: Invalid alias, too many type arguments!  There is also a legacy syntax that relies on ``TypeVar`.`<span class="title-ref"> Here the number of type arguments must match the number of free type variables in the generic type alias definition. A type variables is free if it's not a type parameter of a surrounding class or function. Example (following :pep:\`PEP 484: Type aliases \<484\#type-aliases\></span>, Python 3.11 and earlier):

`` `python     from typing import TypeVar, Iterable, Union, Callable      S = TypeVar('S')      TInt = tuple[int, S]  # 1 type parameter, since only S is free     UInt = Union[S, int]     CBack = Callable[..., S]      def response(query: str) -> UInt[str]:  # Same as Union[str, int]         ...     def activate(cb: CBack[S]) -> S:        # Same as Callable[..., S]         ...     table_entry: TInt  # Same as tuple[int, Any]      T = TypeVar('T', int, float, complex)      Vec = Iterable[tuple[T, T]]      def inproduct(v: Vec[T]) -> T:         return sum(x*y for x, y in v)      def dilate(v: Vec[T], scale: T) -> Vec[T]:         return ((x * scale, y * scale) for x, y in v)      v1: Vec[int] = []      # Same as Iterable[tuple[int, int]]     v2: Vec = []           # Same as Iterable[tuple[Any, Any]]     v3: Vec[int, int] = [] # Error: Invalid alias, too many type arguments!  Type aliases can be imported from modules just like other names. An ``\` alias can also target another alias, although building complex chains of aliases is not recommended -- this impedes code readability, thus defeating the purpose of using aliases. Example (Python 3.12 syntax):

`` `python     from example1 import AliasType     from example2 import Vec      # AliasType and Vec are type aliases (Vec as defined above)      def fun() -> AliasType:         ...      type OIntVec = Vec[int] | None  Type aliases defined using the ``type`statement are not valid as`\` base classes, and they can't be used to construct instances:

`` `python     from example1 import AliasType     from example2 import Vec      # AliasType and Vec are type aliases (Vec as defined above)      class NewVec[T](Vec[T]):  # Error: not valid as base class         ...      x = AliasType()  # Error: can't be used to create instances  Here are examples using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python      from typing import TypeVar, Generic, Optional     from example1 import AliasType     from example2 import Vec      # AliasType and Vec are type aliases (Vec as defined above)      def fun() -> AliasType:         ...      OIntVec = Optional[Vec[int]]      T = TypeVar('T')      # Old-style type aliases can be used as base classes and you can     # construct instances using them      class NewVec(Vec[T]):         ...      x = AliasType()      for i, j in NewVec[int]():         ...  Using type variable bounds or value restriction in generic aliases has ``\` the same effect as in generic classes and functions.

## Differences between the new and old syntax

There are a few notable differences between the new (Python 3.12 and later) and the old syntax for generic classes, functions and type aliases, beyond the obvious syntactic differences:

>   - Type variables defined using the old syntax create definitions at runtime in the surrounding namespace, whereas the type variables defined using the new syntax are only defined within the class, function or type variable that uses them.
>   - Type variable definitions can be shared when using the old syntax, but the new syntax doesn't support this.
>   - When using the new syntax, the variance of class type variables is always inferred.
>   - Type aliases defined using the new syntax can contain forward references and recursive references without using string literal escaping. The same is true for the bounds and constraints of type variables.
>   - The new syntax lets you define a generic alias where the definition doesn't contain a reference to a type parameter. This is occasionally useful, at least when conditionally defining type aliases.
>   - Type aliases defined using the new syntax can't be used as base classes and can't be used to construct instances, unlike aliases defined using the old syntax.

## Generic class internals

You may wonder what happens at runtime when you index a generic class. Indexing returns a *generic alias* to the original class that returns instances of the original class on instantiation (Python 3.12 syntax):

`` `python    >>> class Stack[T]: ...    >>> Stack    __main__.Stack    >>> Stack[int]    __main__.Stack[int]    >>> instance = Stack[int]()    >>> instance.__class__    __main__.Stack  Here is the same example using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python     >>> from typing import TypeVar, Generic    >>> T = TypeVar('T')    >>> class Stack(Generic[T]): ...    >>> Stack    __main__.Stack    >>> Stack[int]    __main__.Stack[int]    >>> instance = Stack[int]()    >>> instance.__class__    __main__.Stack  Generic aliases can be instantiated or subclassed, similar to real ``<span class="title-ref"> classes, but the above examples illustrate that type variables are erased at runtime. Generic </span><span class="title-ref">Stack</span><span class="title-ref"> instances are just ordinary Python objects, and they have no extra runtime overhead or magic due to being generic, other than the </span><span class="title-ref">Generic</span><span class="title-ref"> base class that overloads the indexing operator using </span><span class="title-ref">\_\_class\_getitem\_\_</span><span class="title-ref">. </span><span class="title-ref">typing.Generic</span>\` is included as an implicit base class even when using the new syntax:

`` `python    >>> class Stack[T]: ...    >>> Stack.mro()    [<class '__main__.Stack'>, <class 'typing.Generic'>, <class 'object'>]  Note that in Python 3.8 and earlier, the built-in types ``<span class="title-ref"> :py\`list</span>, :py\`dict\` and others do not support indexing. This is why we have the aliases :py\`\~typing.List\`, :py\`\~typing.Dict\` and so on in the :py`typing` module. Indexing these aliases gives you a generic alias that resembles generic aliases constructed by directly indexing the target class in more recent versions of Python:

`` `python    >>> # Only relevant for Python 3.8 and below    >>> # If using Python 3.9 or newer, prefer the 'list[int]' syntax    >>> from typing import List    >>> List[int]    typing.List[int]  Note that the generic aliases in ``typing`don't support constructing`\` instances, unlike the corresponding built-in classes:

`` `python >>> list[int]() [] >>> from typing import List >>> List[int]() Traceback (most recent call last): ... TypeError: Type List cannot be instantiated; use list() instead ``\`

---

getting_started.md

---

# Getting started

This chapter introduces some core concepts of mypy, including function annotations, the :py`typing` module, stub files, and more.

If you're looking for a quick intro, see the \[mypy cheatsheet \<cheat-sheet-py3\>\](\#mypy-cheatsheet-\<cheat-sheet-py3\>).

If you're unfamiliar with the concepts of static and dynamic type checking, be sure to read this chapter carefully, as the rest of the documentation may not make much sense otherwise.

## Installing and running mypy

Mypy requires Python 3.8 or later to run. You can install mypy using pip:

`` `shell     $ python3 -m pip install mypy  Once mypy is installed, run it by using the ``mypy`tool:  .. code-block:: shell      $ mypy program.py  This command makes mypy *type check* your`program.py`file and print`\` out any errors it finds. Mypy will type check your code *statically*: this means that it will check for errors without ever running your code, just like a linter.

This also means that you are always free to ignore the errors mypy reports, if you so wish. You can always use the Python interpreter to run your code, even if mypy reports errors.

However, if you try directly running mypy on your existing Python code, it will most likely report little to no errors. This is a feature\! It makes it easy to adopt mypy incrementally.

In order to get useful diagnostics from mypy, you must add *type annotations* to your code. See the section below for details.

## Dynamic vs static typing

A function without type annotations is considered to be *dynamically typed* by mypy:

`` `python    def greeting(name):        return 'Hello ' + name  By default, mypy will **not** type check dynamically typed functions. This means ``\` that with a few exceptions, mypy will not report any errors with regular unannotated Python.

This is the case even if you misuse the function\!

`` `python    def greeting(name):        return 'Hello ' + name     # These calls will fail when the program runs, but mypy does not report an error    # because "greeting" does not have type annotations.    greeting(123)    greeting(b"Alice")  We can get mypy to detect these kinds of bugs by adding *type annotations* (also ``<span class="title-ref"> known as \*type hints\*). For example, you can tell mypy that </span><span class="title-ref">greeting</span>\` both accepts and returns a string like so:

`` `python    # The "name: str" annotation says that the "name" argument should be a string    # The "-> str" annotation says that "greeting" will return a string    def greeting(name: str) -> str:        return 'Hello ' + name  This function is now *statically typed*: mypy will use the provided type hints ``<span class="title-ref"> to detect incorrect use of the </span><span class="title-ref">greeting</span><span class="title-ref"> function and incorrect use of variables within the </span><span class="title-ref">greeting</span>\` function. For example:

`` `python    def greeting(name: str) -> str:        return 'Hello ' + name     greeting(3)         # Argument 1 to "greeting" has incompatible type "int"; expected "str"    greeting(b'Alice')  # Argument 1 to "greeting" has incompatible type "bytes"; expected "str"    greeting("World!")  # No error     def bad_greeting(name: str) -> str:        return 'Hello ' * name  # Unsupported operand types for * ("str" and "str")  Being able to pick whether you want a function to be dynamically or statically ``\` typed can be very helpful. For example, if you are migrating an existing Python codebase to use static types, it's usually easier to migrate by incrementally adding type hints to your code rather than adding them all at once. Similarly, when you are prototyping a new feature, it may be convenient to initially implement the code using dynamic typing and only add type hints later once the code is more stable.

Once you are finished migrating or prototyping your code, you can make mypy warn you if you add a dynamic function by mistake by using the `--disallow-untyped-defs <mypy --disallow-untyped-defs>` flag. You can also get mypy to provide some limited checking of dynamically typed functions by using the `--check-untyped-defs <mypy --check-untyped-defs>` flag. See \[command-line\](\#command-line) for more information on configuring mypy.

## Strict mode and configuration

Mypy has a *strict mode* that enables a number of additional checks, like `--disallow-untyped-defs <mypy --disallow-untyped-defs>`.

If you run mypy with the `--strict <mypy --strict>` flag, you will basically never get a type related error at runtime without a corresponding mypy error, unless you explicitly circumvent mypy somehow.

However, this flag will probably be too aggressive if you are trying to add static types to a large, existing codebase. See \[existing-code\](\#existing-code) for suggestions on how to handle that case.

Mypy is very configurable, so you can start with using `--strict` and toggle off individual checks. For instance, if you use many third party libraries that do not have types, `--ignore-missing-imports <mypy --ignore-missing-imports>` may be useful. See \[getting-to-strict\](\#getting-to-strict) for how to build up to `--strict`.

See \[command-line\](\#command-line) and \[config-file\](\#config-file) for a complete reference on configuration options.

## More complex types

So far, we've added type hints that use only basic concrete types like `str` and `float`. What if we want to express more complex types, such as "a list of strings" or "an iterable of ints"?

For example, to indicate that some function can accept a list of strings, use the `list[str]` type (Python 3.9 and later):

`` `python    def greet_all(names: list[str]) -> None:        for name in names:            print('Hello ' + name)     names = ["Alice", "Bob", "Charlie"]    ages = [10, 20, 30]     greet_all(names)   # Ok!    greet_all(ages)    # Error due to incompatible types  The :py`list` type is an example of something called a *generic type*: it can ``<span class="title-ref"> accept one or more \*type parameters\*. In this case, we \*parameterized\* :py\`list</span> by writing `list[str]`. This lets mypy know that `greet_all` accepts specifically lists containing strings, and not lists containing ints or any other type.

In the above examples, the type signature is perhaps a little too rigid. After all, there's no reason why this function must accept *specifically* a list --it would run just fine if you were to pass in a tuple, a set, or any other custom iterable.

You can express this idea using :py\`collections.abc.Iterable\`:

`` `python    from collections.abc import Iterable  # or "from typing import Iterable"     def greet_all(names: Iterable[str]) -> None:        for name in names:            print('Hello ' + name)  This behavior is actually a fundamental aspect of the PEP 484 type system: when ``<span class="title-ref"> we annotate some variable with a type </span><span class="title-ref">T</span><span class="title-ref">, we are actually telling mypy that variable can be assigned an instance of </span><span class="title-ref">T</span><span class="title-ref">, or an instance of a \*subtype\* of </span><span class="title-ref">T</span><span class="title-ref">. That is, </span><span class="title-ref">list\[str\]</span><span class="title-ref"> is a subtype of </span><span class="title-ref">Iterable\[str\]</span>\`.

This also applies to inheritance, so if you have a class `Child` that inherits from `Parent`, then a value of type `Child` can be assigned to a variable of type `Parent`. For example, a `RuntimeError` instance can be passed to a function that is annotated as taking an `Exception`.

As another example, suppose you want to write a function that can accept *either* ints or strings, but no other types. You can express this using a union type. For example, `int` is a subtype of `int | str`:

`` `python    def normalize_id(user_id: int | str) -> str:        if isinstance(user_id, int):            return f'user-{100_000 + user_id}'        else:            return user_id  > **Note** >      If using Python 3.9 or earlier, use ``typing.Union\[int, str\]`instead of`int | str`, or use`from \_\_future\_\_ import annotations``at the top of     the file (see [runtime_troubles](#runtime_troubles)).  The :py:mod:`typing` module contains many other useful types.  For a quick overview, look through the [mypy cheatsheet <cheat-sheet-py3>](#mypy-cheatsheet-<cheat-sheet-py3>).  For a detailed overview (including information on how to make your own``\` generic types or your own type aliases), look through the \[type system reference \<overview-type-system-reference\>\](\#type-system-reference-\<overview-type-system-reference\>).

\> **Note** \> When adding types, the convention is to import types using the form `from typing import <name>` (as opposed to doing just `import typing` or `import typing as t` or `from typing import *`).

> For brevity, we often omit imports from :py`typing` or :py`collections.abc` in code examples, but mypy will give an error if you use types such as :py\`\~collections.abc.Iterable\` without first importing them.

<div class="note">

<div class="title">

Note

</div>

In some examples we use capitalized variants of types, such as `List`, and sometimes we use plain `list`. They are equivalent, but the prior variant is needed if you are using Python 3.8 or earlier.

</div>

## Local type inference

Once you have added type hints to a function (i.e. made it statically typed), mypy will automatically type check that function's body. While doing so, mypy will try and *infer* as many details as possible.

We saw an example of this in the `normalize_id` function above -- mypy understands basic :py\`isinstance \<isinstance\><span class="title-ref"> checks and so can infer that the </span><span class="title-ref">user\_id</span><span class="title-ref"> variable was of type </span><span class="title-ref">int</span><span class="title-ref"> in the if-branch and of type </span><span class="title-ref">str</span>\` in the else-branch.

As another example, consider the following function. Mypy can type check this function without a problem: it will use the available context and deduce that `output` must be of type `list[float]` and that `num` must be of type `float`:

`` `python    def nums_below(numbers: Iterable[float], limit: float) -> list[float]:        output = []        for num in numbers:            if num < limit:                output.append(num)        return output  For more details, see [type-inference-and-annotations](#type-inference-and-annotations).  Types from libraries ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Mypy can also understand how to work with types from libraries that you use.

For instance, mypy comes out of the box with an intimate knowledge of the Python standard library. For example, here is a function which uses the `Path` object from the \[pathlib standard library module \<python:library/pathlib\>\](pathlib standard library module \<python:library/pathlib\>.md):

`` `python     from pathlib import Path      def load_template(template_path: Path, name: str) -> str:         # Mypy knows that `template_path` has a `read_text` method that returns a str         template = template_path.read_text()         # ...so it understands this line type checks         return template.replace('USERNAME', name)  If a third party library you use [declares support for type checking <installed-packages>](#declares-support-for-type-checking-<installed-packages>), ``\` mypy will type check your use of that library based on the type hints it contains.

However, if the third party library does not have type hints, mypy will complain about missing type information.

`` `text   prog.py:1: error: Library stubs not installed for "yaml"   prog.py:1: note: Hint: "python3 -m pip install types-PyYAML"   prog.py:2: error: Library stubs not installed for "requests"   prog.py:2: note: Hint: "python3 -m pip install types-requests"   ...  In this case, you can provide mypy a different source of type information, ``\` by installing a *stub* package. A stub package is a package that contains type hints for another library, but no actual code.

`` `shell   $ python3 -m pip install types-PyYAML types-requests  Stubs packages for a distribution are often named ``types-\<distribution\>`.`<span class="title-ref"> Note that a distribution name may be different from the name of the package that you import. For example, </span><span class="title-ref">types-PyYAML</span><span class="title-ref"> contains stubs for the </span><span class="title-ref">yaml</span>\` package.

For more discussion on strategies for handling errors about libraries without type information, refer to \[fix-missing-imports\](\#fix-missing-imports).

For more information about stubs, see \[stub-files\](\#stub-files).

## Next steps

If you are in a hurry and don't want to read lots of documentation before getting started, here are some pointers to quick learning resources:

  - Read the \[mypy cheatsheet \<cheat-sheet-py3\>\](\#mypy-cheatsheet-\<cheat-sheet-py3\>).
  - Read \[existing-code\](\#existing-code) if you have a significant existing codebase without many type annotations.
  - Read the [blog post](https://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/) about the Zulip project's experiences with adopting mypy.
  - If you prefer watching talks instead of reading, here are some ideas:
      - Carl Meyer: [Type Checked Python in the Real World](https://www.youtube.com/watch?v=pMgmKJyWKn8) (PyCon 2018)
      - Greg Price: [Clearer Code at Scale: Static Types at Zulip and Dropbox](https://www.youtube.com/watch?v=0c46YHS3RY8) (PyCon 2018)
  - Look at \[solutions to common issues \<common\_issues\>\](\#solutions-to-common-issues-\<common\_issues\>) with mypy if you encounter problems.
  - You can ask questions about mypy in the [mypy issue tracker](https://github.com/python/mypy/issues) and typing [Gitter chat](https://gitter.im/python/typing).
  - For general questions about Python typing, try posting at [typing discussions](https://github.com/python/typing/discussions).

You can also continue reading this document and skip sections that aren't relevant for you. You don't need to read sections in order.

---

index.md

---

# Welcome to mypy documentation\!

Mypy is a static type checker for Python.

Type checkers help ensure that you're using variables and functions in your code correctly. With mypy, add type hints (`484`) to your Python programs, and mypy will warn you when you use those types incorrectly.

Python is a dynamic language, so usually you'll only see errors in your code when you attempt to run it. Mypy is a *static* checker, so it finds bugs in your programs without even running them\!

Here is a small example to whet your appetite:

`` `python    number = input("What is your favourite number?")    print("It is", number + 1)  # error: Unsupported operand types for + ("str" and "int")  Adding type hints for mypy does not interfere with the way your program would ``\` otherwise run. Think of type hints as similar to comments\! You can always use the Python interpreter to run your code, even if mypy reports errors.

Mypy is designed with gradual typing in mind. This means you can add type hints to your code base slowly and that you can always fall back to dynamic typing when static typing is not convenient.

Mypy has a powerful and easy-to-use type system, supporting features such as type inference, generics, callable types, tuple types, union types, structural subtyping and more. Using mypy will make your programs easier to understand, debug, and maintain.

\> **Note** \> Although mypy is production ready, there may be occasional changes that break backward compatibility. The mypy development team tries to minimize the impact of changes to user code. In case of a major breaking change, mypy's major version will be bumped.

## Contents

<div class="toctree" data-maxdepth="2" data-caption="First steps">

getting\_started cheat\_sheet\_py3 existing\_code

</div>

<div id="overview-type-system-reference">

<div class="toctree" data-maxdepth="2" data-caption="Type system reference">

builtin\_types type\_inference\_and\_annotations kinds\_of\_types class\_basics runtime\_troubles protocols dynamic\_typing type\_narrowing duck\_type\_compatibility stubs generics more\_types literal\_types typed\_dict final\_attrs metaclasses

</div>

</div>

<div class="toctree" data-maxdepth="2" data-caption="Configuring and running mypy">

running\_mypy command\_line config\_file inline\_config mypy\_daemon installed\_packages extending\_mypy stubgen stubtest

</div>

<div class="toctree" data-maxdepth="2" data-caption="Miscellaneous">

common\_issues supported\_python\_features error\_codes error\_code\_list error\_code\_list2 additional\_features faq changelog

</div>

<div class="toctree" hidden="" data-caption="Project Links">

GitHub \<<https://github.com/python/mypy>\> Website \<<https://mypy-lang.org/>\>

</div>

# Indices and tables

  - \[genindex\](\#genindex)
  - \[search\](\#search)

---

inline_config.md

---

# Inline configuration

Mypy supports setting per-file configuration options inside files themselves using `# mypy:` comments. For example:

`` `python   # mypy: disallow-any-generics  Inline configuration comments take precedence over all other ``\` configuration mechanisms.

## Configuration comment format

Flags correspond to \[config file flags \<config-file\>\](\#config-file-flags-\<config-file\>) but allow hyphens to be substituted for underscores.

Values are specified using `=`, but `= True` may be omitted:

`` `python   # mypy: disallow-any-generics   # mypy: always-true=FOO  Multiple flags can be separated by commas or placed on separate ``\` lines. To include a comma as part of an option's value, place the value inside quotes:

`` `python   # mypy: disallow-untyped-defs, always-false="FOO,BAR"  Like in the configuration file, options that take a boolean value may be ``<span class="title-ref"> inverted by adding </span><span class="title-ref">no-</span><span class="title-ref"> to their name or by (when applicable) swapping their prefix from </span><span class="title-ref">disallow</span><span class="title-ref"> to </span><span class="title-ref">allow</span>\` (and vice versa):

`` `python # mypy: allow-untyped-defs, no-strict-optional ``\`

---

installed_packages.md

---

# Using installed packages

Packages installed with pip can declare that they support type checking. For example, the [aiohttp](https://docs.aiohttp.org/en/stable/) package has built-in support for type checking.

Packages can also provide stubs for a library. For example, `types-requests` is a stub-only package that provides stubs for the [requests](https://requests.readthedocs.io/en/master/) package. Stub packages are usually published from [typeshed](https://github.com/python/typeshed), a shared repository for Python library stubs, and have a name of form `types-<library>`. Note that many stub packages are not maintained by the original maintainers of the package.

The sections below explain how mypy can use these packages, and how you can create such packages.

\> **Note** \> `561` specifies how a package can declare that it supports type checking.

<div class="note">

<div class="title">

Note

</div>

New versions of stub packages often use type system features not supported by older, and even fairly recent mypy versions. If you pin to an older version of mypy (using `requirements.txt`, for example), it is recommended that you also pin the versions of all your stub package dependencies.

</div>

<div class="note">

<div class="title">

Note

</div>

Starting in mypy 0.900, most third-party package stubs must be installed explicitly. This decouples mypy and stub versioning, allowing stubs to updated without updating mypy. This also allows stubs not originally included with mypy to be installed. Earlier mypy versions included a fixed set of stubs for third-party packages.

</div>

## Using installed packages with mypy (PEP 561)

Typically mypy will automatically find and use installed packages that support type checking or provide stubs. This requires that you install the packages in the Python environment that you use to run mypy. As many packages don't support type checking yet, you may also have to install a separate stub package, usually named `types-<library>`. (See \[fix-missing-imports\](\#fix-missing-imports) for how to deal with libraries that don't support type checking and are also missing stubs.)

If you have installed typed packages in another Python installation or environment, mypy won't automatically find them. One option is to install another copy of those packages in the environment in which you installed mypy. Alternatively, you can use the `--python-executable <mypy --python-executable>` flag to point to the Python executable for another environment, and mypy will find packages installed for that Python executable.

Note that mypy does not support some more advanced import features, such as zip imports and custom import hooks.

If you don't want to use installed packages that provide type information at all, use the `--no-site-packages <mypy
--no-site-packages>` flag to disable searching for installed packages.

Note that stub-only packages cannot be used with `MYPYPATH`. If you want mypy to find the package, it must be installed. For a package `foo`, the name of the stub-only package (`foo-stubs`) is not a legal package name, so mypy will not find it, unless it is installed (see `PEP 561: Stub-only Packages <561#stub-only-packages>` for more information).

## Creating PEP 561 compatible packages

\> **Note** \> You can generally ignore this section unless you maintain a package on PyPI, or want to publish type information for an existing PyPI package.

`561` describes three main ways to distribute type information:

1.  A package has inline type annotations in the Python implementation.
2.  A package ships \[stub files \<stub-files\>\](\#stub-files-\<stub-files\>) with type information alongside the Python implementation.
3.  A package ships type information for another package separately as stub files (also known as a "stub-only package").

If you want to create a stub-only package for an existing library, the simplest way is to contribute stubs to the [typeshed](https://github.com/python/typeshed) repository, and a stub package will automatically be uploaded to PyPI.

If you would like to publish a library package to a package repository yourself (e.g. on PyPI) for either internal or external use in type checking, packages that supply type information via type comments or annotations in the code should put a `py.typed` file in their package directory. For example, here is a typical directory structure:

`` `text     setup.py     package_a/         __init__.py         lib.py         py.typed  The ``setup.py`file could look like this:  .. code-block:: python      from setuptools import setup      setup(         name="SuperPackageA",         author="Me",         version="0.1",         package_data={"package_a": ["py.typed"]},         packages=["package_a"]     )  Some packages have a mix of stub files and runtime files. These packages also`<span class="title-ref"> require a </span><span class="title-ref">py.typed</span>\` file. An example can be seen below:

`` `text     setup.py     package_b/         __init__.py         lib.py         lib.pyi         py.typed  The ``setup.py`file might look like this:  .. code-block:: python      from setuptools import setup      setup(         name="SuperPackageB",         author="Me",         version="0.1",         package_data={"package_b": ["py.typed", "lib.pyi"]},         packages=["package_b"]     )  In this example, both`lib.py`and the`lib.pyi`stub file exist. At`<span class="title-ref"> runtime, the Python interpreter will use </span><span class="title-ref">lib.py</span><span class="title-ref">, but mypy will use </span><span class="title-ref">lib.pyi</span>\` instead.

If the package is stub-only (not imported at runtime), the package should have a prefix of the runtime package name and a suffix of `-stubs`. A `py.typed` file is not needed for stub-only packages. For example, if we had stubs for `package_c`, we might do the following:

`` `text     setup.py     package_c-stubs/         __init__.pyi         lib.pyi  The ``setup.py`might look like this:  .. code-block:: python      from setuptools import setup      setup(         name="SuperPackageC",         author="Me",         version="0.1",         package_data={"package_c-stubs": ["__init__.pyi", "lib.pyi"]},         packages=["package_c-stubs"]     )  The instructions above are enough to ensure that the built wheels`<span class="title-ref"> contain the appropriate files. However, to ensure inclusion inside the </span><span class="title-ref">sdist</span><span class="title-ref"> (</span><span class="title-ref">.tar.gz</span><span class="title-ref"> archive), you may also need to modify the inclusion rules in your </span><span class="title-ref">MANIFEST.in</span>\`:

`` `text global-include *.pyi global-include *.typed ``\`

---

kinds_of_types.md

---

# Kinds of types

We've mostly restricted ourselves to built-in types until now. This section introduces several additional kinds of types. You are likely to need at least some of them to type check any non-trivial programs.

## Class types

Every class is also a valid type. Any instance of a subclass is also compatible with all superclasses -- it follows that every value is compatible with the :py\`object\` type (and incidentally also the `Any` type, discussed below). Mypy analyzes the bodies of classes to determine which methods and attributes are available in instances. This example uses subclassing:

`` `python    class A:        def f(self) -> int:  # Type of self inferred (A)            return 2     class B(A):        def f(self) -> int:             return 3        def g(self) -> int:            return 4     def foo(a: A) -> None:        print(a.f())  # 3        a.g()         # Error: "A" has no attribute "g"     foo(B())  # OK (B is a subclass of A)  The Any type ``\` \*\*\*\*\*\*\*\*\*\*\*\*

A value with the `Any` type is dynamically typed. Mypy doesn't know anything about the possible runtime types of such value. Any operations are permitted on the value, and the operations are only checked at runtime. You can use `Any` as an "escape hatch" when you can't use a more precise type for some reason.

`Any` is compatible with every other type, and vice versa. You can freely assign a value of type `Any` to a variable with a more precise type:

`` `python    a: Any = None    s: str = ''    a = 2     # OK (assign "int" to "Any")    s = a     # OK (assign "Any" to "str")  Declared (and inferred) types are ignored (or *erased*) at runtime. They are ``<span class="title-ref"> basically treated as comments, and thus the above code does not generate a runtime error, even though </span><span class="title-ref">s</span><span class="title-ref"> gets an </span><span class="title-ref">int</span><span class="title-ref"> value when the program is run, while the declared type of </span><span class="title-ref">s</span><span class="title-ref"> is actually </span><span class="title-ref">str</span><span class="title-ref">\! You need to be careful with </span><span class="title-ref">Any</span>\` types, since they let you lie to mypy, and this could easily hide bugs.

If you do not define a function return value or argument types, these default to `Any`:

`` `python    def show_heading(s) -> None:        print('=== ' + s + ' ===')  # No static type checking, as s has type Any     show_heading(1)  # OK (runtime error only; mypy won't generate an error)  You should give a statically typed function an explicit ``None`  `\` return type even if it doesn't return a value, as this lets mypy catch additional type errors:

`` `python    def wait(t: float):  # Implicit Any return value        print('Waiting...')        time.sleep(t)     if wait(2) > 1:   # Mypy doesn't catch this error!        ...  If we had used an explicit ``None`return type, mypy would have caught`\` the error:

`` `python    def wait(t: float) -> None:        print('Waiting...')        time.sleep(t)     if wait(2) > 1:   # Error: can't compare None and int        ...  The ``Any`type is discussed in more detail in section [dynamic-typing](#dynamic-typing).  > **Note** >    A function without any types in the signature is dynamically   typed. The body of a dynamically typed function is not checked   statically, and local variables have implicit`Any`types.   This makes it easier to migrate legacy Python code to mypy, as   mypy won't complain about dynamically typed functions.  .. _tuple-types:  Tuple types`\` \*\*\*\*\*\*\*\*\*\*\*

The type `tuple[T1, ..., Tn]` represents a tuple with the item types `T1`, ..., `Tn`:

`` `python    # Use `typing.Tuple` in Python 3.8 and earlier    def f(t: tuple[int, str]) -> None:        t = 1, 'foo'    # OK        t = 'foo', 1    # Type check error  A tuple type of this kind has exactly a specific number of items (2 in ``<span class="title-ref"> the above example). Tuples can also be used as immutable, varying-length sequences. You can use the type </span><span class="title-ref">tuple\[T, ...\]</span><span class="title-ref"> (with a literal </span><span class="title-ref">...</span>\` -- it's part of the syntax) for this purpose. Example:

`` `python     def print_squared(t: tuple[int, ...]) -> None:         for n in t:             print(n, n ** 2)      print_squared(())           # OK     print_squared((1, 3, 5))    # OK     print_squared([1, 2])       # Error: only a tuple is valid  > **Note** >     Usually it's a better idea to use ``Sequence\[T\]`instead of`tuple\[T, ...\]``, as    :py`~collections.abc.Sequence` is also compatible with lists and other non-tuple sequences.  .. note::``tuple\[...\]`is valid as a base class in Python 3.6 and later, and    always in stub files. In earlier Python versions you can sometimes work around this    limitation by using a named tuple as a base class (see section [named-tuples](#named-tuples)).  .. _callable-types:  Callable types (and lambdas)`\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

You can pass around function objects and bound methods in statically typed code. The type of a function that accepts arguments `A1`, ..., `An` and returns `Rt` is `Callable[[A1, ..., An], Rt]`. Example:

`` `python    from collections.abc import Callable     def twice(i: int, next: Callable[[int], int]) -> int:        return next(next(i))     def add(i: int) -> int:        return i + 1     print(twice(3, add))   # 5  > **Note** >      Import :py`Callable[...] <typing.Callable>` from ``typing`instead     of`collections.abc`if you use Python 3.8 or earlier.  You can only have positional arguments, and only ones without default`<span class="title-ref"> values, in callable types. These cover the vast majority of uses of callable types, but sometimes this isn't quite enough. Mypy recognizes a special form </span><span class="title-ref">Callable\[..., T\]</span><span class="title-ref"> (with a literal </span><span class="title-ref">...</span><span class="title-ref">) which can be used in less typical cases. It is compatible with arbitrary callable objects that return a type compatible with </span><span class="title-ref">T</span><span class="title-ref">, independent of the number, types or kinds of arguments. Mypy lets you call such callable values with arbitrary arguments, without any checking -- in this respect they are treated similar to a </span><span class="title-ref">(\*args: Any, \*\*kwargs: Any)</span>\` function signature. Example:

`` `python    from collections.abc import Callable     def arbitrary_call(f: Callable[..., int]) -> int:        return f('x') + f(y=2)  # OK     arbitrary_call(ord)   # No static error, but fails at runtime    arbitrary_call(open)  # Error: does not return an int    arbitrary_call(1)     # Error: 'int' is not callable  In situations where more precise or complex types of callbacks are ``\` necessary one can use flexible \[callback protocols \<callback\_protocols\>\](\#callback-protocols-\<callback\_protocols\>). Lambdas are also supported. The lambda argument and return value types cannot be given explicitly; they are always inferred based on context using bidirectional type inference:

`` `python    l = map(lambda x: x + 1, [1, 2, 3])   # Infer x as int and l as list[int]  If you want to give the argument or return value types explicitly, use ``\` an ordinary, perhaps nested function definition.

Callables can also be used against type objects, matching their `__init__` or `__new__` signature:

`` `python     from collections.abc import Callable      class C:         def __init__(self, app: str) -> None:             pass      CallableType = Callable[[str], C]      def class_or_callable(arg: CallableType) -> None:         inst = arg("my_app")         reveal_type(inst)  # Revealed type is "C"  This is useful if you want ``arg`to be either a`Callable`returning an`<span class="title-ref"> instance of </span><span class="title-ref">C</span><span class="title-ref"> or the type of </span><span class="title-ref">C</span>\` itself. This also works with \[callback protocols \<callback\_protocols\>\](\#callback-protocols-\<callback\_protocols\>).

## Union types<span id="union-types"></span>

Python functions often accept values of two or more different types. You can use \[overloading \<function-overloading\>\](\#overloading-\<function-overloading\>) to represent this, but union types are often more convenient.

Use `T1 | ... | Tn` to construct a union type. For example, if an argument has type `int | str`, both integers and strings are valid argument values.

You can use an :py\`isinstance\` check to narrow down a union type to a more specific type:

`` `python    def f(x: int | str) -> None:        x + 1     # Error: str + int is not valid        if isinstance(x, int):            # Here type of x is int.            x + 1      # OK        else:            # Here type of x is str.            x + 'a'    # OK     f(1)    # OK    f('x')  # OK    f(1.1)  # Error  > **Note** >      Operations are valid for union types only if they are valid for *every*     union item. This is why it's often necessary to use an :py`isinstance`     check to first narrow down a union type to a non-union type. This also     means that it's recommended to avoid union types as function return types,     since the caller may have to use :py`isinstance` before doing anything     interesting with the value.  Python 3.9 and older only partially support this syntax. Instead, you can ``<span class="title-ref"> use the legacy </span><span class="title-ref">Union\[T1, ..., Tn\]</span>\` type constructor. Example:

`` `python    from typing import Union     def f(x: Union[int, str]) -> None:        ...  It is also possible to use the new syntax with versions of Python where it ``<span class="title-ref"> isn't supported by the runtime with some limitations, if you use </span><span class="title-ref">from \_\_future\_\_ import annotations</span>\` (see \[runtime\_troubles\](\#runtime\_troubles)):

`` `python    from __future__ import annotations     def f(x: int | str) -> None:   # OK on Python 3.7 and later        ...  .. _strict_optional:  Optional types and the None type ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

You can use `T | None` to define a type variant that allows `None` values, such as `int | None`. This is called an *optional type*:

`` `python    def strlen(s: str) -> int | None:        if not s:            return None  # OK        return len(s)     def strlen_invalid(s: str) -> int:        if not s:            return None  # Error: None not compatible with int        return len(s)  To support Python 3.9 and earlier, you can use the :py`~typing.Optional` ``<span class="title-ref"> type modifier instead, such as </span><span class="title-ref">Optional\[int\]</span><span class="title-ref"> (</span><span class="title-ref">Optional\[X\]</span><span class="title-ref"> is the preferred shorthand for </span><span class="title-ref">Union\[X, None\]</span>\`):

`` `python    from typing import Optional     def strlen(s: str) -> Optional[int]:        ...  Most operations will not be allowed on unguarded ``None`or *optional* values`\` (values with an optional type):

`` `python    def my_inc(x: int | None) -> int:        return x + 1  # Error: Cannot add None and int  Instead, an explicit ``None`check is required. Mypy has`<span class="title-ref"> powerful type inference that lets you use regular Python idioms to guard against </span><span class="title-ref">None</span><span class="title-ref"> values. For example, mypy recognizes </span><span class="title-ref">is None</span>\` checks:

`` `python    def my_inc(x: int | None) -> int:        if x is None:            return 0        else:            # The inferred type of x is just int here.            return x + 1  Mypy will infer the type of ``x`to be`int`in the else block due to the`<span class="title-ref"> check against </span><span class="title-ref">None</span>\` in the if condition.

Other supported checks for guarding against a `None` value include `if x is not None`, `if x` and `if not x`. Additionally, mypy understands `None` checks within logical expressions:

`` `python    def concat(x: str | None, y: str | None) -> str | None:        if x is not None and y is not None:            # Both x and y are not None here            return x + y        else:            return None  Sometimes mypy doesn't realize that a value is never ``None`. This notably`<span class="title-ref"> happens when a class instance can exist in a partially defined state, where some attribute is initialized to </span><span class="title-ref">None</span><span class="title-ref"> during object construction, but a method assumes that the attribute is no longer </span><span class="title-ref">None</span><span class="title-ref">. Mypy will complain about the possible </span><span class="title-ref">None</span><span class="title-ref"> value. You can use </span><span class="title-ref">assert x is not None</span>\` to work around this in the method:

`` `python    class Resource:        path: str | None = None         def initialize(self, path: str) -> None:            self.path = path         def read(self) -> str:            # We require that the object has been initialized.            assert self.path is not None            with open(self.path) as f:  # OK               return f.read()     r = Resource()    r.initialize('/foo/bar')    r.read()  When initializing a variable as ``None`,`None`is usually an`<span class="title-ref"> empty place-holder value, and the actual value has a different type. This is why you need to annotate an attribute in cases like the class </span><span class="title-ref">Resource</span>\` above:

`` `python     class Resource:         path: str | None = None         ...  This also works for attributes defined within methods:  .. code-block:: python      class Counter:         def __init__(self) -> None:             self.count: int | None = None  Often it's easier to not use any initial value for an attribute. ``<span class="title-ref"> This way you don't need to use an optional type and can avoid </span><span class="title-ref">assert ... is not None</span>\` checks. No initial value is needed if you annotate an attribute in the class body:

`` `python    class Container:        items: list[str]  # No initial value  Mypy generally uses the first assignment to a variable to ``<span class="title-ref"> infer the type of the variable. However, if you assign both a </span><span class="title-ref">None</span><span class="title-ref"> value and a non-</span><span class="title-ref">None</span>\` value in the same scope, mypy can usually do the right thing without an annotation:

`` `python    def f(i: int) -> None:        n = None  # Inferred type 'int | None' because of the assignment below        if i > 0:             n = i        ...  Sometimes you may get the error "Cannot determine type of <something>". In this ``<span class="title-ref"> case you should add an explicit </span><span class="title-ref">... | None</span>\` annotation.

\> **Note** \> `None` is a type with only one value, `None`. `None` is also used as the return type for functions that don't return a value, i.e. functions that implicitly return `None`.

<div class="note">

<div class="title">

Note

</div>

The Python interpreter internally uses the name `NoneType` for the type of `None`, but `None` is always used in type annotations. The latter is shorter and reads better. (`NoneType` is available as :py\`types.NoneType\` on Python 3.10+, but is not exposed at all on earlier versions of Python.)

</div>

<div class="note">

<div class="title">

Note

</div>

The type `Optional[T]` *does not* mean a function parameter with a default value. It simply means that `None` is a valid argument value. This is a common confusion because `None` is a common default value for parameters, and parameters with default values are sometimes called *optional* parameters (or arguments).

</div>

## Type aliases

In certain situations, type names may end up being long and painful to type, especially if they are used frequently:

`` `python    def f() -> list[dict[tuple[int, str], set[int]]] | tuple[str, list[str]]:        ...  When cases like this arise, you can define a type alias by simply ``\` assigning the type to a variable (this is an *implicit type alias*):

`` `python    AliasType = list[dict[tuple[int, str], set[int]]] | tuple[str, list[str]]     # Now we can use AliasType in place of the full name:     def f() -> AliasType:        ...  > **Note** >      A type alias does not create a new type. It's just a shorthand notation for     another type -- it's equivalent to the target type except for     [generic aliases <generic-type-aliases>](#generic-aliases-<generic-type-aliases>).  Python 3.12 introduced the ``type`statement for defining *explicit type aliases*.`\` Explicit type aliases are unambiguous and can also improve readability by making the intent clear:

`` `python    type AliasType = list[dict[tuple[int, str], set[int]]] | tuple[str, list[str]]     # Now we can use AliasType in place of the full name:     def f() -> AliasType:        ...  There can be confusion about exactly when an assignment defines an implicit type alias -- ``\` for example, when the alias contains forward references, invalid types, or violates some other restrictions on type alias declarations. Because the distinction between an unannotated variable and a type alias is implicit, ambiguous or incorrect type alias declarations default to defining a normal variable instead of a type alias.

Aliases defined using the `type` statement have these properties, which distinguish them from implicit type aliases:

  - The definition may contain forward references without having to use string literal escaping, since it is evaluated lazily.
  - The alias can be used in type annotations, type arguments, and casts, but it can't be used in contexts which require a class object. For example, it's not valid as a base class and it can't be used to construct instances.

There is also use an older syntax for defining explicit type aliases, which was introduced in Python 3.10 (`613`):

`` `python    from typing import TypeAlias  # "from typing_extensions" in Python 3.9 and earlier     AliasType: TypeAlias = list[dict[tuple[int, str], set[int]]] | tuple[str, list[str]]  .. _named-tuples:  Named tuples ``\` \*\*\*\*\*\*\*\*\*\*\*\*

Mypy recognizes named tuples and can type check code that defines or uses them. In this example, we can detect code trying to access a missing attribute:

`` `python     Point = namedtuple('Point', ['x', 'y'])     p = Point(x=1, y=2)     print(p.z)  # Error: Point has no attribute 'z'  If you use :py`namedtuple <collections.namedtuple>` to define your named tuple, all the items ``<span class="title-ref"> are assumed to have </span><span class="title-ref">Any</span><span class="title-ref"> types. That is, mypy doesn't know anything about item types. You can use :py</span>\~typing.NamedTuple\` to also define item types:

`` `python     from typing import NamedTuple      Point = NamedTuple('Point', [('x', int),                                  ('y', int)])     p = Point(x=1, y='x')  # Argument has incompatible type "str"; expected "int"  Python 3.6 introduced an alternative, class-based syntax for named tuples with types:  .. code-block:: python      from typing import NamedTuple      class Point(NamedTuple):         x: int         y: int      p = Point(x=1, y='x')  # Argument has incompatible type "str"; expected "int"  > **Note** >    You can use the raw ``NamedTuple`"pseudo-class" in type annotations   if any`NamedTuple`object is valid.    For example, it can be useful for deserialization:    .. code-block:: python      def deserialize_named_tuple(arg: NamedTuple) -> Dict[str, Any]:         return arg._asdict()      Point = namedtuple('Point', ['x', 'y'])     Person = NamedTuple('Person', [('name', str), ('age', int)])      deserialize_named_tuple(Point(x=1, y=2))  # ok     deserialize_named_tuple(Person(name='Nikita', age=18))  # ok      # Error: Argument 1 to "deserialize_named_tuple" has incompatible type     # "Tuple[int, int]"; expected "NamedTuple"     deserialize_named_tuple((1, 2))    Note that this behavior is highly experimental, non-standard,   and may not be supported by other type checkers and IDEs.  .. _type-of-class:  The type of class objects`\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

(Freely after `PEP 484: The type of class objects
<484#the-type-of-class-objects>`.)

Sometimes you want to talk about class objects that inherit from a given class. This can be spelled as `type[C]` (or, on Python 3.8 and lower, :py\`typing.Type\[C\] \<typing.Type\><span class="title-ref">) where </span><span class="title-ref">C</span><span class="title-ref"> is a class. In other words, when </span><span class="title-ref">C</span><span class="title-ref"> is the name of a class, using </span><span class="title-ref">C</span><span class="title-ref"> to annotate an argument declares that the argument is an instance of </span><span class="title-ref">C</span><span class="title-ref"> (or of a subclass of </span><span class="title-ref">C</span><span class="title-ref">), but using </span><span class="title-ref">type\[C\]</span><span class="title-ref"> as an argument annotation declares that the argument is a class object deriving from </span><span class="title-ref">C</span><span class="title-ref"> (or </span><span class="title-ref">C</span>\` itself).

For example, assume the following classes:

`` `python    class User:        # Defines fields like name, email     class BasicUser(User):        def upgrade(self):            """Upgrade to Pro"""     class ProUser(User):        def pay(self):            """Pay bill"""  Note that ``ProUser`doesn't inherit from`BasicUser`.  Here's a function that creates an instance of one of these classes if`\` you pass it the right class object:

`` `python    def new_user(user_class):        user = user_class()        # (Here we could write the user object to a database)        return user  How would we annotate this function?  Without the ability to parameterize ``type`, the best we`\` could do would be:

`` `python    def new_user(user_class: type) -> User:        # Same  implementation as before  This seems reasonable, except that in the following example, mypy ``<span class="title-ref"> doesn't see that the </span><span class="title-ref">buyer</span><span class="title-ref"> variable has type </span><span class="title-ref">ProUser</span>\`:

`` `python    buyer = new_user(ProUser)    buyer.pay()  # Rejected, not a method on User  However, using the ``type\[C\]`syntax and a type variable with an upper bound (see`\` \[type-variable-upper-bound\](\#type-variable-upper-bound)) we can do better (Python 3.12 syntax):

`` `python    def new_user[U: User](user_class: type[U]) -> U:        # Same implementation as before  Here is the example using the legacy syntax (Python 3.11 and earlier):  .. code-block:: python     U = TypeVar('U', bound=User)     def new_user(user_class: type[U]) -> U:        # Same implementation as before  Now mypy will infer the correct type of the result when we call ``<span class="title-ref"> </span><span class="title-ref">new\_user()</span><span class="title-ref"> with a specific subclass of </span><span class="title-ref">User</span>\`:

`` `python    beginner = new_user(BasicUser)  # Inferred type is BasicUser    beginner.upgrade()  # OK  > **Note** >     The value corresponding to ``type\[C\]`must be an actual class    object that's a subtype of`C`.  Its constructor must be    compatible with the constructor of`C`.  If`C`is a type    variable, its upper bound must be a class object.  For more details about`type\[\]``and :py`typing.Type[] <typing.Type>`, see :pep:`PEP 484: The type of``<span class="title-ref"> class objects \<484\#the-type-of-class-objects\></span>.

## Generators

A basic generator that only yields values can be succinctly annotated as having a return type of either :py\`Iterator\[YieldType\] \<typing.Iterator\><span class="title-ref"> or :py\`Iterable\[YieldType\] \<typing.Iterable\></span>. For example:

`` `python    def squares(n: int) -> Iterator[int]:        for i in range(n):            yield i * i  A good rule of thumb is to annotate functions with the most specific return ``<span class="title-ref"> type possible. However, you should also take care to avoid leaking implementation details into a function's public API. In keeping with these two principles, prefer :py\`Iterator\[YieldType\] \<typing.Iterator\></span> over :py\`Iterable\[YieldType\] \<typing.Iterable\><span class="title-ref"> as the return-type annotation for a generator function, as it lets mypy know that users are able to call :py\`next</span> on the object returned by the function. Nonetheless, bear in mind that `Iterable` may sometimes be the better option, if you consider it an implementation detail that `next()` can be called on the object returned by your function.

If you want your generator to accept values via the :py\`\~generator.send\` method or return a value, on the other hand, you should use the :py\`Generator\[YieldType, SendType, ReturnType\] \<typing.Generator\><span class="title-ref"> generic type instead of either </span><span class="title-ref">Iterator</span><span class="title-ref"> or </span><span class="title-ref">Iterable</span>\`. For example:

`` `python    def echo_round() -> Generator[int, float, str]:        sent = yield 0        while sent >= 0:            sent = yield round(sent)        return 'Done'  Note that unlike many other generics in the typing module, the ``SendType`of`<span class="title-ref"> :py</span>\~typing.Generator\` behaves contravariantly, not covariantly or invariantly.

If you do not plan on receiving or returning values, then set the `SendType` or `ReturnType` to `None`, as appropriate. For example, we could have annotated the first example as the following:

`` `python    def squares(n: int) -> Generator[int, None, None]:        for i in range(n):            yield i * i  This is slightly different from using ``Iterator\[int\]`or`Iterable\[int\]`,`<span class="title-ref"> since generators have :py</span>\~generator.close\`, :py\`\~generator.send\`, and :py\`\~generator.throw\` methods that generic iterators and iterables don't. If you plan to call these methods on the returned generator, use the :py\`\~typing.Generator\` type instead of :py\`\~typing.Iterator\` or :py\`\~typing.Iterable\`.

---

literal_types.md

---

# Literal types and Enums

## Literal types

Literal types let you indicate that an expression is equal to some specific primitive value. For example, if we annotate a variable with type `Literal["foo"]`, mypy will understand that variable is not only of type `str`, but is also equal to specifically the string `"foo"`.

This feature is primarily useful when annotating functions that behave differently based on the exact value the caller provides. For example, suppose we have a function `fetch_data(...)` that returns `bytes` if the first argument is `True`, and `str` if it's `False`. We can construct a precise type signature for this function using `Literal[...]` and overloads:

`` `python     from typing import overload, Union, Literal      # The first two overloads use Literal[...] so we can     # have precise return types:      @overload     def fetch_data(raw: Literal[True]) -> bytes: ...     @overload     def fetch_data(raw: Literal[False]) -> str: ...      # The last overload is a fallback in case the caller     # provides a regular bool:      @overload     def fetch_data(raw: bool) -> Union[bytes, str]: ...      def fetch_data(raw: bool) -> Union[bytes, str]:         # Implementation is omitted         ...      reveal_type(fetch_data(True))        # Revealed type is "bytes"     reveal_type(fetch_data(False))       # Revealed type is "str"      # Variables declared without annotations will continue to have an     # inferred type of 'bool'.      variable = True     reveal_type(fetch_data(variable))    # Revealed type is "Union[bytes, str]"  > **Note** >      The examples in this page import ``Literal`as well as`Final`and`TypedDict`from the`typing`module. These types were added to`typing`in Python 3.8, but are also available for use in Python     3.4 - 3.7 via the`typing\_extensions`package.  Parameterizing Literals`\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Literal types may contain one or more literal bools, ints, strs, bytes, and enum values. However, literal types **cannot** contain arbitrary expressions: types like `Literal[my_string.trim()]`, `Literal[x > 3]`, or `Literal[3j + 4]` are all illegal.

Literals containing two or more values are equivalent to the union of those values. So, `Literal[-3, b"foo", MyEnum.A]` is equivalent to `Union[Literal[-3], Literal[b"foo"], Literal[MyEnum.A]]`. This makes writing more complex types involving literals a little more convenient.

Literal types may also contain `None`. Mypy will treat `Literal[None]` as being equivalent to just `None`. This means that `Literal[4, None]`, `Literal[4] | None`, and `Optional[Literal[4]]` are all equivalent.

Literals may also contain aliases to other literal types. For example, the following program is legal:

`` `python     PrimaryColors = Literal["red", "blue", "yellow"]     SecondaryColors = Literal["purple", "green", "orange"]     AllowedColors = Literal[PrimaryColors, SecondaryColors]      def paint(color: AllowedColors) -> None: ...      paint("red")        # Type checks!     paint("turquoise")  # Does not type check  Literals may not contain any other kind of type or expression. This means doing ``<span class="title-ref"> </span><span class="title-ref">Literal\[my\_instance\]</span><span class="title-ref">, </span><span class="title-ref">Literal\[Any\]</span><span class="title-ref">, </span><span class="title-ref">Literal\[3.14\]</span><span class="title-ref">, or </span><span class="title-ref">Literal\[{"foo": 2, "bar": 5}\]</span>\` are all illegal.

### Declaring literal variables

You must explicitly add an annotation to a variable to declare that it has a literal type:

`` `python     a: Literal[19] = 19     reveal_type(a)          # Revealed type is "Literal[19]"  In order to preserve backwards-compatibility, variables without this annotation ``\` are **not** assumed to be literals:

`` `python     b = 19     reveal_type(b)          # Revealed type is "int"  If you find repeating the value of the variable in the type hint to be tedious, ``<span class="title-ref"> you can instead change the variable to be </span><span class="title-ref">Final</span>\` (see \[final\_attrs\](\#final\_attrs)):

`` `python     from typing import Final, Literal      def expects_literal(x: Literal[19]) -> None: pass      c: Final = 19      reveal_type(c)          # Revealed type is "Literal[19]?"     expects_literal(c)      # ...and this type checks!  If you do not provide an explicit type in the ``Final`, the type of`c`becomes`<span class="title-ref"> \*context-sensitive\*: mypy will basically try "substituting" the original assigned value whenever it's used before performing type checking. This is why the revealed type of </span><span class="title-ref">c</span><span class="title-ref"> is </span><span class="title-ref">Literal\[19\]?</span>\`: the question mark at the end reflects this context-sensitive nature.

For example, mypy will type check the above program almost as if it were written like so:

`` `python     from typing import Final, Literal      def expects_literal(x: Literal[19]) -> None: pass      reveal_type(19)     expects_literal(19)  This means that while changing a variable to be ``Final`is not quite the same thing`<span class="title-ref"> as adding an explicit </span><span class="title-ref">Literal\[...\]</span>\` annotation, it often leads to the same effect in practice.

The main cases where the behavior of context-sensitive vs true literal types differ are when you try using those types in places that are not explicitly expecting a `Literal[...]`. For example, compare and contrast what happens when you try appending these types to a list:

`` `python     from typing import Final, Literal      a: Final = 19     b: Literal[19] = 19      # Mypy will choose to infer list[int] here.     list_of_ints = []     list_of_ints.append(a)     reveal_type(list_of_ints)  # Revealed type is "list[int]"      # But if the variable you're appending is an explicit Literal, mypy     # will infer list[Literal[19]].     list_of_lits = []     list_of_lits.append(b)     reveal_type(list_of_lits)  # Revealed type is "list[Literal[19]]"   Intelligent indexing ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

We can use Literal types to more precisely index into structured heterogeneous types such as tuples, NamedTuples, and TypedDicts. This feature is known as *intelligent indexing*.

For example, when we index into a tuple using some int, the inferred type is normally the union of the tuple item types. However, if we want just the type corresponding to some particular index, we can use Literal types like so:

`` `python     from typing import TypedDict      tup = ("foo", 3.4)      # Indexing with an int literal gives us the exact type for that index     reveal_type(tup[0])  # Revealed type is "str"      # But what if we want the index to be a variable? Normally mypy won't     # know exactly what the index is and so will return a less precise type:     int_index = 0     reveal_type(tup[int_index])  # Revealed type is "Union[str, float]"      # But if we use either Literal types or a Final int, we can gain back     # the precision we originally had:     lit_index: Literal[0] = 0     fin_index: Final = 0     reveal_type(tup[lit_index])  # Revealed type is "str"     reveal_type(tup[fin_index])  # Revealed type is "str"      # We can do the same thing with with TypedDict and str keys:     class MyDict(TypedDict):         name: str         main_id: int         backup_id: int      d: MyDict = {"name": "Saanvi", "main_id": 111, "backup_id": 222}     name_key: Final = "name"     reveal_type(d[name_key])  # Revealed type is "str"      # You can also index using unions of literals     id_key: Literal["main_id", "backup_id"]     reveal_type(d[id_key])    # Revealed type is "int"  .. _tagged_unions:  Tagged unions ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*

When you have a union of types, you can normally discriminate between each type in the union by using `isinstance` checks. For example, if you had a variable `x` of type `Union[int, str]`, you could write some code that runs only if `x` is an int by doing `if isinstance(x, int): ...`.

However, it is not always possible or convenient to do this. For example, it is not possible to use `isinstance` to distinguish between two different TypedDicts since at runtime, your variable will simply be just a dict.

Instead, what you can do is *label* or *tag* your TypedDicts with a distinct Literal type. Then, you can discriminate between each kind of TypedDict by checking the label:

`` `python     from typing import Literal, TypedDict, Union      class NewJobEvent(TypedDict):         tag: Literal["new-job"]         job_name: str         config_file_path: str      class CancelJobEvent(TypedDict):         tag: Literal["cancel-job"]         job_id: int      Event = Union[NewJobEvent, CancelJobEvent]      def process_event(event: Event) -> None:         # Since we made sure both TypedDicts have a key named 'tag', it's         # safe to do 'event["tag"]'. This expression normally has the type         # Literal["new-job", "cancel-job"], but the check below will narrow         # the type to either Literal["new-job"] or Literal["cancel-job"].         #         # This in turns narrows the type of 'event' to either NewJobEvent         # or CancelJobEvent.         if event["tag"] == "new-job":             print(event["job_name"])         else:             print(event["job_id"])  While this feature is mostly useful when working with TypedDicts, you can also ``\` use the same technique with regular objects, tuples, or namedtuples.

Similarly, tags do not need to be specifically str Literals: they can be any type you can normally narrow within `if` statements and the like. For example, you could have your tags be int or Enum Literals or even regular classes you narrow using `isinstance()` (Python 3.12 syntax):

`` `python     class Wrapper[T]:         def __init__(self, inner: T) -> None:             self.inner = inner      def process(w: Wrapper[int] | Wrapper[str]) -> None:         # Doing `if isinstance(w, Wrapper[int])` does not work: isinstance requires         # that the second argument always be an *erased* type, with no generics.         # This is because generics are a typing-only concept and do not exist at         # runtime in a way `isinstance` can always check.         #         # However, we can side-step this by checking the type of `w.inner` to         # narrow `w` itself:         if isinstance(w.inner, int):             reveal_type(w)  # Revealed type is "Wrapper[int]"         else:             reveal_type(w)  # Revealed type is "Wrapper[str]"  This feature is sometimes called "sum types" or "discriminated union types" ``\` in other programming languages.

### Exhaustiveness checking

You may want to check that some code covers all possible `Literal` or `Enum` cases. Example:

`` `python   from typing import Literal    PossibleValues = Literal['one', 'two']    def validate(x: PossibleValues) -> bool:       if x == 'one':           return True       elif x == 'two':           return False       raise ValueError(f'Invalid value: {x}')    assert validate('one') is True   assert validate('two') is False  In the code above, it's easy to make a mistake. You can ``<span class="title-ref"> add a new literal value to </span><span class="title-ref">PossibleValues</span><span class="title-ref"> but forget to handle it in the </span><span class="title-ref">validate</span>\` function:

`` `python   PossibleValues = Literal['one', 'two', 'three']  Mypy won't catch that ``'three'`is not covered.  If you want mypy to`<span class="title-ref"> perform an exhaustiveness check, you need to update your code to use an </span><span class="title-ref">assert\_never()</span>\` check:

`` `python   from typing import Literal, NoReturn   from typing_extensions import assert_never    PossibleValues = Literal['one', 'two']    def validate(x: PossibleValues) -> bool:       if x == 'one':           return True       elif x == 'two':           return False       assert_never(x)  Now if you add a new value to ``PossibleValues`but don't update`validate`,`\` mypy will spot the error:

`` `python   PossibleValues = Literal['one', 'two', 'three']    def validate(x: PossibleValues) -> bool:       if x == 'one':           return True       elif x == 'two':           return False       # Error: Argument 1 to "assert_never" has incompatible type "Literal['three']";       # expected "NoReturn"       assert_never(x)  If runtime checking against unexpected values is not needed, you can ``<span class="title-ref"> leave out the </span><span class="title-ref">assert\_never</span><span class="title-ref"> call in the above example, and mypy will still generate an error about function </span><span class="title-ref">validate</span>\` returning without a value:

`` `python   PossibleValues = Literal['one', 'two', 'three']    # Error: Missing return statement   def validate(x: PossibleValues) -> bool:       if x == 'one':           return True       elif x == 'two':           return False  Exhaustiveness checking is also supported for match statements (Python 3.10 and later):  .. code-block:: python    def validate(x: PossibleValues) -> bool:       match x:           case 'one':               return True           case 'two':               return False       assert_never(x)   Limitations ``\` \*\*\*\*\*\*\*\*\*\*\*

Mypy will not understand expressions that use variables of type `Literal[..]` on a deep level. For example, if you have a variable `a` of type `Literal[3]` and another variable `b` of type `Literal[5]`, mypy will infer that `a + b` has type `int`, **not** type `Literal[8]`.

The basic rule is that literal types are treated as just regular subtypes of whatever type the parameter has. For example, `Literal[3]` is treated as a subtype of `int` and so will inherit all of `int`'s methods directly. This means that `Literal[3].__add__` accepts the same arguments and has the same return type as `int.__add__`.

## Enums

Mypy has special support for :py\`enum.Enum\` and its subclasses: :py\`enum.IntEnum\`, :py\`enum.Flag\`, :py\`enum.IntFlag\`, and :py\`enum.StrEnum\`.

`` `python   from enum import Enum    class Direction(Enum):       up = 'up'       down = 'down'    reveal_type(Direction.up)  # Revealed type is "Literal[Direction.up]?"   reveal_type(Direction.down)  # Revealed type is "Literal[Direction.down]?"  You can use enums to annotate types as you would expect:  .. code-block:: python    class Movement:       def __init__(self, direction: Direction, speed: float) -> None:           self.direction = direction           self.speed = speed    Movement(Direction.up, 5.0)  # ok   Movement('up', 5.0)  # E: Argument 1 to "Movement" has incompatible type "str"; expected "Direction"  Exhaustiveness checking ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Similar to `Literal` types, `Enum` supports exhaustiveness checking. Let's start with a definition:

`` `python   from enum import Enum   from typing import NoReturn   from typing_extensions import assert_never    class Direction(Enum):       up = 'up'       down = 'down'  Now, let's use an exhaustiveness check:  .. code-block:: python    def choose_direction(direction: Direction) -> None:       if direction is Direction.up:           reveal_type(direction)  # N: Revealed type is "Literal[Direction.up]"           print('Going up!')           return       elif direction is Direction.down:           print('Down')           return       # This line is never reached       assert_never(direction)  If we forget to handle one of the cases, mypy will generate an error:  .. code-block:: python    def choose_direction(direction: Direction) -> None:       if direction == Direction.up:           print('Going up!')           return       assert_never(direction)  # E: Argument 1 to "assert_never" has incompatible type "Direction"; expected "NoReturn"  Exhaustiveness checking is also supported for match statements (Python 3.10 and later).  Extra Enum checks ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Mypy also tries to support special features of `Enum` the same way Python's runtime does:

  - Any `Enum` class with values is implicitly \[final \<final\_attrs\>\](\#final-\<final\_attrs\>). This is what happens in CPython:
    
      - \`\`\`python  
        \>\>\> class AllDirection(Direction): ... left = 'left' ... right = 'right' Traceback (most recent call last): ... TypeError: AllDirection: cannot extend enumeration 'Direction'
    
    Mypy also catches this error:
    
    ``` python
    class AllDirection(Direction):  # E: Cannot inherit from final class "Direction"
        left = 'left'
        right = 'right'
    ```

  - All `Enum` fields are implicitly `final` as well.
    
    ``` python
    Direction.up = '^'  # E: Cannot assign to final attribute "up"
    ```

  - All field names are checked to be unique.
    
    ``` python
    class Some(Enum):
       x = 1
       x = 2  # E: Attempted to reuse member name "x" in Enum definition "Some"
    ```

\- Base classes have no conflicts and mixin types are correct.

> 
> 
> ``` python
> class WrongEnum(str, int, enum.Enum):
>     # E: Only a single data type mixin is allowed for Enum subtypes, found extra "int"
>     ...
> 
> class MixinAfterEnum(enum.Enum, Mixin): # E: No base classes are allowed after "enum.Enum"
>     ...
> ```

\`\`\`

---

metaclasses.md

---

# Metaclasses

A \[metaclass \<python:metaclasses\>\](\#metaclass-\<python:metaclasses\>) is a class that describes the construction and behavior of other classes, similarly to how classes describe the construction and behavior of objects. The default metaclass is :py\`type\`, but it's possible to use other metaclasses. Metaclasses allows one to create "a different kind of class", such as :py\`\~enum.Enum\`s, :py\`\~typing.NamedTuple\`s and singletons.

Mypy has some special understanding of :py\`\~abc.ABCMeta\` and `EnumMeta`.

## Defining a metaclass

`` `python     class M(type):         pass      class A(metaclass=M):         pass  .. _examples:  Metaclass usage example ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Mypy supports the lookup of attributes in the metaclass:

`` `python     from typing import ClassVar, Self      class M(type):         count: ClassVar[int] = 0          def make(cls) -> Self:             M.count += 1             return cls()      class A(metaclass=M):         pass      a: A = A.make()  # make() is looked up at M; the result is an object of type A     print(A.count)      class B(A):         pass      b: B = B.make()  # metaclasses are inherited     print(B.count + " objects were created")  # Error: Unsupported operand types for + ("int" and "str")  .. note::     In Python 3.10 and earlier, ``Self`is available in`typing\_extensions`.  .. _limitations:  Gotchas and limitations of metaclass support`\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Note that metaclasses pose some requirements on the inheritance structure, so it's better not to combine metaclasses and class hierarchies:

`` `python     class M1(type): pass     class M2(type): pass      class A1(metaclass=M1): pass     class A2(metaclass=M2): pass      class B1(A1, metaclass=M2): pass  # Mypy Error: metaclass conflict     # At runtime the above definition raises an exception     # TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases      class B12(A1, A2): pass  # Mypy Error: metaclass conflict      # This can be solved via a common metaclass subtype:     class CorrectMeta(M1, M2): pass     class B2(A1, A2, metaclass=CorrectMeta): pass  # OK, runtime is also OK  * Mypy does not understand dynamically-computed metaclasses,   such as ``class A(metaclass=f()): ...`  `<span class="title-ref"> \* Mypy does not and cannot understand arbitrary metaclass code. \* Mypy only recognizes subclasses of :py\`type</span> as potential metaclasses.

---

more_types.md

---

# More types

This section introduces a few additional kinds of types, including :py\`\~typing.NoReturn\`, :py\`\~typing.NewType\`, and types for async code. It also discusses how to give functions more precise types using overloads. All of these are only situationally useful, so feel free to skip this section and come back when you have a need for some of them.

Here's a quick summary of what's covered here:

  - :py\`\~typing.NoReturn\` lets you tell mypy that a function never returns normally.
  - :py\`\~typing.NewType\` lets you define a variant of a type that is treated as a separate type by mypy but is identical to the original type at runtime. For example, you can have `UserId` as a variant of `int` that is just an `int` at runtime.
  - :py\`@overload \<typing.overload\>\` lets you define a function that can accept multiple distinct signatures. This is useful if you need to encode a relationship between the arguments and the return type that would be difficult to express normally.
  - Async types let you type check programs using `async` and `await`.

## The NoReturn type

Mypy provides support for functions that never return. For example, a function that unconditionally raises an exception:

`` `python    from typing import NoReturn     def stop() -> NoReturn:        raise Exception('no way')  Mypy will ensure that functions annotated as returning :py`~typing.NoReturn` ``\` truly never return, either implicitly or explicitly. Mypy will also recognize that the code after calls to such functions is unreachable and will behave accordingly:

`` `python    def f(x: int) -> int:        if x == 0:            return x        stop()        return 'whatever works'  # No error in an unreachable block  In earlier Python versions you need to install ``typing\_extensions`using`<span class="title-ref"> pip to use :py</span>\~typing.NoReturn\` in your code. Python 3 command line:

`` `text     python3 -m pip install --upgrade typing-extensions  .. _newtypes:  NewTypes ``\` \*\*\*\*\*\*\*\*

There are situations where you may want to avoid programming errors by creating simple derived classes that are only used to distinguish certain values from base class instances. Example:

`` `python     class UserId(int):         pass      def get_by_user_id(user_id: UserId):         ...  However, this approach introduces some runtime overhead. To avoid this, the typing ``<span class="title-ref"> module provides a helper object :py</span>\~typing.NewType\` that creates simple unique types with almost zero runtime overhead. Mypy will treat the statement `Derived = NewType('Derived', Base)` as being roughly equivalent to the following definition:

`` `python     class Derived(Base):         def __init__(self, _x: Base) -> None:             ...  However, at runtime, ``NewType('Derived', Base)`will return a dummy callable that`\` simply returns its argument:

`` `python     def Derived(_x):         return _x  Mypy will require explicit casts from ``int`where`UserId`is expected, while`<span class="title-ref"> implicitly casting from </span><span class="title-ref">UserId</span><span class="title-ref"> where </span><span class="title-ref">int</span>\` is expected. Examples:

`` `python     from typing import NewType      UserId = NewType('UserId', int)      def name_by_id(user_id: UserId) -> str:         ...      UserId('user')          # Fails type check      name_by_id(42)          # Fails type check     name_by_id(UserId(42))  # OK      num: int = UserId(5) + 1  :py`~typing.NewType` accepts exactly two arguments. The first argument must be a string literal ``\` containing the name of the new type and must equal the name of the variable to which the new type is assigned. The second argument must be a properly subclassable class, i.e., not a type construct like a \[union type \<union-types\>\](\#union-type-\<union-types\>), etc.

The callable returned by :py\`\~typing.NewType\` accepts only one argument; this is equivalent to supporting only one constructor accepting an instance of the base class (see above). Example:

`` `python     from typing import NewType      class PacketId:         def __init__(self, major: int, minor: int) -> None:             self._major = major             self._minor = minor      TcpPacketId = NewType('TcpPacketId', PacketId)      packet = PacketId(100, 100)     tcp_packet = TcpPacketId(packet)  # OK      tcp_packet = TcpPacketId(127, 0)  # Fails in type checker and at runtime  You cannot use :py`isinstance` or :py`issubclass` on the object returned by ``<span class="title-ref"> :py</span>\~typing.NewType\`, nor can you subclass an object returned by :py\`\~typing.NewType\`.

\> **Note** \> Unlike type aliases, :py\`\~typing.NewType\` will create an entirely new and unique type when used. The intended purpose of :py\`\~typing.NewType\` is to help you detect cases where you accidentally mixed together the old base type and the new derived type.

> For example, the following will successfully typecheck when using type aliases:
> 
>   - \`\`\`python  
>     UserId = int
>     
>       - def name\_by\_id(user\_id: UserId) -\> str:  
>         ...
>     
>     name\_by\_id(3) \# ints and UserId are synonymous
> 
> But a similar example using :py\`\~typing.NewType\` will not typecheck:
> 
> ``` python
> from typing import NewType
> 
> UserId = NewType('UserId', int)
> 
> def name_by_id(user_id: UserId) -> str:
>     ...
> 
> name_by_id(3)  # int is not the same as UserId
> ```

<div id="function-overloading">

Function overloading `` ` ********************  Sometimes the arguments and types in a function depend on each other in ways that can't be captured with a [union types <union-types>](#union-types-<union-types>). For example, suppose we want to write a function that can accept x-y coordinates. If we pass in just a single x-y coordinate, we return a ``ClickEvent`object. However, if we pass in two x-y coordinates, we return a`DragEvent`object.  Our first attempt at writing this function might look like this:`\`python def mouse\_event(x1: int, y1: int, x2: int | None = None, y2: int | None = None) -\> ClickEvent | DragEvent: if x2 is None and y2 is None: return ClickEvent(x1, y1) elif x2 is not None and y2 is not None: return DragEvent(x1, y1, x2, y2) else: raise TypeError("Bad arguments")

</div>

While this function signature works, it's too loose: it implies `mouse_event` `` ` could return either object regardless of the number of arguments we pass in. It also does not prohibit a caller from passing in the wrong number of ints: mypy would treat calls like ``mouse\_event(1, 2, 20)``as being valid, for example.  We can do better by using :pep:`overloading <484#function-method-overloading>` which lets us give the same function multiple type annotations (signatures) to more accurately describe the function's behavior:``\`python from typing import overload

> \# Overload *variants* for 'mouse\_event'. \# These variants give extra information to the type checker. \# They are ignored at runtime.
> 
> @overload def mouse\_event(x1: int, y1: int) -\> ClickEvent: ... @overload def mouse\_event(x1: int, y1: int, x2: int, y2: int) -\> DragEvent: ...
> 
> \# The actual *implementation* of 'mouse\_event'. \# The implementation contains the actual runtime logic. \# \# It may or may not have type hints. If it does, mypy \# will check the body of the implementation against the \# type hints. \# \# Mypy will also check and make sure the signature is \# consistent with the provided variants.
> 
>   - def mouse\_event(x1: int,  
>     y1: int, x2: int | None = None, y2: int | None = None) -\> ClickEvent | DragEvent: if x2 is None and y2 is None: return ClickEvent(x1, y1) elif x2 is not None and y2 is not None: return DragEvent(x1, y1, x2, y2) else: raise TypeError("Bad arguments")

This allows mypy to understand calls to `mouse_event` much more precisely. `` ` For example, mypy will understand that ``mouse\_event(5, 25)`will always have a return type of`ClickEvent`and will report errors for calls like`mouse\_event(5, 25, 2)``.  As another example, suppose we want to write a custom container class that implements the :py`__getitem__ <object.__getitem__>` method (``\[\]`bracket indexing). If this method receives an integer we return a single item. If it receives a`slice``, we return a :py`~collections.abc.Sequence` of items.  We can precisely encode this relationship between the argument and the return type by using overloads like so (Python 3.12 syntax):``\`python from collections.abc import Sequence from typing import overload

>   - class MyList\[T\](Sequence\[T\]):  
>     @overload def \_\_getitem\_\_(self, index: int) -\> T: ...
>     
>     @overload def \_\_getitem\_\_(self, index: slice) -\> Sequence\[T\]: ...
>     
>       - def \_\_getitem\_\_(self, index: int | slice) -\> T | Sequence\[T\]:
>         
>           - if isinstance(index, int):  
>             \# Return a T here
>         
>           - elif isinstance(index, slice):  
>             \# Return a sequence of Ts here
>         
>           - else:  
>             raise TypeError(...)

Here is the same example using the legacy syntax (Python 3.11 and earlier):

``` python
from collections.abc import Sequence
from typing import TypeVar, overload

T = TypeVar('T')

class MyList(Sequence[T]):
    @overload
    def __getitem__(self, index: int) -> T: ...

    @overload
    def __getitem__(self, index: slice) -> Sequence[T]: ...

    def __getitem__(self, index: int | slice) -> T | Sequence[T]:
        if isinstance(index, int):
            # Return a T here
        elif isinstance(index, slice):
            # Return a sequence of Ts here
        else:
            raise TypeError(...)
```

\> **Note** \> If you just need to constrain a type variable to certain types or subtypes, you can use a \[value restriction \<type-variable-value-restriction\>\](\#value-restriction ---\<type-variable-value-restriction\>).

The default values of a function's arguments don't affect its signature -- only `` ` the absence or presence of a default value does. So in order to reduce redundancy, it's possible to replace default values in overload definitions with ``...`as a placeholder:`\`python from typing import overload

> class M: ...
> 
> @overload def get\_model(model\_or\_pk: M, flag: bool = ...) -\> M: ... @overload def get\_model(model\_or\_pk: int, flag: bool = ...) -\> M | None: ...
> 
>   - def get\_model(model\_or\_pk: int | M, flag: bool = True) -\> M | None:  
>     ...

Runtime behavior `` ` ----------------  An overloaded function must consist of two or more overload *variants* followed by an *implementation*. The variants and the implementations must be adjacent in the code: think of them as one indivisible unit.  The variant bodies must all be empty; only the implementation is allowed to contain code. This is because at runtime, the variants are completely ignored: they're overridden by the final implementation function.  This means that an overloaded function is still an ordinary Python function! There is no automatic dispatch handling and you must manually handle the different types in the implementation (e.g. by using ``if``statements and :py`isinstance <isinstance>` checks).  If you are adding an overload within a stub file, the implementation function should be omitted: stubs do not contain runtime logic.  > **Note** >     While we can leave the variant body empty using the``pass`keyword,    the more common convention is to instead use the ellipsis (`...`) literal.  Type checking calls to overloads --------------------------------  When you call an overloaded function, mypy will infer the correct return type by picking the best matching variant, after taking into consideration both the argument types and arity. However, a call is never type checked against the implementation. This is why mypy will report calls like`mouse\_event(5, 25, 3)`as being invalid even though it matches the implementation signature.  If there are multiple equally good matching variants, mypy will select the variant that was defined first. For example, consider the following program:`<span class="title-ref">python \# For Python 3.8 and below you must use \`typing.List</span> instead of <span class="title-ref">list</span>. e.g. \# from typing import List from typing import overload

> @overload def summarize(data: list\[int\]) -\> float: ...
> 
> @overload def summarize(data: list\[str\]) -\> str: ...
> 
>   - def summarize(data):
>     
>       - if not data:  
>         return 0.0
>     
>       - elif isinstance(data\[0\], int):  
>         \# Do int specific code
>     
>       - else:  
>         \# Do str-specific code
> 
> \# What is the type of 'output'? float or str? output = summarize(\[\])

The `summarize([])` call matches both variants: an empty list could `` ` be either a ``list\[int\]`or a`list\[str\]`. In this case, mypy will break the tie by picking the first matching variant:`output`will have an inferred type of`float`. The implementor is responsible for making sure`summarize`breaks ties in the same way at runtime.  However, there are two exceptions to the "pick the first match" rule. First, if multiple variants match due to an argument being of type`Any`, mypy will make the inferred type also be`Any`:`\`python dynamic\_var: Any = some\_dynamic\_function()

> \# output2 is of type 'Any' output2 = summarize(dynamic\_var)

Second, if multiple variants match due to one or more of the arguments `` ` being a union, mypy will make the inferred type be the union of the matching variant returns: ``\`python some\_list: list\[int\] | list\[str\]

> \# output3 is of type 'float | str' output3 = summarize(some\_list)

\> **Note** \> Due to the "pick the first match" rule, changing the order of your overload variants can change how mypy type checks your program.

> To minimize potential issues, we recommend that you:
> 
> 1.  Make sure your overload variants are listed in the same order as the runtime checks (e.g. :py\`isinstance \<isinstance\>\` checks) in your implementation.
> 2.  Order your variants and runtime checks from most to least specific. (See the following section for an example).

Type checking the variants `` ` --------------------------  Mypy will perform several checks on your overload variant definitions to ensure they behave as expected. First, mypy will check and make sure that no overload variant is shadowing a subsequent one. For example, consider the following function which adds together two ``Expression`objects, and contains a special-case to handle receiving two`Literal`types:`\`python from typing import overload

>   - class Expression:  
>     \# ...snip...
> 
>   - class Literal(Expression):  
>     \# ...snip...
> 
> \# Warning -- the first overload variant shadows the second\!
> 
> @overload def add(left: Expression, right: Expression) -\> Expression: ...
> 
> @overload def add(left: Literal, right: Literal) -\> Literal: ...
> 
>   - def add(left: Expression, right: Expression) -\> Expression:  
>     \# ...snip...

While this code snippet is technically type-safe, it does contain an `` ` anti-pattern: the second variant will never be selected! If we try calling ``add(Literal(3), Literal(4))`, mypy will always pick the first variant and evaluate the function call to be of type`Expression`, not`Literal`. This is because`Literal`is a subtype of`Expression`, which means the "pick the first match" rule will always halt after considering the first overload.  Because having an overload variant that can never be matched is almost certainly a mistake, mypy will report an error. To fix the error, we can either 1) delete the second overload or 2) swap the order of the overloads:`\`python \# Everything is ok now -- the variants are correctly ordered \# from most to least specific.

> @overload def add(left: Literal, right: Literal) -\> Literal: ...
> 
> @overload def add(left: Expression, right: Expression) -\> Expression: ...
> 
>   - def add(left: Expression, right: Expression) -\> Expression:  
>     \# ...snip...

Mypy will also type check the different variants and flag any overloads `` ` that have inherently unsafely overlapping variants. For example, consider the following unsafe overload definition: ``\`python from typing import overload

> @overload def unsafe\_func(x: int) -\> int: ...
> 
> @overload def unsafe\_func(x: object) -\> str: ...
> 
>   - def unsafe\_func(x: object) -\> int | str:
>     
>       - if isinstance(x, int):  
>         return 42
>     
>       - else:  
>         return "some string"

On the surface, this function definition appears to be fine. However, it will `` ` result in a discrepancy between the inferred type and the actual runtime type when we try using it like so: ``\`python some\_obj: object = 42 unsafe\_func(some\_obj) + " danger danger" \# Type checks, yet crashes at runtime\!

Since `some_obj` is of type :py\`object\`, mypy will decide that `unsafe_func` `` ` must return something of type ``str`and concludes the above will type check. But in reality,`unsafe\_func`will return an int, causing the code to crash at runtime!  To prevent these kinds of issues, mypy will detect and prohibit inherently unsafely overlapping overloads on a best-effort basis. Two variants are considered unsafely overlapping when both of the following are true:  1. All of the arguments of the first variant are potentially compatible with the second. 2. The return type of the first variant is *not* compatible with (e.g. is not a    subtype of) the second.  So in this example, the`int`argument in the first variant is a subtype of the`object`argument in the second, yet the`int`return type is not a subtype of`str`. Both conditions are true, so mypy will correctly flag`unsafe\_func`as being unsafe.  Note that in cases where you ignore the overlapping overload error, mypy will usually still infer the types you expect at callsites.  However, mypy will not detect *all* unsafe uses of overloads. For example, suppose we modify the above snippet so it calls`summarize`instead of`unsafe\_func`:`\`python some\_list: list\[str\] = \[\] summarize(some\_list) + "danger danger" \# Type safe, yet crashes at runtime\!

We run into a similar issue here. This program type checks if we look just at the `` ` annotations on the overloads. But since ``summarize(...)`is designed to be biased towards returning a float when it receives an empty list, this program will actually crash during runtime.  The reason mypy does not flag definitions like`summarize`as being potentially unsafe is because if it did, it would be extremely difficult to write a safe overload. For example, suppose we define an overload with two variants that accept types`A`and`B`respectively. Even if those two types were completely unrelated, the user could still potentially trigger a runtime error similar to the ones above by passing in a value of some third type`C`that inherits from both`A`and`B`.  Thankfully, these types of situations are relatively rare. What this does mean, however, is that you should exercise caution when designing or using an overloaded function that can potentially receive values that are an instance of two seemingly unrelated types.   Type checking the implementation --------------------------------  The body of an implementation is type-checked against the type hints provided on the implementation. For example, in the`MyList`example up above, the code in the body is checked with argument list`index: int | slice`and a return type of`T | Sequence\[T\]``. If there are no annotations on the implementation, then the body is not type checked. If you want to force mypy to check the body anyways, use the :option:`--check-untyped-defs <mypy --check-untyped-defs>` flag ([more details here <untyped-definitions-and-calls>](#more-details-here-<untyped-definitions-and-calls>)).  The variants must also also be compatible with the implementation type hints. In the``MyList`example, mypy will check that the parameter type`int`and the return type`T`are compatible with`int | slice`and`T | Sequence`for the first variant. For the second variant it verifies the parameter type`slice`and the return type`Sequence\[T\]`are compatible with`int | slice`and`T | Sequence`.  > **Note** >     The overload semantics documented above are new as of mypy 0.620.     Previously, mypy used to perform type erasure on all overload variants. For    example, the`summarize`example from the previous section used to be    illegal because`list\[str\]`and`list\[int\]`both erased to just`list\[Any\]`.    This restriction was removed in mypy 0.620.     Mypy also previously used to select the best matching variant using a different    algorithm. If this algorithm failed to find a match, it would default to returning`Any`. The new algorithm uses the "pick the first match" rule and will fall back    to returning`Any`only if the input arguments also contain`Any``.   Conditional overloads ---------------------  Sometimes it is useful to define overloads conditionally. Common use cases include types that are unavailable at runtime or that only exist in a certain Python version. All existing overload rules still apply. For example, there must be at least two overloads.  > **Note** >      Mypy can only infer a limited number of conditions.     Supported ones currently include :py`~typing.TYPE_CHECKING`,``MYPY``,     [version_and_platform_checks](#version_and_platform_checks), :option:`--always-true <mypy --always-true>`,     and :option:`--always-false <mypy --always-false>` values.``\`python from typing import TYPE\_CHECKING, Any, overload

>   - if TYPE\_CHECKING:  
>     class A: ... class B: ...
> 
>   - if TYPE\_CHECKING:  
>     @overload def func(var: A) -\> A: ...
>     
>     @overload def func(var: B) -\> B: ...
> 
>   - def func(var: Any) -\> Any:  
>     return var
> 
> reveal\_type(func(A())) \# Revealed type is "A"

``` python
# flags: --python-version 3.10
import sys
from typing import Any, overload

class A: ...
class B: ...
class C: ...
class D: ...

if sys.version_info < (3, 7):
    @overload
    def func(var: A) -> A: ...

elif sys.version_info >= (3, 10):
    @overload
    def func(var: B) -> B: ...

else:
    @overload
    def func(var: C) -> C: ...

@overload
def func(var: D) -> D: ...

def func(var: Any) -> Any:
    return var

reveal_type(func(B()))  # Revealed type is "B"
reveal_type(func(C()))  # No overload variant of "func" matches argument type "C"
    # Possible overload variants:
    #     def func(var: B) -> B
    #     def func(var: D) -> D
    # Revealed type is "Any"
```

<div class="note">

<div class="title">

Note

</div>

In the last example, mypy is executed with `--python-version 3.10 <mypy --python-version>`. Therefore, the condition `sys.version_info >= (3, 10)` will match and the overload for `B` will be added. The overloads for `A` and `C` are ignored\! The overload for `D` is not defined conditionally and thus is also added.

</div>

When mypy cannot infer a condition to be always `True` or always `False`, `` ` an error is emitted. ``\`python from typing import Any, overload

> class A: ... class B: ...
> 
>   - def g(bool\_var: bool) -\> None:
>     
>       - if bool\_var: \# Condition can't be inferred, unable to merge overloads  
>         @overload def func(var: A) -\> A: ...
>         
>         @overload def func(var: B) -\> B: ...
>     
>     def func(var: Any) -\> Any: ...
>     
>     reveal\_type(func(A())) \# Revealed type is "Any"

<div id="advanced_self">

Advanced uses of self-types `` ` ***************************  Normally, mypy doesn't require annotations for the first arguments of instance and class methods. However, they may be needed to have more precise static typing for certain programming patterns.  Restricted methods in generic classes -------------------------------------  In generic classes some methods may be allowed to be called only for certain values of type arguments (Python 3.12 syntax): ``\`python class Tag\[T\]: item: T

</div>

>   - def uppercase\_item(self: Tag\[str\]) -\> str:  
>     return self.item.upper()
> 
> def label(ti: Tag\[int\], ts: Tag\[str\]) -\> None: ti.uppercase\_item() \# E: Invalid self argument "Tag\[int\]" to attribute function \# "uppercase\_item" with type "Callable\[\[Tag\[str\]\], str\]" ts.uppercase\_item() \# This is OK

This pattern also allows matching on nested types in situations where the type `` ` argument is itself generic (Python 3.12 syntax): ``\`python from collections.abc import Sequence

>   - class Storage\[T\]:
>     
>       - def \_\_init\_\_(self, content: T) -\> None:  
>         self.\_content = content
>     
>       - def first\_chunk\[S\](self: Storage\[Sequence\[S\]\]) -\> S:  
>         return self.\_content\[0\]
> 
> page: Storage\[list\[str\]\] page.first\_chunk() \# OK, type is "str"
> 
>   - Storage(0).first\_chunk() \# Error: Invalid self argument "Storage\[int\]" to attribute function  
>     \# "first\_chunk" with type "Callable\[\[Storage\[Sequence\[S\]\]\], S\]"

Finally, one can use overloads on self-type to express precise types of `` ` some tricky methods (Python 3.12 syntax): ``\`python from collections.abc import Callable from typing import overload

>   - class Tag\[T\]:  
>     @overload def export(self: Tag\[str\]) -\> str: ... @overload def export(self, converter: Callable\[\[T\], str\]) -\> str: ...
>     
>       - def export(self, converter=None):
>         
>           - if isinstance(self.item, str):  
>             return self.item
>         
>         return converter(self.item)

  - In particular, an :py\`\~object.\_\_init\_\_<span class="title-ref"> method overloaded on self-type </span>``may be useful to annotate generic class constructors where type arguments depend on constructor parameters in a non-trivial way, see e.g. :py`~subprocess.Popen`.  Mixin classes -------------  Using host class protocol as a self-type in mixin methods allows more code re-usability for static typing of mixin classes. For example, one can define a protocol that defines common functionality for host classes instead of adding required abstract methods to every mixin:``\`python
    
      - class Lockable(Protocol):  
        @property def lock(self) -\> Lock: ...
    
      - class AtomicCloseMixin:
        
          - def atomic\_close(self: Lockable) -\> int:
            
              - with self.lock:  
                \# perform actions
    
      - class AtomicOpenMixin:
        
          - def atomic\_open(self: Lockable) -\> int:
            
              - with self.lock:  
                \# perform actions
    
      - class File(AtomicCloseMixin, AtomicOpenMixin):
        
          - def \_\_init\_\_(self) -\> None:  
            self.lock = Lock()
    
      - class Bad(AtomicCloseMixin):  
        pass
    
    f = File() b: Bad f.atomic\_close() \# OK b.atomic\_close() \# Error: Invalid self type for "atomic\_close"

Note that the explicit self-type is *required* to be a protocol whenever it `` ` is not a supertype of the current class. In this case mypy will check the validity of the self-type only at the call site.  Precise typing of alternative constructors ------------------------------------------  Some classes may define alternative constructors. If these classes are generic, self-type allows giving them precise signatures (Python 3.12 syntax): ``\`python from typing import Self

>   - class Base\[T\]:
>     
>       - def \_\_init\_\_(self, item: T) -\> None:  
>         self.item = item
>     
>     @classmethod def make\_pair(cls, item: T) -\> tuple\[Self, Self\]: return cls(item), cls(item)
> 
>   - class Sub\[T\](Base\[T\]):  
>     ...
> 
> pair = Sub.make\_pair('yes') \# Type is "tuple\[Sub\[str\], Sub\[str\]\]" bad = Sub\[int\].make\_pair('no') \# Error: Argument 1 to "make\_pair" of "Base" \# has incompatible type "str"; expected "int"

<div id="async-and-await">

Typing async/await `` ` ******************  Mypy lets you type coroutines that use the ``async/await``syntax. For more information regarding coroutines, see :pep:`492` and the `asyncio documentation <python:library/asyncio>`_.  Functions defined using``async def`are typed similar to normal functions. The return type annotation should be the same as the type of the value you expect to get back when`await`-ing the coroutine.`\`python import asyncio

</div>

>   - async def format\_string(tag: str, count: int) -\> str:  
>     return f'T-minus {count} ({tag})'
> 
>   - async def countdown(tag: str, count: int) -\> str:
>     
>       - while count \> 0:  
>         my\_str = await format\_string(tag, count) \# type is inferred to be str print(my\_str) await asyncio.sleep(0.1) count -= 1
>     
>     return "Blastoff\!"
> 
> asyncio.run(countdown("Millennium Falcon", 5))

The result of calling an `async def` function *without awaiting* will `` ` automatically be inferred to be a value of type :py`Coroutine[Any, Any, T] <collections.abc.Coroutine>`, which is a subtype of :py`Awaitable[T] <collections.abc.Awaitable>`: ``\`python my\_coroutine = countdown("Millennium Falcon", 5) reveal\_type(my\_coroutine) \# Revealed type is "typing.Coroutine\[Any, Any, builtins.str\]"

<div id="async-iterators">

Asynchronous iterators `` ` ----------------------  If you have an asynchronous iterator, you can use the :py`~collections.abc.AsyncIterator` type in your annotations: ``\`python from collections.abc import AsyncIterator from typing import Optional import asyncio

</div>

>   - class arange:
>     
>       - def \_\_init\_\_(self, start: int, stop: int, step: int) -\> None:  
>         self.start = start self.stop = stop self.step = step self.count = start - step
>     
>       - def \_\_aiter\_\_(self) -\> AsyncIterator\[int\]:  
>         return self
>     
>       - async def \_\_anext\_\_(self) -\> int:  
>         self.count += self.step if self.count == self.stop: raise StopAsyncIteration else: return self.count
> 
>   - async def run\_countdown(tag: str, countdown: AsyncIterator\[int\]) -\> str:
>     
>       - async for i in countdown:  
>         print(f'T-minus {i} ({tag})') await asyncio.sleep(0.1)
>     
>     return "Blastoff\!"
> 
> asyncio.run(run\_countdown("Serenity", arange(5, 0, -1)))

Async generators (introduced in `525`) are an easy way to create `` ` async iterators: ``\`python from collections.abc import AsyncGenerator from typing import Optional import asyncio

> \# Could also type this as returning AsyncIterator\[int\] async def arange(start: int, stop: int, step: int) -\> AsyncGenerator\[int, None\]: current = start while (step \> 0 and current \< stop) or (step \< 0 and current \> stop): yield current current += step
> 
> asyncio.run(run\_countdown("Battlestar Galactica", arange(5, 0, -1)))

One common confusion is that the presence of a `yield` statement in an `` ` ``async def`function has an effect on the type of the function:`\`python from collections.abc import AsyncIterator

>   - async def arange(stop: int) -\> AsyncIterator\[int\]:  
>     \# When called, arange gives you an async iterator \# Equivalent to Callable\[\[int\], AsyncIterator\[int\]\] i = 0 while i \< stop: yield i i += 1
> 
>   - async def coroutine(stop: int) -\> AsyncIterator\[int\]:  
>     \# When called, coroutine gives you something you can await to get an async iterator \# Equivalent to Callable\[\[int\], Coroutine\[Any, Any, AsyncIterator\[int\]\]\] return arange(stop)
> 
>   - async def main() -\> None:  
>     reveal\_type(arange(5)) \# Revealed type is "typing.AsyncIterator\[builtins.int\]" reveal\_type(coroutine(5)) \# Revealed type is "typing.Coroutine\[Any, Any, typing.AsyncIterator\[builtins.int\]\]"
>     
>     await arange(5) \# Error: Incompatible types in "await" (actual type "AsyncIterator\[int\]", expected type "Awaitable\[Any\]") reveal\_type(await coroutine(5)) \# Revealed type is "typing.AsyncIterator\[builtins.int\]"

This can sometimes come up when trying to define base classes, Protocols or overloads:

``` python
from collections.abc import AsyncIterator
from typing import Protocol, overload

class LauncherIncorrect(Protocol):
    # Because launch does not have yield, this has type
    # Callable[[], Coroutine[Any, Any, AsyncIterator[int]]]
    # instead of
    # Callable[[], AsyncIterator[int]]
    async def launch(self) -> AsyncIterator[int]:
        raise NotImplementedError

class LauncherCorrect(Protocol):
    def launch(self) -> AsyncIterator[int]:
        raise NotImplementedError

class LauncherAlsoCorrect(Protocol):
    async def launch(self) -> AsyncIterator[int]:
        raise NotImplementedError
        if False:
            yield 0

# The type of the overloads is independent of the implementation.
# In particular, their type is not affected by whether or not the
# implementation contains a `yield`.
# Use of `def`` makes it clear the type is Callable[..., AsyncIterator[int]],
# whereas with `async def` it would be Callable[..., Coroutine[Any, Any, AsyncIterator[int]]]
@overload
def launch(*, count: int = ...) -> AsyncIterator[int]: ...
@overload
def launch(*, time: float = ...) -> AsyncIterator[int]: ...

async def launch(*, count: int = 0, time: float = 0) -> AsyncIterator[int]:
    # The implementation of launch is an async generator and contains a yield
    yield 0
```

\`\`\`

---

mypy_daemon.md

---

<div id="mypy_daemon">

<div class="program">

dmypy

</div>

</div>

# Mypy daemon (mypy server)

Instead of running mypy as a command-line tool, you can also run it as a long-running daemon (server) process and use a command-line client to send type-checking requests to the server. This way mypy can perform type checking much faster, since program state cached from previous runs is kept in memory and doesn't have to be read from the file system on each run. The server also uses finer-grained dependency tracking to reduce the amount of work that needs to be done.

If you have a large codebase to check, running mypy using the mypy daemon can be *10 or more times faster* than the regular command-line `mypy` tool, especially if your workflow involves running mypy repeatedly after small edits -- which is often a good idea, as this way you'll find errors sooner.

\> **Note** \> The command-line interface of mypy daemon may change in future mypy releases.

<div class="note">

<div class="title">

Note

</div>

Each mypy daemon process supports one user and one set of source files, and it can only process one type checking request at a time. You can run multiple mypy daemon processes to type check multiple repositories.

</div>

## Basic usage

The client utility `dmypy` is used to control the mypy daemon. Use `dmypy run -- <flags> <files>` to type check a set of files (or directories). This will launch the daemon if it is not running. You can use almost arbitrary mypy flags after `--`. The daemon will always run on the current host. Example:

    dmypy run -- prog.py pkg/*.py

`dmypy run` will automatically restart the daemon if the configuration or mypy version changes.

The initial run will process all the code and may take a while to finish, but subsequent runs will be quick, especially if you've only changed a few files. (You can use \[remote caching \<remote-cache\>\](\#remote-caching-\<remote-cache\>) to speed up the initial run. The speedup can be significant if you have a large codebase.)

\> **Note** \> Mypy 0.780 added support for following imports in dmypy (enabled by default). This functionality is still experimental. You can use `--follow-imports=skip` or `--follow-imports=error` to fall back to the stable functionality. See \[follow-imports\](\#follow-imports) for details on how these work.

<div class="note">

<div class="title">

Note

</div>

The mypy daemon requires `--local-partial-types` and automatically enables it.

</div>

## Daemon client commands

While `dmypy run` is sufficient for most uses, some workflows (ones using \[remote caching \<remote-cache\>\](\#remote-caching-\<remote-cache\>), perhaps), require more precise control over the lifetime of the daemon process:

  - `dmypy stop` stops the daemon.
  - `dmypy start -- <flags>` starts the daemon but does not check any files. You can use almost arbitrary mypy flags after `--`.
  - `dmypy restart -- <flags>` restarts the daemon. The flags are the same as with `dmypy start`. This is equivalent to a stop command followed by a start.
  - Use `dmypy run --timeout SECONDS -- <flags>` (or `start` or `restart`) to automatically shut down the daemon after inactivity. By default, the daemon runs until it's explicitly stopped.
  - `dmypy check <files>` checks a set of files using an already running daemon.
  - `dmypy recheck` checks the same set of files as the most recent `check` or `recheck` command. (You can also use the `--update` and `--remove` options to alter the set of files, and to define which files should be processed.)
  - `dmypy status` checks whether a daemon is running. It prints a diagnostic and exits with `0` if there is a running daemon.

Use `dmypy --help` for help on additional commands and command-line options not discussed here, and `dmypy <command> --help` for help on command-specific options.

## Additional daemon flags

<div class="option">

\--status-file FILE

Use `FILE` as the status file for storing daemon runtime state. This is normally a JSON file that contains information about daemon process and connection. The default path is `.dmypy.json` in the current working directory.

</div>

<div class="option">

\--log-file FILE

Direct daemon stdout/stderr to `FILE`. This is useful for debugging daemon crashes, since the server traceback is not always printed by the client. This is available for the `start`, `restart`, and `run` commands.

</div>

<div class="option">

\--timeout TIMEOUT

Automatically shut down server after `TIMEOUT` seconds of inactivity. This is available for the `start`, `restart`, and `run` commands.

</div>

<div class="option">

\--update FILE

Re-check `FILE`, or add it to the set of files being checked (and check it). This option may be repeated, and it's only available for the `recheck` command. By default, mypy finds and checks all files changed since the previous run and files that depend on them. However, if you use this option (and/or `--remove`), mypy assumes that only the explicitly specified files have changed. This is only useful to speed up mypy if you type check a very large number of files, and use an external, fast file system watcher, such as [watchman](https://facebook.github.io/watchman/) or [watchdog](), to determine which files got edited or deleted. *Note:* This option is never required and is only available for performance tuning.

</div>

<div class="option">

\--remove FILE

Remove `FILE` from the set of files being checked. This option may be repeated. This is only available for the `recheck` command. See `--update` above for when this may be useful. *Note:* This option is never required and is only available for performance tuning.

</div>

<div class="option">

\--fswatcher-dump-file FILE

Collect information about the current internal file state. This is only available for the `status` command. This will dump JSON to `FILE` in the format `{path: [modification_time, size, content_hash]}`. This is useful for debugging the built-in file system watcher. *Note:* This is an internal flag and the format may change.

</div>

<div class="option">

\--perf-stats-file FILE

Write performance profiling information to `FILE`. This is only available for the `check`, `recheck`, and `run` commands.

</div>

<div class="option">

\--export-types

Store all expression types in memory for future use. This is useful to speed up future calls to `dmypy inspect` (but uses more memory). Only valid for `check`, `recheck`, and `run` command.

</div>

## Static inference of annotations

The mypy daemon supports (as an experimental feature) statically inferring draft function and method type annotations. Use `dmypy suggest FUNCTION` to generate a draft signature in the format `(param_type_1, param_type_2, ...) -> ret_type` (types are included for all arguments, including keyword-only arguments, `*args` and `**kwargs`).

This is a low-level feature intended to be used by editor integrations, IDEs, and other tools (for example, the [mypy plugin for PyCharm]()), to automatically add annotations to source files, or to propose function signatures.

In this example, the function `format_id()` has no annotation:

`` `python    def format_id(user):        return f"User: {user}"     root = format_id(0) ``dmypy suggest`uses call sites, return statements, and other heuristics (such as`<span class="title-ref"> looking for signatures in base classes) to infer that </span><span class="title-ref">format\_id()</span><span class="title-ref"> accepts an </span><span class="title-ref">int</span><span class="title-ref"> argument and returns a </span><span class="title-ref">str</span><span class="title-ref">. Use </span><span class="title-ref">dmypy suggest module.format\_id</span>\` to print the suggested signature for the function.

More generally, the target function may be specified in two ways:

  - By its fully qualified name, i.e. `[package.]module.[class.]function`.
  - By its location in a source file, i.e. `/path/to/file.py:line`. The path can be absolute or relative, and `line` can refer to any line number within the function body.

This command can also be used to find a more precise alternative for an existing, imprecise annotation with some `Any` types.

The following flags customize various aspects of the `dmypy suggest` command.

<div class="option">

\--json

Output the signature as JSON, so that [PyAnnotate]() can read it and add the signature to the source file. Here is what the JSON looks like:

  - \`\`\`python
    
      - \[{"func\_name": "example.format\_id",  
        "line": 1, "path": "/absolute/path/to/example.py", "samples": 0, "signature": {"arg\_types": \["int"\], "return\_type": "str"}}\]

</div>

<div class="option">

\--no-errors

Only produce suggestions that cause no errors in the checked code. By default, mypy will try to find the most precise type, even if it causes some type errors.

</div>

<div class="option">

\--no-any

Only produce suggestions that don't contain `Any` types. By default mypy proposes the most precise signature found, even if it contains `Any` types.

</div>

<div class="option">

\--flex-any FRACTION

Only allow some fraction of types in the suggested signature to be `Any` types. The fraction ranges from `0` (same as `--no-any`) to `1`.

</div>

<div class="option">

\--callsites

Only find call sites for a given function instead of suggesting a type. This will produce a list with line numbers and types of actual arguments for each call: `/path/to/file.py:line: (arg_type_1, arg_type_2, ...)`.

</div>

<div class="option">

\--use-fixme NAME

Use a dummy name instead of plain `Any` for types that cannot be inferred. This may be useful to emphasize to a user that a given type couldn't be inferred and needs to be entered manually.

</div>

<div class="option">

\--max-guesses NUMBER

Set the maximum number of types to try for a function (default: `64`).

</div>

Statically inspect expressions `` ` ******************************  The daemon allows to get declared or inferred type of an expression (or other information about an expression, such as known attributes or definition location) using ``dmypy inspect LOCATION`command. The location of the expression should be specified in the format`path/to/file.py:line:column\[:end\_line:end\_column\]`. Both line and column are 1-based. Both start and end position are inclusive. These rules match how mypy prints the error location in error messages.  If a span is given (i.e. all 4 numbers), then only an exactly matching expression is inspected. If only a position is given (i.e. 2 numbers, line and column), mypy will inspect all *expressions*, that include this position, starting from the innermost one.  Consider this Python code snippet:`\`python def foo(x: int, longer\_name: str) -\> None: x longer\_name

Here to find the type of `x` one needs to call `dmypy inspect src.py:2:5:2:5` `` ` or ``dmypy inspect src.py:2:5`. While for`longer\_name`one needs to call`dmypy inspect src.py:3:5:3:15`or, for example,`dmypy inspect src.py:3:10`. Please note that this command is only valid after daemon had a successful type check (without parse errors), so that types are populated, e.g. using`dmypy check``. In case where multiple expressions match the provided location, their types are returned separated by a newline.  Important note: it is recommended to check files with :option:`--export-types` since otherwise most inspections will not work without :option:`--force-reload`.  .. option:: --show INSPECTION     What kind of inspection to run for expression(s) found. Currently the supported    inspections are:     *``type`(default): Show the best known type of a given expression.    *`attrs`: Show which attributes are valid for an expression (e.g. for      auto-completion). Format is`{"Base1": \["name\_1", "name\_2", ...\]; "Base2": ...}`.      Names are sorted by method resolution order. If expression refers to a module,      then module attributes will be under key like`"\<full.module.name\>"`.    *`definition`(experimental): Show the definition location for a name      expression or member expression. Format is`path/to/file.py:line:column:Symbol`.      If multiple definitions are found (e.g. for a Union attribute), they are      separated by comma.  .. option:: --verbose     Increase verbosity of types string representation (can be repeated).    For example, this will print fully qualified names of instance types (like`"builtins.str"`), instead of just a short name (like`"str"`).  .. option:: --limit NUM     If the location is given as`line:column`, this will cause daemon to    return only at most`NUM`inspections of innermost expressions.    Value of 0 means no limit (this is the default). For example, if one calls`dmypy inspect src.py:4:10 --limit=1`with this code`\`python def foo(x: int) -\> str: .. def bar(x: str) -\> None: ... baz: int bar(foo(baz))

> This will output just one type `"int"` (for `baz` name expression). While without the limit option, it would output all three types: `"int"`, `"str"`, and `"None"`.

<div class="option">

\--include-span

With this option on, the daemon will prepend each inspection result with the full span of corresponding expression, formatted as `1:2:1:4 -> "int"`. This may be useful in case multiple expressions match a location.

</div>

<div class="option">

\--include-kind

With this option on, the daemon will prepend each inspection result with the kind of corresponding expression, formatted as `NameExpr -> "int"`. If both this option and `--include-span` are on, the kind will appear first, for example `NameExpr:1:2:1:4 -> "int"`.

</div>

<div class="option">

\--include-object-attrs

This will make the daemon include attributes of `object` (excluded by default) in case of an `atts` inspection.

</div>

<div class="option">

\--union-attrs

Include attributes valid for some of possible expression types (by default an intersection is returned). This is useful for union types of type variables with values. For example, with this code:

``` python
from typing import Union

class A:
    x: int
    z: int
class B:
    y: int
    z: int
var: Union[A, B]
var
```

The command `dmypy inspect --show attrs src.py:10:1` will return `{"A": ["z"], "B": ["z"]}`, while with `--union-attrs` it will return `{"A": ["x", "z"], "B": ["y", "z"]}`.

</div>

<div class="option">

\--force-reload

Force re-parsing and re-type-checking file before inspection. By default this is done only when needed (for example file was not loaded from cache or daemon was initially run without `--export-types` mypy option), since reloading may be slow (up to few seconds for very large files).

</div>

\`\`\` .. \_watchdog: <https://pypi.org/project/watchdog/> .. \_PyAnnotate: <https://github.com/dropbox/pyannotate> .. \_mypy plugin for PyCharm: <https://github.com/dropbox/mypy-PyCharm-plugin>

---

protocols.md

---

# Protocols and structural subtyping

The Python type system supports two ways of deciding whether two objects are compatible as types: nominal subtyping and structural subtyping.

*Nominal* subtyping is strictly based on the class hierarchy. If class `Dog` inherits class `Animal`, it's a subtype of `Animal`. Instances of `Dog` can be used when `Animal` instances are expected. This form of subtyping is what Python's type system predominantly uses: it's easy to understand and produces clear and concise error messages, and matches how the native :py\`isinstance \<isinstance\>\` check works -- based on class hierarchy.

*Structural* subtyping is based on the operations that can be performed with an object. Class `Dog` is a structural subtype of class `Animal` if the former has all attributes and methods of the latter, and with compatible types.

Structural subtyping can be seen as a static equivalent of duck typing, which is well known to Python programmers. See `544` for the detailed specification of protocols and structural subtyping in Python.

## Predefined protocols

The :py`collections.abc`, :py`typing` and other stdlib modules define various protocol classes that correspond to common Python protocols, such as :py\`Iterable\[T\] \<collections.abc.Iterable\><span class="title-ref">. If a class defines a suitable :py</span>\_\_iter\_\_ \<object.\_\_iter\_\_\><span class="title-ref"> method, mypy understands that it implements the iterable protocol and is compatible with :py\`Iterable\[T\] \<collections.abc.Iterable\></span>. For example, `IntList` below is iterable, over `int` values:

`` `python    from __future__ import annotations     from collections.abc import Iterator, Iterable     class IntList:        def __init__(self, value: int, next: IntList | None) -> None:            self.value = value            self.next = next         def __iter__(self) -> Iterator[int]:            current = self            while current:                yield current.value                current = current.next     def print_numbered(items: Iterable[int]) -> None:        for n, x in enumerate(items):            print(n + 1, x)     x = IntList(3, IntList(5, None))    print_numbered(x)  # OK    print_numbered([4, 5])  # Also OK  [predefined_protocols_reference](#predefined_protocols_reference) lists various protocols defined in ``<span class="title-ref"> :py:mod:\`collections.abc</span> and :py`typing` and the signatures of the corresponding methods you need to define to implement each protocol.

<div class="note">

<div class="title">

Note

</div>

`typing` also contains deprecated aliases to protocols and ABCs defined in :py`collections.abc`, such as :py\`Iterable\[T\] \<typing.Iterable\><span class="title-ref">. These are only necessary in Python 3.8 and earlier, since the protocols in </span><span class="title-ref">collections.abc</span><span class="title-ref"> didn't yet support subscripting (</span><span class="title-ref">\[\]</span><span class="title-ref">) in Python 3.8, but the aliases in </span><span class="title-ref">typing</span><span class="title-ref"> have always supported subscripting. In Python 3.9 and later, the aliases in </span><span class="title-ref">typing</span>\` don't provide any extra functionality.

</div>

## Simple user-defined protocols

You can define your own protocol class by inheriting the special `Protocol` class:

`` `python    from collections.abc import Iterable    from typing import Protocol     class SupportsClose(Protocol):        # Empty method body (explicit '...')        def close(self) -> None: ...     class Resource:  # No SupportsClose base class!         def close(self) -> None:           self.resource.release()         # ... other methods ...     def close_all(items: Iterable[SupportsClose]) -> None:        for item in items:            item.close()     close_all([Resource(), open('some/file')])  # OK ``Resource`is a subtype of the`SupportsClose`protocol since it defines`<span class="title-ref"> a compatible </span><span class="title-ref">close</span><span class="title-ref"> method. Regular file objects returned by :py\`open</span> are similarly compatible with the protocol, as they support `close()`.

## Defining subprotocols and subclassing protocols

You can also define subprotocols. Existing protocols can be extended and merged using multiple inheritance. Example:

`` `python    # ... continuing from the previous example     class SupportsRead(Protocol):        def read(self, amount: int) -> bytes: ...     class TaggedReadableResource(SupportsClose, SupportsRead, Protocol):        label: str     class AdvancedResource(Resource):        def __init__(self, label: str) -> None:            self.label = label         def read(self, amount: int) -> bytes:            # some implementation            ...     resource: TaggedReadableResource    resource = AdvancedResource('handle with care')  # OK  Note that inheriting from an existing protocol does not automatically ``<span class="title-ref"> turn the subclass into a protocol -- it just creates a regular (non-protocol) class or ABC that implements the given protocol (or protocols). The </span><span class="title-ref">Protocol</span>\` base class must always be explicitly present if you are defining a protocol:

`` `python    class NotAProtocol(SupportsClose):  # This is NOT a protocol        new_attr: int     class Concrete:       new_attr: int = 0        def close(self) -> None:           ...     # Error: nominal subtyping used by default    x: NotAProtocol = Concrete()  # Error!  You can also include default implementations of methods in ``\` protocols. If you explicitly subclass these protocols you can inherit these default implementations.

Explicitly including a protocol as a base class is also a way of documenting that your class implements a particular protocol, and it forces mypy to verify that your class implementation is actually compatible with the protocol. In particular, omitting a value for an attribute or a method body will make it implicitly abstract:

`` `python    class SomeProto(Protocol):        attr: int  # Note, no right hand side        def method(self) -> str: ...  # Literally just ... here     class ExplicitSubclass(SomeProto):        pass     ExplicitSubclass()  # error: Cannot instantiate abstract class 'ExplicitSubclass'                        # with abstract attributes 'attr' and 'method'  Similarly, explicitly assigning to a protocol instance can be a way to ask the ``\` type checker to verify that your class implements a protocol:

`` `python    _proto: SomeProto = cast(ExplicitSubclass, None)  Invariance of protocol attributes ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

A common issue with protocols is that protocol attributes are invariant. For example:

`` `python    class Box(Protocol):          content: object     class IntBox:          content: int     def takes_box(box: Box) -> None: ...     takes_box(IntBox())  # error: Argument 1 to "takes_box" has incompatible type "IntBox"; expected "Box"                         # note:  Following member(s) of "IntBox" have conflicts:                         # note:      content: expected "object", got "int"  This is because ``Box`defines`content`as a mutable attribute.`\` Here's why this is problematic:

`` `python    def takes_box_evil(box: Box) -> None:        box.content = "asdf"  # This is bad, since box.content is supposed to be an object     my_int_box = IntBox()    takes_box_evil(my_int_box)    my_int_box.content + 1  # Oops, TypeError!  This can be fixed by declaring ``content`to be read-only in the`Box`  `<span class="title-ref"> protocol using </span><span class="title-ref">@property</span>\`:

`` `python    class Box(Protocol):        @property        def content(self) -> object: ...     class IntBox:        content: int     def takes_box(box: Box) -> None: ...     takes_box(IntBox(42))  # OK  Recursive protocols ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

Protocols can be recursive (self-referential) and mutually recursive. This is useful for declaring abstract recursive collections such as trees and linked lists:

`` `python    from __future__ import annotations     from typing import Protocol     class TreeLike(Protocol):        value: int         @property        def left(self) -> TreeLike | None: ...         @property        def right(self) -> TreeLike | None: ...     class SimpleTree:        def __init__(self, value: int) -> None:            self.value = value            self.left: SimpleTree | None = None            self.right: SimpleTree | None = None     root: TreeLike = SimpleTree(0)  # OK  Using isinstance() with protocols ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

You can use a protocol class with :py\`isinstance\` if you decorate it with the `@runtime_checkable` class decorator. The decorator adds rudimentary support for runtime structural checks:

`` `python    from typing import Protocol, runtime_checkable     @runtime_checkable    class Portable(Protocol):        handles: int     class Mug:        def __init__(self) -> None:            self.handles = 1     def use(handles: int) -> None: ...     mug = Mug()    if isinstance(mug, Portable):  # Works at runtime!       use(mug.handles)  :py`isinstance` also works with the [predefined protocols <predefined_protocols>](#predefined-protocols-<predefined_protocols>) ``<span class="title-ref"> in :py:mod:\`typing</span> such as :py\`\~typing.Iterable\`.

<div class="warning">

<div class="title">

Warning

</div>

:py\`isinstance\` with protocols is not completely safe at runtime. For example, signatures of methods are not checked. The runtime implementation only checks that all protocol members exist, not that they have the correct type. :py\`issubclass\` with protocols will only check for the existence of methods.

</div>

<div class="note">

<div class="title">

Note

</div>

:py\`isinstance\` with protocols can also be surprisingly slow. In many cases, you're better served by using :py\`hasattr\` to check for the presence of attributes.

</div>

## Callback protocols

Protocols can be used to define flexible callback types that are hard (or even impossible) to express using the :py\`Callable\[...\] \<collections.abc.Callable\><span class="title-ref"> syntax, such as variadic, overloaded, and complex generic callbacks. They are defined with a special :py</span>\_\_call\_\_ \<object.\_\_call\_\_\>\` member:

`` `python    from collections.abc import Iterable    from typing import Optional, Protocol     class Combiner(Protocol):        def __call__(self, *vals: bytes, maxlen: int | None = None) -> list[bytes]: ...     def batch_proc(data: Iterable[bytes], cb_results: Combiner) -> bytes:        for item in data:            ...     def good_cb(*vals: bytes, maxlen: int | None = None) -> list[bytes]:        ...    def bad_cb(*vals: bytes, maxitems: int | None) -> list[bytes]:        ...     batch_proc([], good_cb)  # OK    batch_proc([], bad_cb)   # Error! Argument 2 has incompatible type because of                             # different name and kind in the callback  Callback protocols and :py`~collections.abc.Callable` types can be used mostly interchangeably. ``<span class="title-ref"> Parameter names in :py</span>\_\_call\_\_ \<object.\_\_call\_\_\>\` methods must be identical, unless the parameters are positional-only. Example (using the legacy syntax for generic functions):

`` `python    from collections.abc import Callable    from typing import Protocol, TypeVar     T = TypeVar('T')     class Copy(Protocol):        # '/' marks the end of positional-only parameters        def __call__(self, origin: T, /) -> T: ...     copy_a: Callable[[T], T]    copy_b: Copy     copy_a = copy_b  # OK    copy_b = copy_a  # Also OK  .. _predefined_protocols_reference:  Predefined protocol reference ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

### Iteration protocols

The iteration protocols are useful in many contexts. For example, they allow iteration of objects in for loops.

#### collections.abc.Iterable\[T\]

The \[example above \<predefined\_protocols\>\](\#example-above-\<predefined\_protocols\>) has a simple implementation of an :py\`\_\_iter\_\_ \<object.\_\_iter\_\_\>\` method.

`` `python    def __iter__(self) -> Iterator[T]  See also :py`~collections.abc.Iterable`.  collections.abc.Iterator[T] ``\` ---------------------------

`` `python    def __next__(self) -> T    def __iter__(self) -> Iterator[T]  See also :py`~collections.abc.Iterator`.  Collection protocols ``\` ....................

Many of these are implemented by built-in container types such as :py\`list\` and :py\`dict\`, and these are also useful for user-defined collection objects.

#### collections.abc.Sized

This is a type for objects that support :py\`len(x) \<len\>\`.

`` `python    def __len__(self) -> int  See also :py`~collections.abc.Sized`.  collections.abc.Container[T] ``\` ----------------------------

This is a type for objects that support the `in` operator.

`` `python    def __contains__(self, x: object) -> bool  See also :py`~collections.abc.Container`.  collections.abc.Collection[T] ``\` -----------------------------

`` `python    def __len__(self) -> int    def __iter__(self) -> Iterator[T]    def __contains__(self, x: object) -> bool  See also :py`~collections.abc.Collection`.  One-off protocols ``\` .................

These protocols are typically only useful with a single standard library function or class.

#### collections.abc.Reversible\[T\]

This is a type for objects that support :py\`reversed(x) \<reversed\>\`.

`` `python    def __reversed__(self) -> Iterator[T]  See also :py`~collections.abc.Reversible`.  typing.SupportsAbs[T] ``\` ---------------------

This is a type for objects that support :py\`abs(x) \<abs\><span class="title-ref">. </span><span class="title-ref">T</span><span class="title-ref"> is the type of value returned by :py\`abs(x) \<abs\></span>.

`` `python    def __abs__(self) -> T  See also :py`~typing.SupportsAbs`.  typing.SupportsBytes ``\` --------------------

This is a type for objects that support :py\`bytes(x) \<bytes\>\`.

`` `python    def __bytes__(self) -> bytes  See also :py`~typing.SupportsBytes`.  .. _supports-int-etc:  typing.SupportsComplex ``\` ----------------------

This is a type for objects that support :py\`complex(x) \<complex\>\`. Note that no arithmetic operations are supported.

`` `python    def __complex__(self) -> complex  See also :py`~typing.SupportsComplex`.  typing.SupportsFloat ``\` --------------------

This is a type for objects that support :py\`float(x) \<float\>\`. Note that no arithmetic operations are supported.

`` `python    def __float__(self) -> float  See also :py`~typing.SupportsFloat`.  typing.SupportsInt ``\` ------------------

This is a type for objects that support :py\`int(x) \<int\>\`. Note that no arithmetic operations are supported.

`` `python    def __int__(self) -> int  See also :py`~typing.SupportsInt`.  typing.SupportsRound[T] ``\` -----------------------

This is a type for objects that support :py\`round(x) \<round\>\`.

`` `python    def __round__(self) -> T  See also :py`~typing.SupportsRound`.  Async protocols ``\` ...............

These protocols can be useful in async code. See \[async-and-await\](\#async-and-await) for more information.

#### collections.abc.Awaitable\[T\]

`` `python    def __await__(self) -> Generator[Any, None, T]  See also :py`~collections.abc.Awaitable`.  collections.abc.AsyncIterable[T] ``\` --------------------------------

`` `python    def __aiter__(self) -> AsyncIterator[T]  See also :py`~collections.abc.AsyncIterable`.  collections.abc.AsyncIterator[T] ``\` --------------------------------

`` `python    def __anext__(self) -> Awaitable[T]    def __aiter__(self) -> AsyncIterator[T]  See also :py`~collections.abc.AsyncIterator`.  Context manager protocols ``\` .........................

There are two protocols for context managers -- one for regular context managers and one for async ones. These allow defining objects that can be used in `with` and `async with` statements.

#### contextlib.AbstractContextManager\[T\]

`` `python    def __enter__(self) -> T    def __exit__(self,                 exc_type: type[BaseException] | None,                 exc_value: BaseException | None,                 traceback: TracebackType | None) -> bool | None  See also :py`~contextlib.AbstractContextManager`.  contextlib.AbstractAsyncContextManager[T] ``\` -----------------------------------------

`` `python    def __aenter__(self) -> Awaitable[T]    def __aexit__(self,                  exc_type: type[BaseException] | None,                  exc_value: BaseException | None,                  traceback: TracebackType | None) -> Awaitable[bool | None]  See also :py`~contextlib.AbstractAsyncContextManager`. ``\`

---

running_mypy.md

---

# Running mypy and managing imports

The \[getting-started\](\#getting-started) page should have already introduced you to the basics of how to run mypy -- pass in the files and directories you want to type check via the command line:

    $ mypy foo.py bar.py some_directory

This page discusses in more detail how exactly to specify what files you want mypy to type check, how mypy discovers imported modules, and recommendations on how to handle any issues you may encounter along the way.

If you are interested in learning about how to configure the actual way mypy type checks your code, see our \[command-line\](\#command-line) guide.

## Specifying code to be checked

Mypy lets you specify what files it should type check in several different ways.

1.  First, you can pass in paths to Python files and directories you want to type check. For example:
    
        $ mypy file_1.py foo/file_2.py file_3.pyi some/directory
    
    The above command tells mypy it should type check all of the provided files together. In addition, mypy will recursively type check the entire contents of any provided directories.
    
    For more details about how exactly this is done, see \[Mapping file paths to modules \<mapping-paths-to-modules\>\](\#mapping-file-paths-to-modules-\<mapping-paths-to-modules\>).

2.  Second, you can use the `-m <mypy -m>` flag (long form: `--module <mypy --module>`) to specify a module name to be type checked. The name of a module is identical to the name you would use to import that module within a Python program. For example, running:
    
        $ mypy -m html.parser
    
    ...will type check the module `html.parser` (this happens to be a library stub).
    
    Mypy will use an algorithm very similar to the one Python uses to find where modules and imports are located on the file system. For more details, see \[finding-imports\](\#finding-imports).

3.  Third, you can use the `-p <mypy -p>` (long form: `--package <mypy --package>`) flag to specify a package to be (recursively) type checked. This flag is almost identical to the `-m <mypy -m>` flag except that if you give it a package name, mypy will recursively type check all submodules and subpackages of that package. For example, running:
    
        $ mypy -p html
    
    ...will type check the entire `html` package (of library stubs). In contrast, if we had used the `-m <mypy -m>` flag, mypy would have type checked just `html`'s `__init__.py` file and anything imported from there.
    
    Note that we can specify multiple packages and modules on the command line. For example:
    
        $ mypy --package p.a --package p.b --module c

4.  Fourth, you can also instruct mypy to directly type check small strings as programs by using the `-c <mypy -c>` (long form: `--command <mypy --command>`) flag. For example:
    
        $ mypy -c 'x = [1, 2]; print(x())'
    
    ...will type check the above string as a mini-program (and in this case, will report that `list[int]` is not callable).

You can also use the `files` option in your `mypy.ini` file to specify which files to check, in which case you can simply run `mypy` with no arguments.

## Reading a list of files from a file

Finally, any command-line argument starting with `@` reads additional command-line arguments from the file following the `@` character. This is primarily useful if you have a file containing a list of files that you want to be type-checked: instead of using shell syntax like:

    $ mypy $(cat file_of_files.txt)

you can use this instead:

    $ mypy @file_of_files.txt

This file can technically also contain any command line flag, not just file paths. However, if you want to configure many different flags, the recommended approach is to use a \[configuration file \<config-file\>\](\#configuration-file-\<config-file\>) instead.

## Mapping file paths to modules

One of the main ways you can tell mypy what to type check is by providing mypy a list of paths. For example:

    $ mypy file_1.py foo/file_2.py file_3.pyi some/directory

This section describes how exactly mypy maps the provided paths to modules to type check.

  - Mypy will check all paths provided that correspond to files.
  - Mypy will recursively discover and check all files ending in `.py` or `.pyi` in directory paths provided, after accounting for `--exclude <mypy --exclude>`.
  - For each file to be checked, mypy will attempt to associate the file (e.g. `project/foo/bar/baz.py`) with a fully qualified module name (e.g. `foo.bar.baz`). The directory the package is in (`project`) is then added to mypy's module search paths.

How mypy determines fully qualified module names depends on if the options `--no-namespace-packages <mypy --no-namespace-packages>` and `--explicit-package-bases <mypy --explicit-package-bases>` are set.

1.  If `--no-namespace-packages <mypy --no-namespace-packages>` is set, mypy will rely solely upon the presence of `__init__.py[i]` files to determine the fully qualified module name. That is, mypy will crawl up the directory tree for as long as it continues to find `__init__.py` (or `__init__.pyi`) files.
    
    For example, if your directory tree consists of `pkg/subpkg/mod.py`, mypy would require `pkg/__init__.py` and `pkg/subpkg/__init__.py` to exist in order correctly associate `mod.py` with `pkg.subpkg.mod`

2.  The default case. If `--namespace-packages <mypy
    --no-namespace-packages>` is on, but `--explicit-package-bases <mypy
    --explicit-package-bases>` is off, mypy will allow for the possibility that directories without `__init__.py[i]` are packages. Specifically, mypy will look at all parent directories of the file and use the location of the highest `__init__.py[i]` in the directory tree to determine the top-level package.
    
    For example, say your directory tree consists solely of `pkg/__init__.py` and `pkg/a/b/c/d/mod.py`. When determining `mod.py`'s fully qualified module name, mypy will look at `pkg/__init__.py` and conclude that the associated module name is `pkg.a.b.c.d.mod`.

3.  You'll notice that the above case still relies on `__init__.py`. If you can't put an `__init__.py` in your top-level package, but still wish to pass paths (as opposed to packages or modules using the `-p` or `-m` flags), `--explicit-package-bases <mypy --explicit-package-bases>` provides a solution.
    
    With `--explicit-package-bases <mypy --explicit-package-bases>`, mypy will locate the nearest parent directory that is a member of the `MYPYPATH` environment variable, the `mypy_path` config or is the current working directory. Mypy will then use the relative path to determine the fully qualified module name.
    
    For example, say your directory tree consists solely of `src/namespace_pkg/mod.py`. If you run the following command, mypy will correctly associate `mod.py` with `namespace_pkg.mod`:
    
        $ MYPYPATH=src mypy --namespace-packages --explicit-package-bases .

If you pass a file not ending in `.py[i]`, the module name assumed is `__main__` (matching the behavior of the Python interpreter), unless `--scripts-are-modules <mypy --scripts-are-modules>` is passed.

Passing `-v <mypy -v>` will show you the files and associated module names that mypy will check.

## How mypy handles imports

When mypy encounters an `import` statement, it will first \[attempt to locate \<finding-imports\>\](\#attempt-to-locate-\<finding-imports\>) that module or type stubs for that module in the file system. Mypy will then type check the imported module. There are three different outcomes of this process:

1.  Mypy is unable to follow the import: the module either does not exist, or is a third party library that does not use type hints.
2.  Mypy is able to follow and type check the import, but you did not want mypy to type check that module at all.
3.  Mypy is able to successfully both follow and type check the module, and you want mypy to type check that module.

The third outcome is what mypy will do in the ideal case. The following sections will discuss what to do in the other two cases.

## Missing imports<span id="ignore-missing-imports"></span>

When you import a module, mypy may report that it is unable to follow the import. This can cause errors that look like the following:

`` `text     main.py:1: error: Skipping analyzing 'django': module is installed, but missing library stubs or py.typed marker     main.py:2: error: Library stubs not installed for "requests"     main.py:3: error: Cannot find implementation or library stub for module named "this_module_does_not_exist"  If you get any of these errors on an import, mypy will assume the type of that ``<span class="title-ref"> module is </span><span class="title-ref">Any</span>\`, the dynamic type. This means attempting to access any attribute of the module will automatically succeed:

`` `python     # Error: Cannot find implementation or library stub for module named 'does_not_exist'     import does_not_exist      # But this type checks, and x will have type 'Any'     x = does_not_exist.foobar()  This can result in mypy failing to warn you about errors in your code. Since ``<span class="title-ref"> operations on </span><span class="title-ref">Any</span><span class="title-ref"> result in </span><span class="title-ref">Any</span>\`, these dynamic types can propagate through your code, making type checking less effective. See \[dynamic-typing\](\#dynamic-typing) for more information.

The next sections describe what each of these errors means and recommended next steps; scroll to the section that matches your error.

### Missing library stubs or py.typed marker

If you are getting a `Skipping analyzing X: module is installed, but missing library stubs or py.typed marker`, error, this means mypy was able to find the module you were importing, but no corresponding type hints.

Mypy will not try inferring the types of any 3rd party libraries you have installed unless they either have declared themselves to be \[PEP 561 compliant stub package \<installed-packages\>\](\#pep-561-compliant-stub-package-\<installed-packages\>) (e.g. with a `py.typed` file) or have registered themselves on [typeshed](https://github.com/python/typeshed), the repository of types for the standard library and some 3rd party libraries.

If you are getting this error, try to obtain type hints for the library you're using:

1.  Upgrading the version of the library you're using, in case a newer version has started to include type hints.

2.  Searching to see if there is a \[PEP 561 compliant stub package \<installed-packages\>\](\#pep-561-compliant-stub-package-\<installed-packages\>) corresponding to your third party library. Stub packages let you install type hints independently from the library itself.
    
    For example, if you want type hints for the `django` library, you can install the [django-stubs](https://pypi.org/project/django-stubs/) package.

3.  \[Writing your own stub files \<stub-files\>\](\#writing-your-own-stub-files-\<stub-files\>) containing type hints for the library. You can point mypy at your type hints either by passing them in via the command line, by using the `files` or `mypy_path` config file options, or by adding the location to the `MYPYPATH` environment variable.
    
    These stub files do not need to be complete\! A good strategy is to use \[stubgen \<stubgen\>\](\#stubgen-\<stubgen\>), a program that comes bundled with mypy, to generate a first rough draft of the stubs. You can then iterate on just the parts of the library you need.
    
    If you want to share your work, you can try contributing your stubs back to the library -- see our documentation on creating \[PEP 561 compliant packages \<installed-packages\>\](\#pep-561-compliant-packages-\<installed-packages\>).

If you are unable to find any existing type hints nor have time to write your own, you can instead *suppress* the errors.

All this will do is make mypy stop reporting an error on the line containing the import: the imported module will continue to be of type `Any`, and mypy may not catch errors in its use.

1.  To suppress a *single* missing import error, add a `# type: ignore` at the end of the line containing the import.

2.  To suppress *all* missing import errors from a single library, add a per-module section to your \[mypy config file \<config-file\>\](\#mypy-config-file-\<config-file\>) setting `ignore_missing_imports` to True for that library. For example, suppose your codebase makes heavy use of an (untyped) library named `foobar`. You can silence all import errors associated with that library and that library alone by adding the following section to your config file:
    
        [mypy-foobar.*]
        ignore_missing_imports = True
    
    Note: this option is equivalent to adding a `# type: ignore` to every import of `foobar` in your codebase. For more information, see the documentation about configuring \[import discovery \<config-file-import-discovery\>\](\#import-discovery-\<config-file-import-discovery\>) in config files. The `.*` after `foobar` will ignore imports of `foobar` modules and subpackages in addition to the `foobar` top-level package namespace.

3.  To suppress *all* missing import errors for *all* untyped libraries in your codebase, use `--disable-error-code=import-untyped <mypy --ignore-missing-imports>`. See \[code-import-untyped\](\#code-import-untyped) for more details on this error code.
    
    You can also set `disable_error_code`, like so:
    
        [mypy]
        disable_error_code = import-untyped
    
    You can also set the `--ignore-missing-imports <mypy --ignore-missing-imports>` command line flag or set the `ignore_missing_imports` config file option to True in the *global* section of your mypy config file. We recommend avoiding `--ignore-missing-imports` if possible: it's equivalent to adding a `# type: ignore` to all unresolved imports in your codebase.

### Library stubs not installed

If mypy can't find stubs for a third-party library, and it knows that stubs exist for the library, you will get a message like this:

`` `text     main.py:1: error: Library stubs not installed for "yaml"     main.py:1: note: Hint: "python3 -m pip install types-PyYAML"     main.py:1: note: (or run "mypy --install-types" to install all missing stub packages)  You can resolve the issue by running the suggested pip commands. ``<span class="title-ref"> If you're running mypy in CI, you can ensure the presence of any stub packages you need the same as you would any other test dependency, e.g. by adding them to the appropriate </span><span class="title-ref">requirements.txt</span>\` file.

Alternatively, add the `--install-types <mypy --install-types>` to your mypy command to install all known missing stubs:

`` `text     mypy --install-types  This is slower than explicitly installing stubs, since it effectively ``\` runs mypy twice -- the first time to find the missing stubs, and the second time to type check your code properly after mypy has installed the stubs. It also can make controlling stub versions harder, resulting in less reproducible type checking.

By default, `--install-types <mypy --install-types>` shows a confirmation prompt. Use `--non-interactive <mypy --non-interactive>` to install all suggested stub packages without asking for confirmation *and* type check your code:

If you've already installed the relevant third-party libraries in an environment other than the one mypy is running in, you can use `--python-executable
<mypy --python-executable>` flag to point to the Python executable for that environment, and mypy will find packages installed for that Python executable.

If you've installed the relevant stub packages and are still getting this error, see the \[section below \<missing-type-hints-for-third-party-library\>\](\#section-below-\<missing-type-hints-for-third-party-library\>).

### Cannot find implementation or library stub

If you are getting a `Cannot find implementation or library stub for module` error, this means mypy was not able to find the module you are trying to import, whether it comes bundled with type hints or not. If you are getting this error, try:

1.  Making sure your import does not contain a typo.

2.  If the module is a third party library, making sure that mypy is able to find the interpreter containing the installed library.
    
    For example, if you are running your code in a virtualenv, make sure to install and use mypy within the virtualenv. Alternatively, if you want to use a globally installed mypy, set the `--python-executable <mypy --python-executable>` command line flag to point the Python interpreter containing your installed third party packages.
    
    You can confirm that you are running mypy from the environment you expect by running it like `python -m mypy ...`. You can confirm that you are installing into the environment you expect by running pip like `python -m pip ...`.

3.  Reading the \[finding-imports\](\#finding-imports) section below to make sure you understand how exactly mypy searches for and finds modules and modify how you're invoking mypy accordingly.

4.  Directly specifying the directory containing the module you want to type check from the command line, by using the `mypy_path` or `files` config file options, or by using the `MYPYPATH` environment variable.
    
    Note: if the module you are trying to import is actually a *submodule* of some package, you should specify the directory containing the *entire* package. For example, suppose you are trying to add the module `foo.bar.baz` which is located at `~/foo-project/src/foo/bar/baz.py`. In this case, you must run `mypy ~/foo-project/src` (or set the `MYPYPATH` to `~/foo-project/src`).

## How imports are found

When mypy encounters an `import` statement or receives module names from the command line via the `--module <mypy --module>` or `--package <mypy --package>` flags, mypy tries to find the module on the file system similar to the way Python finds it. However, there are some differences.

First, mypy has its own search path. This is computed from the following items:

  - The `MYPYPATH` environment variable (a list of directories, colon-separated on UNIX systems, semicolon-separated on Windows).
  - The `mypy_path` config file option.
  - The directories containing the sources given on the command line (see \[Mapping file paths to modules \<mapping-paths-to-modules\>\](\#mapping-file-paths-to-modules-\<mapping-paths-to-modules\>)).
  - The installed packages marked as safe for type checking (see \[PEP 561 support \<installed-packages\>\](\#pep-561-support-\<installed-packages\>))
  - The relevant directories of the [typeshed](https://github.com/python/typeshed) repo.

\> **Note** \> You cannot point to a stub-only package (`561`) via the `MYPYPATH`, it must be installed (see \[PEP 561 support \<installed-packages\>\](\#pep-561-support-\<installed-packages\>))

Second, mypy searches for stub files in addition to regular Python files and packages. The rules for searching for a module `foo` are as follows:

  - The search looks in each of the directories in the search path (see above) until a match is found.
  - If a package named `foo` is found (i.e. a directory `foo` containing an `__init__.py` or `__init__.pyi` file) that's a match.
  - If a stub file named `foo.pyi` is found, that's a match.
  - If a Python module named `foo.py` is found, that's a match.

These matches are tried in order, so that if multiple matches are found in the same directory on the search path (e.g. a package and a Python file, or a stub file and a Python file) the first one in the above list wins.

In particular, if a Python file and a stub file are both present in the same directory on the search path, only the stub file is used. (However, if the files are in different directories, the one found in the earlier directory is used.)

Setting `mypy_path`/`MYPYPATH` is mostly useful in the case where you want to try running mypy against multiple distinct sets of files that happen to share some common dependencies.

For example, if you have multiple projects that happen to be using the same set of work-in-progress stubs, it could be convenient to just have your `MYPYPATH` point to a single directory containing the stubs.

## Following imports

Mypy is designed to \[doggedly follow all imports \<finding-imports\>\](\#doggedly-follow-all-imports-\<finding-imports\>), even if the imported module is not a file you explicitly wanted mypy to check.

For example, suppose we have two modules `mycode.foo` and `mycode.bar`: the former has type hints and the latter does not. We run `mypy -m mycode.foo <mypy -m>` and mypy discovers that `mycode.foo` imports `mycode.bar`.

How do we want mypy to type check `mycode.bar`? Mypy's behaviour here is configurable -- although we **strongly recommend** using the default --by using the `--follow-imports <mypy --follow-imports>` flag. This flag accepts one of four string values:

  - `normal` (the default, recommended) follows all imports normally and type checks all top level code (as well as the bodies of all functions and methods with at least one type annotation in the signature).

  - `silent` behaves in the same way as `normal` but will additionally *suppress* any error messages.

  - `skip` will *not* follow imports and instead will silently replace the module (and *anything imported from it*) with an object of type `Any`.

  - `error` behaves in the same way as `skip` but is not quite as silent -- it will flag the import as an error, like this:
    
        main.py:1: note: Import of "mycode.bar" ignored
        main.py:1: note: (Using --follow-imports=error, module not passed on command line)

If you are starting a new codebase and plan on using type hints from the start, we **recommend** you use either `--follow-imports=normal <mypy --follow-imports>` (the default) or `--follow-imports=error <mypy --follow-imports>`. Either option will help make sure you are not skipping checking any part of your codebase by accident.

If you are planning on adding type hints to a large, existing code base, we recommend you start by trying to make your entire codebase (including files that do not use type hints) pass under `--follow-imports=normal <mypy --follow-imports>`. This is usually not too difficult to do: mypy is designed to report as few error messages as possible when it is looking at unannotated code.

Only if doing this is intractable, try passing mypy just the files you want to type check and using `--follow-imports=silent <mypy --follow-imports>`. Even if mypy is unable to perfectly type check a file, it can still glean some useful information by parsing it (for example, understanding what methods a given object has). See \[existing-code\](\#existing-code) for more recommendations.

Adjusting import following behaviour is often most useful when restricted to specific modules. This can be accomplished by setting a per-module `follow_imports` config option.

\> **Warning** \> We do not recommend using `follow_imports=skip` unless you're really sure you know what you are doing. This option greatly restricts the analysis mypy can perform and you will lose a lot of the benefits of type checking.

> This is especially true at the global level. Setting a per-module `follow_imports=skip` for a specific problematic module can be useful without causing too much harm.

\> **Note** \> If you're looking to resolve import errors related to libraries, try following the advice in \[fix-missing-imports\](\#fix-missing-imports) before messing with `follow_imports`.

---

runtime_troubles.md

---

# Annotation issues at runtime

Idiomatic use of type annotations can sometimes run up against what a given version of Python considers legal code. This section describes these scenarios and explains how to get your code running again. Generally speaking, we have three tools at our disposal:

  - Use of `from __future__ import annotations` (`563`) (this behaviour may eventually be made the default in a future Python version)
  - Use of string literal types or type comments
  - Use of `typing.TYPE_CHECKING`

We provide a description of these before moving onto discussion of specific problems you may encounter.

## String literal types and type comments

Mypy lets you add type annotations using the (now deprecated) `# type:` type comment syntax. These were required with Python versions older than 3.6, since they didn't support type annotations on variables. Example:

`` `python    a = 1  # type: int     def f(x):  # type: (int) -> int        return x + 1     # Alternative type comment syntax for functions with many arguments    def send_email(         address,     # type: Union[str, List[str]]         sender,      # type: str         cc,          # type: Optional[List[str]]         subject='',         body=None    # type: List[str]    ):        # type: (...) -> bool  Type comments can't cause runtime errors because comments are not evaluated by ``\` Python.

In a similar way, using string literal types sidesteps the problem of annotations that would cause runtime errors.

Any type can be entered as a string literal, and you can combine string-literal types with non-string-literal types freely:

`` `python    def f(a: list['A']) -> None: ...  # OK, prevents NameError since A is defined later    def g(n: 'int') -> None: ...      # Also OK, though not useful     class A: pass  String literal types are never needed in ``\# type:`comments and [stub files <stub-files>](#stub-files-<stub-files>).  String literal types must be defined (or imported) later *in the same module*.`\` They cannot be used to leave cross-module references unresolved. (For dealing with import cycles, see \[import-cycles\](\#import-cycles).)

## Future annotations import (PEP 563)

Many of the issues described here are caused by Python trying to evaluate annotations. Future Python versions (potentially Python 3.14) will by default no longer attempt to evaluate function and variable annotations. This behaviour is made available in Python 3.7 and later through the use of `from __future__ import annotations`.

This can be thought of as automatic string literal-ification of all function and variable annotations. Note that function and variable annotations are still required to be valid Python syntax. For more details, see `563`.

\> **Note** \> Even with the `__future__` import, there are some scenarios that could still require string literals or result in errors, typically involving use of forward references or generics in:

>   - \[type aliases \<type-aliases\>\](\#type-aliases-\<type-aliases\>) not defined using the `type` statement;
>   - \[type narrowing \<type-narrowing\>\](\#type-narrowing-\<type-narrowing\>);
>   - type definitions (see :py\`\~typing.TypeVar\`, :py\`\~typing.NewType\`, :py\`\~typing.NamedTuple\`);
>   - base classes.
> 
> <!-- end list -->
> 
>   - \`\`\`python  
>     \# base class example from \_\_future\_\_ import annotations
>     
>     class A(tuple\['B', 'C'\]): ... \# String literal types needed here class B: ... class C: ...

\> **Warning** \> Some libraries may have use cases for dynamic evaluation of annotations, for instance, through use of `typing.get_type_hints` or `eval`. If your annotation would raise an error when evaluated (say by using `604` syntax with Python 3.9), you may need to be careful when using such libraries.

<div id="typing-type-checking">

typing.TYPE\_CHECKING `` ` --------------------  The :py:mod:`typing` module defines a :py`~typing.TYPE_CHECKING` constant that is ``False`at runtime but treated as`True`while type checking.  Since code inside`if TYPE\_CHECKING:`is not executed at runtime, it provides a convenient way to tell mypy something without the code being evaluated at runtime. This is most useful for resolving [import cycles <import-cycles>](#import-cycles-<import-cycles>).  .. _forward-references:  Class name forward references -----------------------------  Python does not allow references to a class object before the class is defined (aka forward reference). Thus this code does not work as expected:`\`python def f(x: A) -\> None: ... \# NameError: name "A" is not defined class A: ...

</div>

Starting from Python 3.7, you can add `from __future__ import annotations` to `` ` resolve this, as discussed earlier: ``\`python from \_\_future\_\_ import annotations

> def f(x: A) -\> None: ... \# OK class A: ...

For Python 3.6 and below, you can enter the type as a string literal or type comment:

``` python
def f(x: 'A') -> None: ...  # OK

# Also OK
def g(x):  # type: (A) -> None
    ...

class A: ...
```

Of course, instead of using future annotations import or string literal types, `` ` you could move the function definition after the class definition. This is not always desirable or even possible, though.  .. _import-cycles:  Import cycles -------------  An import cycle occurs where module A imports module B and module B imports module A (perhaps indirectly, e.g. ``A -\> B -\> C -\> A`). Sometimes in order to add type annotations you have to add extra imports to a module and those imports cause cycles that didn't exist before. This can lead to errors at runtime like:`\`text ImportError: cannot import name 'b' from partially initialized module 'A' (most likely due to a circular import)

If those cycles do become a problem when running your program, there's a trick: `` ` if the import is only needed for type annotations and you're using a) the [future annotations import<future-annotations>](#future-annotations-import<future-annotations>), or b) string literals or type comments for the relevant annotations, you can write the imports inside ``if TYPE\_CHECKING:`so that they are not executed at runtime. Example:  File`foo.py`:`\`python from typing import TYPE\_CHECKING

>   - if TYPE\_CHECKING:  
>     import bar
> 
>   - def listify(arg: 'bar.BarClass') -\> 'list\[bar.BarClass\]':  
>     return \[arg\]

File `bar.py`:

``` python
from foo import listify

class BarClass:
    def listifyme(self) -> 'list[BarClass]':
        return listify(self)
```

<div id="not-generic-runtime">

Using classes that are generic in stubs but not at runtime `` ` ----------------------------------------------------------  Some classes are declared as [generic<generic-classes>](#generic<generic-classes>) in stubs, but not at runtime.  In Python 3.8 and earlier, there are several examples within the standard library, for instance, :py`os.PathLike` and :py`queue.Queue`. Subscripting such a class will result in a runtime error: ``\`python from queue import Queue

</div>

>   - class Tasks(Queue\[str\]): \# TypeError: 'type' object is not subscriptable  
>     ...
> 
> results: Queue\[int\] = Queue() \# TypeError: 'type' object is not subscriptable

To avoid errors from use of these generics in annotations, just use the `` ` [future annotations import<future-annotations>](#future-annotations-import<future-annotations>) (or string literals or type comments for Python 3.6 and below).  To avoid errors when inheriting from these classes, things are a little more complicated and you need to use [typing.TYPE_CHECKING <typing-type-checking>](#typing.type_checking <typing-type-checking>): ``\`python from typing import TYPE\_CHECKING from queue import Queue

>   - if TYPE\_CHECKING:  
>     BaseQueue = Queue\[str\] \# this is only processed by mypy
> 
>   - else:  
>     BaseQueue = Queue \# this is not seen by mypy but will be executed at runtime
> 
>   - class Tasks(BaseQueue): \# OK  
>     ...
> 
> task\_queue: Tasks reveal\_type(task\_queue.get()) \# Reveals str

If your subclass is also generic, you can use the following (using the `` ` legacy syntax for generic classes): ``\`python from typing import TYPE\_CHECKING, TypeVar, Generic from queue import Queue

> \_T = TypeVar("\_T") if TYPE\_CHECKING: class \_MyQueueBase(Queue\[\_T\]): pass else: class \_MyQueueBase(Generic\[\_T\], Queue): pass
> 
> class MyQueue(\_MyQueueBase\[\_T\]): pass
> 
> task\_queue: MyQueue\[str\] reveal\_type(task\_queue.get()) \# Reveals str

In Python 3.9 and later, we can just inherit directly from `Queue[str]` or `Queue[T]` `` ` since its :py`queue.Queue` implements :py`~object.__class_getitem__`, so the class object can be subscripted at runtime. You may still encounter issues (even if you use a recent Python version) when subclassing generic classes defined in third-party libraries if types are generic only in stubs.  Using types defined in stubs but not at runtime -----------------------------------------------  Sometimes stubs that you're using may define types you wish to re-use that do not exist at runtime. Importing these types naively will cause your code to fail at runtime with ``ImportError`or`ModuleNotFoundError`. Similar to previous sections, these can be dealt with by using [typing.TYPE_CHECKING <typing-type-checking>](#typing.type_checking <typing-type-checking>):`\`python from \_\_future\_\_ import annotations from typing import TYPE\_CHECKING if TYPE\_CHECKING: from \_typeshed import SupportsRichComparison

> def f(x: SupportsRichComparison) -\> None

The `from __future__ import annotations` is required to avoid `` ` a ``NameError``when using the imported symbol. For more information and caveats, see the section on [future annotations <future-annotations>](#future-annotations-<future-annotations>).  .. _generic-builtins:  Using generic builtins ----------------------  Starting with Python 3.9 (:pep:`585`), the type objects of many collections in the standard library support subscription at runtime. This means that you no longer have to import the equivalents from :py:mod:`typing`; you can simply use the built-in collections or those from :py:mod:`collections.abc`:``\`python from collections.abc import Sequence x: list\[str\] y: dict\[int, str\] z: Sequence\[str\] = x

There is limited support for using this syntax in Python 3.7 and later as well: `` ` if you use ``from \_\_future\_\_ import annotations``, mypy will understand this syntax in annotations. However, since this will not be supported by the Python interpreter at runtime, make sure you're aware of the caveats mentioned in the notes at [future annotations import<future-annotations>](#future-annotations-import<future-annotations>).  Using X | Y syntax for Unions -----------------------------  Starting with Python 3.10 (:pep:`604`), you can spell union types as``x: int | str`, instead of`x: typing.Union\[int, str\]`.  There is limited support for using this syntax in Python 3.7 and later as well: if you use`from \_\_future\_\_ import annotations`, mypy will understand this syntax in annotations, string literal types, type comments and stub files. However, since this will not be supported by the Python interpreter at runtime (if evaluated,`int | str`will raise`TypeError: unsupported operand type(s) for |: 'type' and 'type'``), make sure you're aware of the caveats mentioned in the notes at [future annotations import<future-annotations>](#future-annotations-import<future-annotations>).  Using new additions to the typing module ----------------------------------------  You may find yourself wanting to use features added to the :py:mod:`typing` module in earlier versions of Python than the addition, for example, using any of``Literal`,`Protocol`,`TypedDict`with Python 3.6.  The easiest way to do this is to install and use the`typing\_extensions`package from PyPI for the relevant imports, for example:`\`python from typing\_extensions import Literal x: Literal\["open", "close"\]

If you don't want to rely on `typing_extensions` being installed on newer `` ` Pythons, you could alternatively use: ``\`python import sys if sys.version\_info \>= (3, 8): from typing import Literal else: from typing\_extensions import Literal

> x: Literal\["open", "close"\]

This plays nicely well with following `508` dependency specification: `` ` ``typing\_extensions; python\_version\<"3.8"\`\`

---

stubgen.md

---

<div id="stubgen">

<div class="program">

stubgen

</div>

</div>

# Automatic stub generation (stubgen)

A stub file (see `484`) contains only type hints for the public interface of a module, with empty function bodies. Mypy can use a stub file instead of the real implementation to provide type information for the module. They are useful for third-party modules whose authors have not yet added type hints (and when no stubs are available in typeshed) and C extension modules (which mypy can't directly process).

Mypy includes the `stubgen` tool that can automatically generate stub files (`.pyi` files) for Python modules and C extension modules. For example, consider this source file:

`` `python    from other_module import dynamic     BORDER_WIDTH = 15     class Window:        parent = dynamic()        def __init__(self, width, height):            self.width = width            self.height = height     def create_empty() -> Window:        return Window(0, 0)  Stubgen can generate this stub file based on the above file:  .. code-block:: python     from typing import Any     BORDER_WIDTH: int = ...     class Window:        parent: Any = ...        width: Any = ...        height: Any = ...        def __init__(self, width, height) -> None: ...     def create_empty() -> Window: ...  Stubgen generates *draft* stubs. The auto-generated stub files often ``<span class="title-ref"> require some manual updates, and most types will default to </span><span class="title-ref">Any</span>\`. The stubs will be much more useful if you add more precise type annotations, at least for the most commonly used functionality.

The rest of this section documents the command line interface of stubgen. Run `stubgen --help` for a quick summary of options.

\> **Note** \> The command-line flags may change between releases.

## Specifying what to stub

You can give stubgen paths of the source files for which you want to generate stubs:

    $ stubgen foo.py bar.py

This generates stubs `out/foo.pyi` and `out/bar.pyi`. The default output directory `out` can be overridden with `-o DIR <-o>`.

You can also pass directories, and stubgen will recursively search them for any `.py` files and generate stubs for all of them:

    $ stubgen my_pkg_dir

Alternatively, you can give module or package names using the `-m` or `-p` options:

    $ stubgen -m foo -m bar -p my_pkg_dir

Details of the options:

<div class="option">

\-m MODULE, --module MODULE

Generate a stub file for the given module. This flag may be repeated multiple times.

Stubgen *will not* recursively generate stubs for any submodules of the provided module.

</div>

<div class="option">

\-p PACKAGE, --package PACKAGE

Generate stubs for the given package. This flag maybe repeated multiple times.

Stubgen *will* recursively generate stubs for all submodules of the provided package. This flag is identical to `--module` apart from this behavior.

</div>

\> **Note** \> You can't mix paths and `-m`/`-p` options in the same stubgen invocation.

Stubgen applies heuristics to avoid generating stubs for submodules that include tests or vendored third-party packages.

## Specifying how to generate stubs

By default stubgen will try to import the target modules and packages. This allows stubgen to use runtime introspection to generate stubs for C extension modules and to improve the quality of the generated stubs. By default, stubgen will also use mypy to perform light-weight semantic analysis of any Python modules. Use the following flags to alter the default behavior:

<div class="option">

\--no-import

Don't try to import modules. Instead only use mypy's normal search mechanism to find sources. This does not support C extension modules. This flag also disables runtime introspection functionality, which mypy uses to find the value of `__all__`. As result the set of exported imported names in stubs may be incomplete. This flag is generally only useful when importing a module causes unwanted side effects, such as the running of tests. Stubgen tries to skip test modules even without this option, but this does not always work.

</div>

<div class="option">

\--no-analysis

Don't perform semantic analysis of source files. This may generate worse stubs -- in particular, some module, class, and function aliases may be represented as variables with the `Any` type. This is generally only useful if semantic analysis causes a critical mypy error. Does not apply to C extension modules. Incompatible with `--inspect-mode`.

</div>

<div class="option">

\--inspect-mode

Import and inspect modules instead of parsing source code. This is the default behavior for C modules and pyc-only packages. The flag is useful to force inspection for pure Python modules that make use of dynamically generated members that would otherwise be omitted when using the default behavior of code parsing. Implies `--no-analysis` as analysis requires source code.

</div>

<div class="option">

\--doc-dir PATH

Try to infer better signatures by parsing .rst documentation in `PATH`. This may result in better stubs, but currently it only works for C extension modules.

</div>

## Additional flags

<div class="option">

\-h, --help

Show help message and exit.

</div>

<div class="option">

\--ignore-errors

If an exception was raised during stub generation, continue to process any remaining modules instead of immediately failing with an error.

</div>

<div class="option">

\--include-private

Include definitions that are considered private in stubs (with names such as `_foo` with single leading underscore and no trailing underscores).

</div>

<div class="option">

\--export-less

Don't export all names imported from other modules within the same package. Instead, only export imported names that are not referenced in the module that contains the import.

</div>

<div class="option">

\--include-docstrings

Include docstrings in stubs. This will add docstrings to Python function and classes stubs and to C extension function stubs.

</div>

<div class="option">

\--search-path PATH

Specify module search directories, separated by colons (only used if `--no-import` is given).

</div>

<div class="option">

\-o PATH, --output PATH

Change the output directory. By default the stubs are written in the `./out` directory. The output directory will be created if it doesn't exist. Existing stubs in the output directory will be overwritten without warning.

</div>

<div class="option">

\-v, --verbose

Produce more verbose output.

</div>

<div class="option">

\-q, --quiet

Produce less verbose output.

</div>

---

stubs.md

---

# Stub files

A *stub file* is a file containing a skeleton of the public interface of that Python module, including classes, variables, functions -- and most importantly, their types.

Mypy uses stub files stored in the [typeshed](https://github.com/python/typeshed) repository to determine the types of standard library and third-party library functions, classes, and other definitions. You can also create your own stubs that will be used to type check your code.

## Creating a stub

Here is an overview of how to create a stub file:

  - Write a stub file for the library (or an arbitrary module) and store it as a `.pyi` file in the same directory as the library module.

  - Alternatively, put your stubs (`.pyi` files) in a directory reserved for stubs (e.g., `myproject/stubs`). In this case you have to set the environment variable `MYPYPATH` to refer to the directory. For example:
    
        $ export MYPYPATH=~/work/myproject/stubs

Use the normal Python file name conventions for modules, e.g. `csv.pyi` for module `csv`. Use a subdirectory with `__init__.pyi` for packages. Note that `561` stub-only packages must be installed, and may not be pointed at through the `MYPYPATH` (see \[PEP 561 support \<installed-packages\>\](\#pep-561-support-\<installed-packages\>)).

If a directory contains both a `.py` and a `.pyi` file for the same module, the `.pyi` file takes precedence. This way you can easily add annotations for a module even if you don't want to modify the source code. This can be useful, for example, if you use 3rd party open source libraries in your program (and there are no stubs in typeshed yet).

That's it\!

Now you can access the module in mypy programs and type check code that uses the library. If you write a stub for a library module, consider making it available for other programmers that use mypy by contributing it back to the typeshed repo.

Mypy also ships with two tools for making it easier to create and maintain stubs: \[stubgen\](\#stubgen) and \[stubtest\](\#stubtest).

The following sections explain the kinds of type annotations you can use in your programs and stub files.

\> **Note** \> You may be tempted to point `MYPYPATH` to the standard library or to the `site-packages` directory where your 3rd party packages are installed. This is almost always a bad idea -- you will likely get tons of error messages about code you didn't write and that mypy can't analyze all that well yet, and in the worst case scenario mypy may crash due to some construct in a 3rd party package that it didn't expect.

## Stub file syntax

Stub files are written in normal Python syntax, but generally leaving out runtime logic like variable initializers, function bodies, and default arguments.

If it is not possible to completely leave out some piece of runtime logic, the recommended convention is to replace or elide them with ellipsis expressions (`...`). Each ellipsis below is literally written in the stub file as three dots:

`` `python     # Variables with annotations do not need to be assigned a value.     # So by convention, we omit them in the stub file.     x: int      # Function bodies cannot be completely removed. By convention,     # we replace them with `...` instead of the `pass` statement.     def func_1(code: str) -> int: ...      # We can do the same with default arguments.     def func_2(a: int, b: int = ...) -> int: ...  > **Note** >      The ellipsis ``...`is also used with a different meaning in     [callable types <callable-types>](#callable-types-<callable-types>) and [tuple types     <tuple-types>](#tuple-types ----<tuple-types>).  Using stub file syntax at runtime`\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

You may also occasionally need to elide actual logic in regular Python code -- for example, when writing methods in \[overload variants \<function-overloading\>\](\#overload-variants-\<function-overloading\>) or \[custom protocols \<protocol-types\>\](\#custom-protocols-\<protocol-types\>).

The recommended style is to use ellipses to do so, just like in stub files. It is also considered stylistically acceptable to throw a :py\`NotImplementedError\` in cases where the user of the code may accidentally call functions with no actual logic.

You can also elide default arguments as long as the function body also contains no runtime logic: the function body only contains a single ellipsis, the pass statement, or a `raise NotImplementedError()`. It is also acceptable for the function body to contain a docstring. For example:

`` `python from typing import Protocol  class Resource(Protocol):     def ok_1(self, foo: list[str] = ...) -> None: ...      def ok_2(self, foo: list[str] = ...) -> None:         raise NotImplementedError()      def ok_3(self, foo: list[str] = ...) -> None:         """Some docstring"""         pass      # Error: Incompatible default for argument "foo" (default has     # type "ellipsis", argument has type "list[str]")     def not_ok(self, foo: list[str] = ...) -> None:         print(foo) ``\`

---

stubtest.md

---

<div id="stubtest">

<div class="program">

stubtest

</div>

</div>

# Automatic stub testing (stubtest)

Stub files are files containing type annotations. See [PEP 484](https://www.python.org/dev/peps/pep-0484/#stub-files) for more motivation and details.

A common problem with stub files is that they tend to diverge from the actual implementation. Mypy includes the `stubtest` tool that can automatically check for discrepancies between the stubs and the implementation at runtime.

## What stubtest does and does not do

Stubtest will import your code and introspect your code objects at runtime, for example, by using the capabilities of the :py`inspect` module. Stubtest will then analyse the stub files, and compare the two, pointing out things that differ between stubs and the implementation at runtime.

It's important to be aware of the limitations of this comparison. Stubtest will not make any attempt to statically analyse your actual code and relies only on dynamic runtime introspection (in particular, this approach means stubtest works well with extension modules). However, this means that stubtest has limited visibility; for instance, it cannot tell if a return type of a function is accurately typed in the stubs.

For clarity, here are some additional things stubtest can't do:

  - Type check your code -- use `mypy` instead
  - Generate stubs -- use `stubgen` or `pyright --createstub` instead
  - Generate stubs based on running your application or test suite -- use `monkeytype` instead
  - Apply stubs to code to produce inline types -- use `retype` or `libcst` instead

In summary, stubtest works very well for ensuring basic consistency between stubs and implementation or to check for stub completeness. It's used to test Python's official collection of library stubs, [typeshed](https://github.com/python/typeshed).

\> **Warning** \> stubtest will import and execute Python code from the packages it checks.

## Example

Here's a quick example of what stubtest can do:

`` `shell     $ python3 -m pip install mypy      $ cat library.py     x = "hello, stubtest"      def foo(x=None):         print(x)      $ cat library.pyi     x: int      def foo(x: int) -> None: ...      $ python3 -m mypy.stubtest library     error: library.foo is inconsistent, runtime argument "x" has a default value but stub argument does not     Stub: at line 3     def (x: builtins.int)     Runtime: in file ~/library.py:3     def (x=None)      error: library.x variable differs from runtime type Literal['hello, stubtest']     Stub: at line 1     builtins.int     Runtime:     'hello, stubtest'   Usage ``\` \*\*\*\*\*

Running stubtest can be as simple as `stubtest module_to_check`. Run `stubtest --help` for a quick summary of options.

Stubtest must be able to import the code to be checked, so make sure that mypy is installed in the same environment as the library to be tested. In some cases, setting `PYTHONPATH` can help stubtest find the code to import.

Similarly, stubtest must be able to find the stubs to be checked. Stubtest respects the `MYPYPATH` environment variable -- consider using this if you receive a complaint along the lines of "failed to find stubs".

Note that stubtest requires mypy to be able to analyse stubs. If mypy is unable to analyse stubs, you may get an error on the lines of "not checking stubs due to mypy build errors". In this case, you will need to mitigate those errors before stubtest will run. Despite potential overlap in errors here, stubtest is not intended as a substitute for running mypy directly.

If you wish to ignore some of stubtest's complaints, stubtest supports a pretty handy allowlist system.

The rest of this section documents the command line interface of stubtest.

<div class="option">

\--concise

Makes stubtest's output more concise, one line per error

</div>

<div class="option">

\--ignore-missing-stub

Ignore errors for stub missing things that are present at runtime

</div>

<div class="option">

\--ignore-positional-only

Ignore errors for whether an argument should or shouldn't be positional-only

</div>

<div class="option">

\--allowlist FILE

Use file as an allowlist. Can be passed multiple times to combine multiple allowlists. Allowlists can be created with --generate-allowlist. Allowlists support regular expressions.

The presence of an entry in the allowlist means stubtest will not generate any errors for the corresponding definition.

</div>

<div class="option">

\--generate-allowlist

Print an allowlist (to stdout) to be used with --allowlist

When introducing stubtest to an existing project, this is an easy way to silence all existing errors.

</div>

<div class="option">

\--ignore-unused-allowlist

Ignore unused allowlist entries

Without this option enabled, the default is for stubtest to complain if an allowlist entry is not necessary for stubtest to pass successfully.

Note if an allowlist entry is a regex that matches the empty string, stubtest will never consider it unused. For example, to get <span class="title-ref">--ignore-unused-allowlist</span> behaviour for a single allowlist entry like `foo.bar` you could add an allowlist entry `(foo\.bar)?`. This can be useful when an error only occurs on a specific platform.

</div>

<div class="option">

\--mypy-config-file FILE

Use specified mypy config file to determine mypy plugins and mypy path

</div>

<div class="option">

\--custom-typeshed-dir DIR

Use the custom typeshed in DIR

</div>

<div class="option">

\--check-typeshed

Check all stdlib modules in typeshed

</div>

<div class="option">

\--help

Show a help message :-)

</div>

---

supported_python_features.md

---

# Supported Python features

A list of unsupported Python features is maintained in the mypy wiki:

  - [Unsupported Python features](https://github.com/python/mypy/wiki/Unsupported-Python-Features)

## Runtime definition of methods and functions

By default, mypy will complain if you add a function to a class or module outside its definition -- but only if this is visible to the type checker. This only affects static checking, as mypy performs no additional type checking at runtime. You can easily work around this. For example, you can use dynamically typed code or values with `Any` types, or you can use :py\`setattr\` or other introspection features. However, you need to be careful if you decide to do this. If used indiscriminately, you may have difficulty using static typing effectively, since the type checker cannot see functions defined at runtime.

---

type_inference_and_annotations.md

---

# Type inference and type annotations

## Type inference

For most variables, if you do not explicitly specify its type, mypy will infer the correct type based on what is initially assigned to the variable.

`` `python     # Mypy will infer the type of these variables, despite no annotations     i = 1     reveal_type(i)  # Revealed type is "builtins.int"     l = [1, 2]     reveal_type(l)  # Revealed type is "builtins.list[builtins.int]"   > **Note** >      Note that mypy will not use type inference in dynamically typed functions     (those without a function type annotation) — every local variable type     defaults to ``Any`in such functions. For more details, see [dynamic-typing](#dynamic-typing).      .. code-block:: python          def untyped_function():             i = 1             reveal_type(i) # Revealed type is "Any"                            # 'reveal_type' always outputs 'Any' in unchecked functions  .. _explicit-var-types:  Explicit types for variables`\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

You can override the inferred type of a variable by using a variable type annotation:

`` `python    x: int | str = 1  Without the type annotation, the type of ``x`would be just`int`. We`<span class="title-ref"> use an annotation to give it a more general type </span><span class="title-ref">int | str</span><span class="title-ref"> (this type means that the value can be either an </span><span class="title-ref">int</span><span class="title-ref"> or a </span><span class="title-ref">str</span>\`).

The best way to think about this is that the type annotation sets the type of the variable, not the type of the expression. For instance, mypy will complain about the following code:

`` `python    x: int | str = 1.1  # error: Incompatible types in assignment                        # (expression has type "float", variable has type "int | str")  > **Note** >     To explicitly override the type of an expression you can use    :py`cast(\<type\>, \<expression\>) <typing.cast>`.    See [casts](#casts) for details.  Note that you can explicitly declare the type of a variable without ``\` giving it an initial value:

`` `python    # We only unpack two values, so there's no right-hand side value    # for mypy to infer the type of "cs" from:    a, b, *cs = 1, 2  # error: Need type annotation for "cs"     rs: list[int]  # no assignment!    p, q, *rs = 1, 2  # OK  Explicit types for collections ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

The type checker cannot always infer the type of a list or a dictionary. This often arises when creating an empty list or dictionary and assigning it to a new variable that doesn't have an explicit variable type. Here is an example where mypy can't infer the type without some help:

`` `python    l = []  # Error: Need type annotation for "l"  In these cases you can give the type explicitly using a type annotation:  .. code-block:: python     l: list[int] = []       # Create empty list of int    d: dict[str, int] = {}  # Create empty dictionary (str -> int)  > **Note** >     Using type arguments (e.g. ``list\[int\]``) on builtin collections like    :py`list`,  :py`dict`, :py`tuple`, and  :py`set`    only works in Python 3.9 and later. For Python 3.8 and earlier, you must use    :py`~typing.List` (e.g.``List\[int\]``), :py`~typing.Dict`, and    so on.   Compatibility of container types``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

A quick note: container types can sometimes be unintuitive. We'll discuss this more in \[variance\](\#variance). For example, the following program generates a mypy error, because mypy treats `list[int]` as incompatible with `list[object]`:

`` `python    def f(l: list[object], k: list[int]) -> None:        l = k  # error: Incompatible types in assignment  The reason why the above assignment is disallowed is that allowing the ``<span class="title-ref"> assignment could result in non-int values stored in a list of </span><span class="title-ref">int</span>\`:

`` `python    def f(l: list[object], k: list[int]) -> None:        l = k        l.append('x')        print(k[-1])  # Ouch; a string in list[int]  Other container types like :py`dict` and :py`set` behave similarly.  You can still run the above program; it prints ``x`. This illustrates the fact`\` that static types do not affect the runtime behavior of programs. You can run programs with type check failures, which is often very handy when performing a large refactoring. Thus you can always 'work around' the type system, and it doesn't really limit what you can do in your program.

## Context in type inference

Type inference is *bidirectional* and takes context into account.

Mypy will take into account the type of the variable on the left-hand side of an assignment when inferring the type of the expression on the right-hand side. For example, the following will type check:

`` `python    def f(l: list[object]) -> None:        l = [1, 2]  # Infer type list[object] for [1, 2], not list[int]   The value expression ``\[1, 2\]`is type checked with the additional`<span class="title-ref"> context that it is being assigned to a variable of type </span><span class="title-ref">list\[object\]</span><span class="title-ref">. This is used to infer the type of the \*expression\* as </span><span class="title-ref">list\[object\]</span>\`.

Declared argument types are also used for type context. In this program mypy knows that the empty list `[]` should have type `list[int]` based on the declared type of `arg` in `foo`:

`` `python     def foo(arg: list[int]) -> None:         print('Items:', ''.join(str(a) for a in arg))      foo([])  # OK  However, context only works within a single statement. Here mypy requires ``\` an annotation for the empty list, since the context would only be available in the following statement:

`` `python     def foo(arg: list[int]) -> None:         print('Items:', ', '.join(arg))      a = []  # Error: Need type annotation for "a"     foo(a)  Working around the issue is easy by adding a type annotation:  .. code-block:: Python      ...     a: list[int] = []  # OK     foo(a)  .. _silencing-type-errors:  Silencing type errors ``\` \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

You might want to disable type checking on specific lines, or within specific files in your codebase. To do that, you can use a `# type: ignore` comment.

For example, say in its latest update, the web framework you use can now take an integer argument to `run()`, which starts it on localhost on that port. Like so:

`` `python     # Starting app on http://localhost:8000     app.run(8000)  However, the devs forgot to update their type annotations for ``<span class="title-ref"> </span><span class="title-ref">run</span><span class="title-ref">, so mypy still thinks </span><span class="title-ref">run</span><span class="title-ref"> only expects </span><span class="title-ref">str</span>\` types. This would give you the following error:

`` `text     error: Argument 1 to "run" of "A" has incompatible type "int"; expected "str"  If you cannot directly fix the web framework yourself, you can temporarily ``<span class="title-ref"> disable type checking on that line, by adding a </span><span class="title-ref">\# type: ignore</span>\`:

`` `python     # Starting app on http://localhost:8000     app.run(8000)  # type: ignore  This will suppress any mypy errors that would have raised on that specific line.  You should probably add some more information on the ``\# type: ignore`comment,`\` to explain why the ignore was added in the first place. This could be a link to an issue on the repository responsible for the type stubs, or it could be a short explanation of the bug. To do that, use this format:

`` `python     # Starting app on http://localhost:8000     app.run(8000)  # type: ignore  # `run()` in v2.0 accepts an `int`, as a port  Type ignore error codes ``\` -----------------------

By default, mypy displays an error code for each error:

`` `text    error: "str" has no attribute "trim"  [attr-defined]   It is possible to add a specific error-code in your ignore comment (e.g. ``<span class="title-ref"> </span><span class="title-ref">\# type: ignore\[attr-defined\]</span>\`) to clarify what's being silenced. You can find more information about error codes \[here \<silence-error-codes\>\](\#here-\<silence-error-codes\>).

### Other ways to silence errors

You can get mypy to silence errors about a specific variable by dynamically typing it with `Any`. See \[dynamic-typing\](\#dynamic-typing) for more information.

`` `python     from typing import Any      def f(x: Any, y: str) -> None:         x = 'hello'         x += 1  # OK  You can ignore all mypy errors in a file by adding a ``<span class="title-ref"> </span><span class="title-ref">\# mypy: ignore-errors</span>\` at the top of the file:

`` `python     # mypy: ignore-errors     # This is a test file, skipping type checking in it.     import unittest     ...  You can also specify per-module configuration options in your [config-file](#config-file). ``\` For example:

`` `ini     # Don't report errors in the 'package_to_fix_later' package     [mypy-package_to_fix_later.*]     ignore_errors = True      # Disable specific error codes in the 'tests' package     # Also don't require type annotations     [mypy-tests.*]     disable_error_code = var-annotated, has-type     allow_untyped_defs = True      # Silence import errors from the 'library_missing_types' package     [mypy-library_missing_types.*]     ignore_missing_imports = True  Finally, adding a ``@typing.no\_type\_check`decorator to a class, method or`\` function causes mypy to avoid type checking that class, method or function and to treat it as not having any type annotations.

`` `python @typing.no_type_check def foo() -> str:    return 12345  # No error! ``\`

---

type_narrowing.md

---

# Type narrowing

This section is dedicated to several type narrowing techniques which are supported by mypy.

Type narrowing is when you convince a type checker that a broader type is actually more specific, for instance, that an object of type `Shape` is actually of the narrower type `Square`.

## Type narrowing expressions

The simplest way to narrow a type is to use one of the supported expressions:

  - :py\`isinstance\` like in `isinstance(obj, float)` will narrow `obj` to have `float` type
  - :py\`issubclass\` like in `issubclass(cls, MyClass)` will narrow `cls` to be `Type[MyClass]`
  - :py\`type\` like in `type(obj) is int` will narrow `obj` to have `int` type
  - :py\`callable\` like in `callable(obj)` will narrow object to callable type
  - `obj is not None` will narrow object to its \[non-optional form \<strict\_optional\>\](\#non-optional-form-\<strict\_optional\>)

Type narrowing is contextual. For example, based on the condition, mypy will narrow an expression only within an `if` branch:

`` `python   def function(arg: object):       if isinstance(arg, int):           # Type is narrowed within the ``if`branch only           reveal_type(arg)  # Revealed type: "builtins.int"       elif isinstance(arg, str) or isinstance(arg, bool):           # Type is narrowed differently within this`elif`branch:           reveal_type(arg)  # Revealed type: "builtins.str | builtins.bool"            # Subsequent narrowing operations will narrow the type further           if isinstance(arg, bool):               reveal_type(arg)  # Revealed type: "builtins.bool"        # Back outside of the`if`statement, the type isn't narrowed:       reveal_type(arg)  # Revealed type: "builtins.object"  Mypy understands the implications`return`or exception raising can have`\` for what type an object could be:

`` `python   def function(arg: int | str):       if isinstance(arg, int):           return        # `arg` can't be `int` at this point:       reveal_type(arg)  # Revealed type: "builtins.str"  We can also use ``assert``to narrow types in the same context:  .. code-block:: python    def function(arg: Any):       assert isinstance(arg, int)       reveal_type(arg)  # Revealed type: "builtins.int"  > **Note** >    With :option:`--warn-unreachable <mypy --warn-unreachable>`   narrowing types to some impossible state will be treated as an error.    .. code-block:: python       def function(arg: int):          # error: Subclass of "int" and "str" cannot exist:          # would have incompatible method signatures          assert isinstance(arg, str)           # error: Statement is unreachable          print("so mypy concludes the assert will always trigger")    Without``--warn-unreachable``mypy will simply not check code it deems to be   unreachable. See [unreachable](#unreachable) for more information.    .. code-block:: python       x: int = 1      assert isinstance(x, str)      reveal_type(x)  # Revealed type is "builtins.int"      print(x + '!')  # Typechecks with `mypy`, but fails in runtime.   issubclass``\` \~\~\~\~\~\~\~\~\~\~

Mypy can also use :py\`issubclass\` for better type inference when working with types and metaclasses:

`` `python    class MyCalcMeta(type):        @classmethod        def calc(cls) -> int:            ...     def f(o: object) -> None:        t = type(o)  # We must use a variable here        reveal_type(t)  # Revealed type is "builtins.type"         if issubclass(t, MyCalcMeta):  # `issubclass(type(o), MyCalcMeta)` won't work            reveal_type(t)  # Revealed type is "Type[MyCalcMeta]"            t.calc()  # Okay  callable ``\` \~\~\~\~\~\~\~\~

Mypy knows what types are callable and which ones are not during type checking. So, we know what `callable()` will return. For example:

`` `python   from collections.abc import Callable    x: Callable[[], int]    if callable(x):       reveal_type(x)  # N: Revealed type is "def () -> builtins.int"   else:       ...  # Will never be executed and will raise error with `--warn-unreachable`  The ``callable`function can even split union types into`\` callable and non-callable parts:

`` `python   from collections.abc import Callable    x: int | Callable[[], int]    if callable(x):       reveal_type(x)  # N: Revealed type is "def () -> builtins.int"   else:       reveal_type(x)  # N: Revealed type is "builtins.int"  .. _casts:  Casts ``\` -----

Mypy supports type casts that are usually used to coerce a statically typed value to a subtype. Unlike languages such as Java or C\#, however, mypy casts are only used as hints for the type checker, and they don't perform a runtime type check. Use the function :py\`\~typing.cast\` to perform a cast:

`` `python    from typing import cast     o: object = [1]    x = cast(list[int], o)  # OK    y = cast(list[str], o)  # OK (cast performs no actual runtime check)  To support runtime checking of casts such as the above, we'd have to check ``\` the types of all list items, which would be very inefficient for large lists. Casts are used to silence spurious type checker warnings and give the type checker a little help when it can't quite understand what is going on.

\> **Note** \> You can use an assertion if you want to perform an actual runtime check:

>   - \`\`\`python
>     
>       - def foo(o: object) -\> None:  
>         print(o + 5) \# Error: can't add 'object' and 'int' assert isinstance(o, int) print(o + 5) \# OK: type of 'o' is 'int' here

You don't need a cast for expressions with type `Any`, or when `` ` assigning to a variable with type ``Any`, as was explained earlier. You can also use`Any`as the cast target type -- this lets you perform any operations on the result. For example:`\`python from typing import cast, Any

> x = 1 x.whatever() \# Type check error y = cast(Any, x) y.whatever() \# Type check OK (runtime error)

<div id="type-guards">

User-Defined Type Guards `` ` ------------------------  Mypy supports User-Defined Type Guards (:pep:`647`).  A type guard is a way for programs to influence conditional type narrowing employed by a type checker based on runtime checks.  Basically, a ``TypeGuard`is a "smart" alias for a`bool`type. Let's have a look at the regular`bool`example:`\`python def is\_str\_list(val: list\[object\]) -\> bool: """Determines whether all objects in the list are strings""" return all(isinstance(x, str) for x in val)

</div>

>   - def func1(val: list\[object\]) -\> None:
>     
>       - if is\_str\_list(val):  
>         reveal\_type(val) \# Reveals list\[object\] print(" ".join(val)) \# Error: incompatible type

The same example with `TypeGuard`:

``` python
from typing import TypeGuard  # use `typing_extensions` for Python 3.9 and below

def is_str_list(val: list[object]) -> TypeGuard[list[str]]:
    """Determines whether all objects in the list are strings"""
    return all(isinstance(x, str) for x in val)

def func1(val: list[object]) -> None:
    if is_str_list(val):
        reveal_type(val)  # list[str]
        print(" ".join(val)) # ok
```

How does it work? `TypeGuard` narrows the first function argument (`val`) `` ` to the type specified as the first type parameter ( ``list\[str\]``).  > **Note** >    Narrowing is   `not strict <https://www.python.org/dev/peps/pep-0647/#enforcing-strict-narrowing>`_.   For example, you can narrow``str`to`int`:`\`python def f(value: str) -\> TypeGuard\[int\]: return True

> Note: since strict narrowing is not enforced, it's easy to break type safety.
> 
> However, there are many ways a determined or uninformed developer can subvert type safety -- most commonly by using cast or Any. If a Python developer takes the time to learn about and implement user-defined type guards within their code, it is safe to assume that they are interested in type safety and will not write their type guard functions in a way that will undermine type safety or produce nonsensical results.

Generic TypeGuards `` ` ~~~~~~~~~~~~~~~~~~ ``TypeGuard`can also work with generic types (Python 3.12 syntax):`<span class="title-ref">python from typing import TypeGuard \# use \`typing\_extensions</span> for <span class="title-ref">python\<3.10</span>

>   - def is\_two\_element\_tuple\[T\](val: tuple\[T, ...\]) -\> TypeGuard\[tuple\[T, T\]\]:  
>     return len(val) == 2
> 
>   - def func(names: tuple\[str, ...\]):
>     
>       - if is\_two\_element\_tuple(names):  
>         reveal\_type(names) \# tuple\[str, str\]
>     
>       - else:  
>         reveal\_type(names) \# tuple\[str, ...\]

TypeGuards with parameters `` ` ~~~~~~~~~~~~~~~~~~~~~~~~~~  Type guard functions can accept extra arguments (Python 3.12 syntax): ``<span class="title-ref">python from typing import TypeGuard \# use \`typing\_extensions</span> for <span class="title-ref">python\<3.10</span>

>   - def is\_set\_of\[T\](val: set\[Any\], type: type\[T\]) -\> TypeGuard\[set\[T\]\]:  
>     return all(isinstance(x, type) for x in val)
> 
> items: set\[Any\] if is\_set\_of(items, str): reveal\_type(items) \# set\[str\]

TypeGuards as methods `` ` ~~~~~~~~~~~~~~~~~~~~~  A method can also serve as a ``TypeGuard`:`\`python class StrValidator: def is\_valid(self, instance: object) -\> TypeGuard\[str\]: return isinstance(instance, str)

>   - def func(to\_validate: object) -\> None:
>     
>       - if StrValidator().is\_valid(to\_validate):  
>         reveal\_type(to\_validate) \# Revealed type is "builtins.str"

\> **Note** \> Note, that `TypeGuard` [does not narrow](https://www.python.org/dev/peps/pep-0647/#narrowing-of-implicit-self-and-cls-parameters) types of `self` or `cls` implicit arguments.

> If narrowing of `self` or `cls` is required, the value can be passed as an explicit argument to a type guard function:
> 
> ``` python
> class Parent:
>     def method(self) -> None:
>         reveal_type(self)  # Revealed type is "Parent"
>         if is_child(self):
>             reveal_type(self)  # Revealed type is "Child"
> 
> class Child(Parent):
>     ...
> 
> def is_child(instance: Parent) -> TypeGuard[Child]:
>     return isinstance(instance, Child)
> ```

Assignment expressions as TypeGuards `` ` ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Sometimes you might need to create a new variable and narrow it to some specific type at the same time. This can be achieved by using ``TypeGuard``together with `:= operator <https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions>`_.``<span class="title-ref">python from typing import TypeGuard \# use \`typing\_extensions</span> for <span class="title-ref">python\<3.10</span>

>   - def is\_float(a: object) -\> TypeGuard\[float\]:  
>     return isinstance(a, float)
> 
>   - def main(a: object) -\> None:
>     
>       - if is\_float(x := a):  
>         reveal\_type(x) \# N: Revealed type is 'builtins.float' reveal\_type(a) \# N: Revealed type is 'builtins.object'
>     
>     reveal\_type(x) \# N: Revealed type is 'builtins.object' reveal\_type(a) \# N: Revealed type is 'builtins.object'

What happens here?

1\. We create a new variable `x` and assign a value of `a` to it `` ` 2. We run ``is\_float()`type guard on`x`3. It narrows`x`to be`float`in the`if`context and does not touch`a`> **Note** >    The same will work with`isinstance(x := a, float)``as well.  Limitations -----------  Mypy's analysis is limited to individual symbols and it will not track relationships between symbols. For example, in the following code it's easy to deduce that if :code:`a` is None then :code:`b` must not be, therefore :code:`a or b` will always be an instance of :code:`C`, but Mypy will not be able to tell that:``\`python class C: pass

>   - def f(a: C | None, b: C | None) -\> C:
>     
>       - if a is not None or b is not None:  
>         return a or b \# Incompatible return value type (got "C | None", expected "C")
>     
>     return C()

Tracking these sort of cross-variable conditions in a type checker would add significant complexity `` ` and performance overhead.  You can use an ``assert`to convince the type checker, override it with a [cast <casts>](#cast-<casts>) or rewrite the function to be slightly more verbose:`\`python def f(a: C | None, b: C | None) -\> C: if a is not None: return a elif b is not None: return b return C()

<div id="typeis">

TypeIs `` ` ------  Mypy supports TypeIs (:pep:`742`).  A `TypeIs narrowing function <https://typing.readthedocs.io/en/latest/spec/narrowing.html#typeis>`_ allows you to define custom type checks that can narrow the type of a variable in `both the if and else <https://docs.python.org/3.13/library/typing.html#typing.TypeIs>`_ branches of a conditional, similar to how the built-in isinstance() function works.  TypeIs is new in Python 3.13 — for use in older Python versions, use the backport from `typing_extensions <https://typing-extensions.readthedocs.io/en/latest/>`_  Consider the following example using TypeIs: ``\`python from typing import TypeIs

</div>

>   - def is\_str(x: object) -\> TypeIs\[str\]:  
>     return isinstance(x, str)
> 
>   - def process(x: int | str) -\> None:
>     
>       - if is\_str(x):  
>         reveal\_type(x) \# Revealed type is 'str' print(x.upper()) \# Valid: x is str
>     
>       - else:  
>         reveal\_type(x) \# Revealed type is 'int' print(x + 1) \# Valid: x is int

In this example, the function is\_str is a type narrowing function `` ` that returns TypeIs[str]. When used in an if statement, x is narrowed to str in the if branch and to int in the else branch.  Key points:   - The function must accept at least one positional argument.  - The return type is annotated as ``TypeIs\[T\]`, where`T`is the type you   want to narrow to.  - The function must return a`bool`value.  - In the`if`branch (when the function returns`True`), the type of the   argument is narrowed to the intersection of its original type and`T`.  - In the`else`branch (when the function returns`False`), the type of   the argument is narrowed to the intersection of its original type and the   complement of`T`.   TypeIs vs TypeGuard ~~~~~~~~~~~~~~~~~~~  While both TypeIs and TypeGuard allow you to define custom type narrowing functions, they differ in important ways:  - **Type narrowing behavior**: TypeIs narrows the type in both the if and else branches,   whereas TypeGuard narrows only in the if branch.  - **Compatibility requirement**: TypeIs requires that the narrowed type T be   compatible with the input type of the function. TypeGuard does not have this restriction.  - **Type inference**: With TypeIs, the type checker may infer a more precise type by   combining existing type information with T.  Here's an example demonstrating the behavior with TypeGuard:`\`python from typing import TypeGuard, reveal\_type

>   - def is\_str(x: object) -\> TypeGuard\[str\]:  
>     return isinstance(x, str)
> 
>   - def process(x: int | str) -\> None:
>     
>       - if is\_str(x):  
>         reveal\_type(x) \# Revealed type is "builtins.str" print(x.upper()) \# ok: x is str
>     
>       - else:  
>         reveal\_type(x) \# Revealed type is "Union\[builtins.int, builtins.str\]" print(x + 1) \# ERROR: Unsupported operand types for + ("str" and "int") \[operator\]

Generic TypeIs `` ` ~~~~~~~~~~~~~~ ``TypeIs`functions can also work with generic types:`\`python from typing import TypeVar, TypeIs

> T = TypeVar('T')
> 
>   - def is\_two\_element\_tuple(val: tuple\[T, ...\]) -\> TypeIs\[tuple\[T, T\]\]:  
>     return len(val) == 2
> 
>   - def process(names: tuple\[str, ...\]) -\> None:
>     
>       - if is\_two\_element\_tuple(names):  
>         reveal\_type(names) \# Revealed type is 'tuple\[str, str\]'
>     
>       - else:  
>         reveal\_type(names) \# Revealed type is 'tuple\[str, ...\]'

TypeIs with Additional Parameters `` ` ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TypeIs functions can accept additional parameters beyond the first. The type narrowing applies only to the first argument. ``\`python from typing import Any, TypeVar, reveal\_type, TypeIs

> T = TypeVar('T')
> 
>   - def is\_instance\_of(val: Any, typ: type\[T\]) -\> TypeIs\[T\]:  
>     return isinstance(val, typ)
> 
>   - def process(x: Any) -\> None:
>     
>       - if is\_instance\_of(x, int):  
>         reveal\_type(x) \# Revealed type is 'int' print(x + 1) \# ok
>     
>       - else:  
>         reveal\_type(x) \# Revealed type is 'Any'

TypeIs in Methods `` ` ~~~~~~~~~~~~~~~~~  A method can also serve as a ``TypeIs`function. Note that in instance or class methods, the type narrowing applies to the second parameter (after`self`or`cls`).`\`python class Validator: def is\_valid(self, instance: object) -\> TypeIs\[str\]: return isinstance(instance, str)

>   - def process(self, to\_validate: object) -\> None:
>     
>       - if Validator().is\_valid(to\_validate):  
>         reveal\_type(to\_validate) \# Revealed type is 'str' print(to\_validate.upper()) \# ok: to\_validate is str

Assignment Expressions with TypeIs `` ` ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  You can use the assignment expression operator ``:=`with`TypeIs`to create a new variable and narrow its type simultaneously.`\`python from typing import TypeIs, reveal\_type

  - def is\_float(x: object) -\> TypeIs\[float\]:  
    return isinstance(x, float)

  - def main(a: object) -\> None:
    
      - if is\_float(x := a):  
        reveal\_type(x) \# Revealed type is 'float' \# x is narrowed to float in this block print(x + 1.0)

\`\`\`

---

typed_dict.md

---

# TypedDict

Python programs often use dictionaries with string keys to represent objects. `TypedDict` lets you give precise types for dictionaries that represent objects with a fixed schema, such as `{'id': 1, 'items': ['x']}`.

Here is a typical example:

`` `python    movie = {'name': 'Blade Runner', 'year': 1982}  Only a fixed set of string keys is expected ( ``'name'`and`<span class="title-ref"> </span><span class="title-ref">'year'</span><span class="title-ref"> above), and each key has an independent value type (</span><span class="title-ref">str</span><span class="title-ref"> for </span><span class="title-ref">'name'</span><span class="title-ref"> and </span><span class="title-ref">int</span><span class="title-ref"> for </span><span class="title-ref">'year'</span><span class="title-ref"> above). We've previously seen the </span><span class="title-ref">dict\[K, V\]</span><span class="title-ref"> type, which lets you declare uniform dictionary types, where every value has the same type, and arbitrary keys are supported. This is clearly not a good fit for </span><span class="title-ref">movie</span><span class="title-ref"> above. Instead, you can use a </span><span class="title-ref">TypedDict</span><span class="title-ref"> to give a precise type for objects like </span><span class="title-ref">movie</span>\`, where the type of each dictionary value depends on the key:

`` `python    from typing import TypedDict     Movie = TypedDict('Movie', {'name': str, 'year': int})     movie: Movie = {'name': 'Blade Runner', 'year': 1982} ``Movie`is a`TypedDict`type with two items:`'name'`(with type`str`)`<span class="title-ref"> and </span><span class="title-ref">'year'</span><span class="title-ref"> (with type </span><span class="title-ref">int</span><span class="title-ref">). Note that we used an explicit type annotation for the </span><span class="title-ref">movie</span><span class="title-ref"> variable. This type annotation is important -- without it, mypy will try to infer a regular, uniform :py\`dict</span> type for `movie`, which is not what we want here.

\> **Note** \> If you pass a `TypedDict` object as an argument to a function, no type annotation is usually necessary since mypy can infer the desired type based on the declared argument type. Also, if an assignment target has been previously defined, and it has a `TypedDict` type, mypy will treat the assigned value as a `TypedDict`, not :py\`dict\`.

Now mypy will recognize these as valid:

`` `python    name = movie['name']  # Okay; type of name is str    year = movie['year']  # Okay; type of year is int  Mypy will detect an invalid key as an error:  .. code-block:: python     director = movie['director']  # Error: 'director' is not a valid key  Mypy will also reject a runtime-computed expression as a key, as ``<span class="title-ref"> it can't verify that it's a valid key. You can only use string literals as </span><span class="title-ref">TypedDict</span>\` keys.

The `TypedDict` type object can also act as a constructor. It returns a normal :py\`dict\` object at runtime -- a `TypedDict` does not define a new runtime type:

`` `python    toy_story = Movie(name='Toy Story', year=1995)  This is equivalent to just constructing a dictionary directly using ``<span class="title-ref"> </span><span class="title-ref">{ ... }</span><span class="title-ref"> or </span><span class="title-ref">dict(key=value, ...)</span>\`. The constructor form is sometimes convenient, since it can be used without a type annotation, and it also makes the type of the object explicit.

Like all types, `TypedDict`s can be used as components to build arbitrarily complex types. For example, you can define nested `TypedDict`s and containers with `TypedDict` items. Unlike most other types, mypy uses structural compatibility checking (or structural subtyping) with `TypedDict`s. A `TypedDict` object with extra items is compatible with (a subtype of) a narrower `TypedDict`, assuming item types are compatible (*totality* also affects subtyping, as discussed below).

A `TypedDict` object is not a subtype of the regular `dict[...]` type (and vice versa), since :py\`dict\` allows arbitrary keys to be added and removed, unlike `TypedDict`. However, any `TypedDict` object is a subtype of (that is, compatible with) `Mapping[str, object]`, since :py\`\~collections.abc.Mapping\` only provides read-only access to the dictionary items:

`` `python    def print_typed_dict(obj: Mapping[str, object]) -> None:        for key, value in obj.items():            print(f'{key}: {value}')     print_typed_dict(Movie(name='Toy Story', year=1995))  # OK  > **Note** >     Unless you are on Python 3.8 or newer (where ``TypedDict``is available in    standard library :py:mod:`typing` module) you need to install``typing\_extensions`using pip to use`TypedDict`:     .. code-block:: text        python3 -m pip install --upgrade typing-extensions  Totality`\` --------

By default mypy ensures that a `TypedDict` object has all the specified keys. This will be flagged as an error:

`` `python    # Error: 'year' missing    toy_story: Movie = {'name': 'Toy Story'}  Sometimes you want to allow keys to be left out when creating a ``<span class="title-ref"> </span><span class="title-ref">TypedDict</span><span class="title-ref"> object. You can provide the </span><span class="title-ref">total=False</span><span class="title-ref"> argument to </span><span class="title-ref">TypedDict(...)</span>\` to achieve this:

`` `python    GuiOptions = TypedDict(        'GuiOptions', {'language': str, 'color': str}, total=False)    options: GuiOptions = {}  # Okay    options['language'] = 'en'  You may need to use :py`~dict.get` to access items of a partial (non-total) ``<span class="title-ref"> </span><span class="title-ref">TypedDict</span><span class="title-ref">, since indexing using </span><span class="title-ref">\[\]</span><span class="title-ref"> could fail at runtime. However, mypy still lets use </span><span class="title-ref">\[\]</span><span class="title-ref"> with a partial </span><span class="title-ref">TypedDict</span><span class="title-ref"> -- you just need to be careful with it, as it could result in a :py\`KeyError</span>. Requiring :py\`\~dict.get\` everywhere would be too cumbersome. (Note that you are free to use :py\`\~dict.get\` with total `TypedDict`s as well.)

Keys that aren't required are shown with a `?` in error messages:

`` `python    # Revealed type is "TypedDict('GuiOptions', {'language'?: builtins.str,    #                                            'color'?: builtins.str})"    reveal_type(options)  Totality also affects structural compatibility. You can't use a partial ``<span class="title-ref"> </span><span class="title-ref">TypedDict</span><span class="title-ref"> when a total one is expected. Also, a total </span><span class="title-ref">TypedDict</span>\` is not valid when a partial one is expected.

## Supported operations

`TypedDict` objects support a subset of dictionary operations and methods. You must use string literals as keys when calling most of the methods, as otherwise mypy won't be able to check that the key is valid. List of supported operations:

  - Anything included in :py\`\~collections.abc.Mapping\`:
      - `d[key]`
      - `key in d`
      - `len(d)`
      - `for key in d` (iteration)
      - :py\`d.get(key\[, default\]) \<dict.get\>\`
      - :py\`d.keys() \<dict.keys\>\`
      - :py\`d.values() \<dict.values\>\`
      - :py\`d.items() \<dict.items\>\`
  - :py\`d.copy() \<dict.copy\>\`
  - :py\`d.setdefault(key, default) \<dict.setdefault\>\`
  - :py\`d1.update(d2) \<dict.update\>\`
  - :py\`d.pop(key\[, default\]) \<dict.pop\><span class="title-ref"> (partial </span><span class="title-ref">TypedDict</span>\`s only)
  - `del d[key]` (partial `TypedDict`s only)

\> **Note** \> :py\`\~dict.clear\` and :py\`\~dict.popitem\` are not supported since they are unsafe -- they could delete required `TypedDict` items that are not visible to mypy because of structural subtyping.

## Class-based syntax

An alternative, class-based syntax to define a `TypedDict` is supported in Python 3.6 and later:

`` `python    from typing import TypedDict  # "from typing_extensions" in Python 3.7 and earlier     class Movie(TypedDict):        name: str        year: int  The above definition is equivalent to the original ``Movie`  `<span class="title-ref"> definition. It doesn't actually define a real class. This syntax also supports a form of inheritance -- subclasses can define additional items. However, this is primarily a notational shortcut. Since mypy uses structural compatibility with </span><span class="title-ref">TypedDict</span>\`s, inheritance is not required for compatibility. Here is an example of inheritance:

`` `python    class Movie(TypedDict):        name: str        year: int     class BookBasedMovie(Movie):        based_on: str  Now ``BookBasedMovie`has keys`name`,`year`and`based\_on`.  Mixing required and non-required items`\` --------------------------------------

In addition to allowing reuse across `TypedDict` types, inheritance also allows you to mix required and non-required (using `total=False`) items in a single `TypedDict`. Example:

`` `python    class MovieBase(TypedDict):        name: str        year: int     class Movie(MovieBase, total=False):        based_on: str  Now ``Movie`has required keys`name`and`year`, while`based\_on`  `<span class="title-ref"> can be left out when constructing an object. A </span><span class="title-ref">TypedDict</span><span class="title-ref"> with a mix of required and non-required keys, such as </span><span class="title-ref">Movie</span><span class="title-ref"> above, will only be compatible with another </span><span class="title-ref">TypedDict</span><span class="title-ref"> if all required keys in the other </span><span class="title-ref">TypedDict</span><span class="title-ref"> are required keys in the first </span><span class="title-ref">TypedDict</span><span class="title-ref">, and all non-required keys of the other </span><span class="title-ref">TypedDict</span><span class="title-ref"> are also non-required keys in the first </span><span class="title-ref">TypedDict</span>\`.

## Read-only items

You can use `typing.ReadOnly`, introduced in Python 3.13, or `typing_extensions.ReadOnly` to mark TypedDict items as read-only (`705`):

`` `python     from typing import TypedDict      # Or "from typing ..." on Python 3.13+     from typing_extensions import ReadOnly      class Movie(TypedDict):         name: ReadOnly[str]         num_watched: int      m: Movie = {"name": "Jaws", "num_watched": 1}     m["name"] = "The Godfather"  # Error: "name" is read-only     m["num_watched"] += 1  # OK  A TypedDict with a mutable item can be assigned to a TypedDict ``\` with a corresponding read-only item, and the type of the item can vary \[covariantly \<variance-of-generics\>\](\#covariantly-\<variance-of-generics\>):

`` `python     class Entry(TypedDict):         name: ReadOnly[str | None]         year: ReadOnly[int]      class Movie(TypedDict):         name: str         year: int      def process_entry(i: Entry) -> None: ...      m: Movie = {"name": "Jaws", "year": 1975}     process_entry(m)  # OK  Unions of TypedDicts ``\` --------------------

Since TypedDicts are really just regular dicts at runtime, it is not possible to use `isinstance` checks to distinguish between different variants of a Union of TypedDict in the same way you can with regular objects.

Instead, you can use the \[tagged union pattern \<tagged\_unions\>\](\#tagged-union-pattern-\<tagged\_unions\>). The referenced section of the docs has a full description with an example, but in short, you will need to give each TypedDict the same key where each value has a unique \[Literal type \<literal\_types\>\](\#literal-type-\<literal\_types\>). Then, check that key to distinguish between your TypedDicts.

## Inline TypedDict types

\> **Note** \> This is an experimental (non-standard) feature. Use `--enable-incomplete-feature=InlineTypedDict` to enable.

Sometimes you may want to define a complex nested JSON schema, or annotate a one-off function that returns a TypedDict. In such cases it may be convenient to use inline TypedDict syntax. For example:

`` `python     def test_values() -> {"int": int, "str": str}:         return {"int": 42, "str": "test"}      class Response(TypedDict):         status: int         msg: str         # Using inline syntax here avoids defining two additional TypedDicts.         content: {"items": list[{"key": str, "value": str}]}  Inline TypedDicts can also by used as targets of type aliases, but due to ``\` ambiguity with a regular variables it is only allowed for (newer) explicit type alias forms:

`` `python     from typing import TypeAlias      X = {"a": int, "b": int}  # creates a variable with type dict[str, type[int]]     Y: TypeAlias = {"a": int, "b": int}  # creates a type alias     type Z = {"a": int, "b": int}  # same as above (Python 3.12+ only)  Also, due to incompatibility with runtime type-checking it is strongly recommended ``\` to *not* use inline syntax in union types.

---

bool_operations.md

---

# Native boolean operations

Operations on `bool` values that are listed here have fast, optimized implementations.

## Construction

  - `True`
  - `False`
  - `bool(obj)`

## Operators

  - `b1 and b2`
  - `b1 or b2`
  - `not b`

## Functions

  - `any(expr for ... in ...)`
  - `all(expr for ... in ...)`

---

compilation_units.md

---

# Compilation units

When you run mypyc to compile a set of modules, these modules form a *compilation unit*. Mypyc will use early binding for references within the compilation unit.

If you run mypyc multiple times to compile multiple sets of modules, each invocation will result in a new compilation unit. References between separate compilation units will fall back to late binding, i.e. looking up names using Python namespace dictionaries. Also, all calls will use the slower Python calling convention, where arguments and the return value will be boxed (and potentially unboxed again in the called function).

For maximal performance, minimize interactions across compilation units. The simplest way to achieve this is to compile your entire program as a single compilation unit.

---

dict_operations.md

---

# Native dict operations

These `dict` operations have fast, optimized implementations. Other dictionary operations use generic implementations that are often slower.

## Construction

Construct dict from keys and values:

  - `{key: value,  ...}`

Construct empty dict:

  - `{}`
  - `dict()`

Construct dict from another object:

  - `dict(d: dict)`
  - `dict(x: Iterable)`

Dict comprehensions:

  - `{...: ... for ... in ...}`
  - `{...: ... for ... in ... if ...}`

## Operators

  - `d[key]`
  - `value in d`

## Statements

  - `d[key] = value`
  - `for key in d:`

## Methods

  - `d.get(key)`
  - `d.get(key, default)`
  - `d.keys()`
  - `d.values()`
  - `d.items()`
  - `d.copy()`
  - `d.clear()`
  - `d1.update(d2: dict)`
  - `d.update(x: Iterable)`

## Functions

  - `len(d: dict)`

---

differences_from_python.md

---

# Differences from Python

Mypyc aims to be sufficiently compatible with Python semantics so that migrating code to mypyc often doesn't require major code changes. There are various differences to enable performance gains that you need to be aware of, however.

This section documents notable differences from Python. We discuss many of them also elsewhere, but it's convenient to have them here in one place.

## Running compiled modules

You can't use `python3 <module>.py` or `python3 -m <module>` to run compiled modules. Use `python3 -c "import <module>"` instead, or write a wrapper script that imports your module.

As a side effect, you can't rely on checking the `__name__` attribute in compiled code, like this:

    if __name__ == "__main__":  # Can't be used in compiled code
        main()

## Type errors prevent compilation

You can't compile code that generates mypy type check errors. You can sometimes ignore these with a `# type: ignore` comment, but this can result in bad code being generated, and it's considered dangerous.

\> **Note** \> In the future, mypyc may reject `# type: ignore` comments that may be unsafe.

## Runtime type checking

Non-erased types in annotations will be type checked at runtime. For example, consider this function:

    def twice(x: int) -> int:
        return x * 2

If you try to call this function with a `float` or `str` argument, you'll get a type error on the call site, even if the call site is not being type checked:

    twice(5)  # OK
    twice(2.2)  # TypeError
    twice("blah")  # TypeError

Also, values with *inferred* types will be type checked. For example, consider a call to the stdlib function `socket.gethostname()` in compiled code. This function is not compiled (no stdlib modules are compiled with mypyc), but mypyc uses a *library stub file* to infer the return type as `str`. Compiled code calling `gethostname()` will fail with `TypeError` if `gethostname()` would return an incompatible value, such as `None`:

    import socket
    
    # Fail if returned value is not a str
    name = socket.gethostname()

Note that `gethostname()` is defined like this in the stub file for `socket` (in typeshed):

    def gethostname() -> str: ...

Thus mypyc verifies that library stub files and annotations in non-compiled code match runtime values. This adds an extra layer of type safety.

Casts such as `cast(str, x)` will also result in strict type checks. Consider this example:

    from typing import cast
    ...
    x = cast(str, y)

The last line is essentially equivalent to this Python code when compiled:

    if not isinstance(y, str):
        raise TypeError(...)
    x = y

In interpreted mode `cast` does not perform a runtime type check.

## Native classes

Native classes behave differently from Python classes. See \[native-classes\](\#native-classes) for the details.

## Primitive types

Some primitive types behave differently in compiled code to improve performance.

`int` objects use an unboxed (non-heap-allocated) representation for small integer values. A side effect of this is that the exact runtime type of `int` values is lost. For example, consider this simple function:

    def first_int(x: List[int]) -> int:
        return x[0]
    
    print(first_int([True]))  # Output is 1, instead of True!

`bool` is a subclass of `int`, so the above code is valid. However, when the list value is converted to `int`, `True` is converted to the corresponding `int` value, which is `1`.

Note that integers still have an arbitrary precision in compiled code, similar to normal Python integers.

Fixed-length tuples are unboxed, similar to integers. The exact type and identity of fixed-length tuples is not preserved, and you can't reliably use `is` checks to compare tuples that are used in compiled code.

## Early binding

References to functions, types, most attributes, and methods in the same \[compilation unit \<compilation-units\>\](\#compilation-unit-\<compilation-units\>) use *early binding*: the target of the reference is decided at compile time, whenever possible. This contrasts with normal Python behavior of *late binding*, where the target is found by a namespace lookup at runtime. Omitting these namespace lookups improves performance, but some Python idioms don't work without changes.

Note that non-final module-level variables still use late binding. You may want to avoid these in very performance-critical code.

Examples of early and late binding:

    from typing import Final
    
    import lib  # "lib" is not compiled
    
    x = 0
    y: Final = 1
    
    def func() -> None:
        pass
    
    class Cls:
        def __init__(self, attr: int) -> None:
            self.attr = attr
    
        def method(self) -> None:
            pass
    
    def example() -> None:
        # Early binding:
        var = y
        func()
        o = Cls()
        o.x
        o.method()
    
        # Late binding:
        var = x  # Module-level variable
        lib.func()  # Accessing library that is not compiled

## Pickling and copying objects

Mypyc tries to enforce that instances native classes are properly initialized by calling `__init__` implicitly when constructing objects, even if objects are constructed through `pickle`, `copy.copy` or `copy.deepcopy`, for example.

If a native class doesn't support calling `__init__` without arguments, you can't pickle or copy instances of the class. Use the `mypy_extensions.mypyc_attr` class decorator to override this behavior and enable pickling through the `serializable` flag:

    from mypy_extensions import mypyc_attr
    import pickle
    
    @mypyc_attr(serializable=True)
    class Cls:
        def __init__(self, n: int) -> None:
            self.n = n
    
    data = pickle.dumps(Cls(5))
    obj = pickle.loads(data)  # OK

Additional notes:

  - All subclasses inherit the `serializable` flag.
  - If a class has the `allow_interpreted_subclasses` attribute, it implicitly supports serialization.
  - Enabling serialization may slow down attribute access, since compiled code has to be always prepared to raise `AttributeError` in case an attribute is not defined at runtime.
  - If you try to pickle an object without setting the `serializable` flag, you'll get a `TypeError` about missing arguments to `__init__`.

## Monkey patching

Since mypyc function and class definitions are immutable, you can't perform arbitrary monkey patching, such as replacing functions or methods with mocks in tests.

\> **Note** \> Each compiled module has a Python namespace that is initialized to point to compiled functions and type objects. This namespace is a regular `dict` object, and it *can* be modified. However, compiled code generally doesn't use this namespace, so any changes will only be visible to non-compiled code.

## Stack overflows

Compiled code currently doesn't check for stack overflows. Your program may crash in an unrecoverable fashion if you have too many nested function calls, typically due to out-of-control recursion.

\> **Note** \> This limitation will be fixed in the future.

## Final values

Compiled code replaces a reference to an attribute declared `Final` with the value of the attribute computed at compile time. This is an example of \[early binding \<early-binding\>\](\#early-binding-\<early-binding\>). Example:

    MAX: Final = 100
    
    def limit_to_max(x: int) -> int:
         if x > MAX:
             return MAX
         return x

The two references to `MAX` don't involve any module namespace lookups, and are equivalent to this code:

    def limit_to_max(x: int) -> int:
         if x > 100:
             return 100
         return x

When run as interpreted, the first example will execute slower due to the extra namespace lookups. In interpreted code final attributes can also be modified.

## Unsupported features

Some Python features are not supported by mypyc (yet). They can't be used in compiled code, or there are some limitations. You can partially work around some of these limitations by running your code in interpreted mode.

### Nested classes

Nested classes are not supported.

### Conditional functions or classes

Function and class definitions guarded by an if-statement are not supported.

### Dunder methods

Native classes **cannot** use these dunders. If defined, they will not work as expected.

  - `__del__`
  - `__index__`
  - `__getattr__`, `__getattribute__`
  - `__setattr__`
  - `__delattr__`

### Generator expressions

Generator expressions are not supported. To make it easier to compile existing code, they are implicitly replaced with list comprehensions. *This does not always produce the same behavior.*

To work around this limitation, you can usually use a generator function instead. You can sometimes replace the generator expression with an explicit list comprehension.

### Descriptors

Native classes can't contain arbitrary descriptors. Properties, static methods and class methods are supported.

### Introspection

Various methods of introspection may break by using mypyc. Here's an non-exhaustive list of what won't work:

  - Instance `__annotations__` is usually not kept
  - Frames of compiled functions can't be inspected using `inspect`
  - Compiled methods aren't considered methods by `inspect.ismethod`
  - `inspect.signature` chokes on compiled functions

### Profiling hooks and tracing

Compiled functions don't trigger profiling and tracing hooks, such as when using the `profile`, `cProfile`, or `trace` modules.

### Debuggers

You can't set breakpoints in compiled functions or step through compiled functions using `pdb`. Often you can debug your code in interpreted mode instead.

---

float_operations.md

---

# Native float operations

These `float` operations have fast, optimized implementations. Other floating point operations use generic implementations that are often slower.

## Construction

  - Float literal
  - `float(x: int)`
  - `float(x: i64)`
  - `float(x: i32)`
  - `float(x: i16)`
  - `float(x: u8)`
  - `float(x: str)`
  - `float(x: float)` (no-op)

## Operators

  - Arithmetic (`+`, `-`, `*`, `/`, `//`, `%`)
  - Comparisons (`==`, `!=`, `<`, etc.)
  - Augmented assignment (`x += y`, etc.)

## Functions

  - `int(f)`
  - `i64(f)` (convert to 64-bit signed integer)
  - `i32(f)` (convert to 32-bit signed integer)
  - `i16(f)` (convert to 16-bit signed integer)
  - `u8(f)` (convert to 8-bit unsigned integer)
  - `abs(f)`
  - `math.sin(f)`
  - `math.cos(f)`
  - `math.tan(f)`
  - `math.sqrt(f)`
  - `math.exp(f)`
  - `math.log(f)`
  - `math.floor(f)`
  - `math.ceil(f)`
  - `math.fabs(f)`
  - `math.pow(x, y)`
  - `math.copysign(x, y)`
  - `math.isinf(f)`
  - `math.isnan(f)`

---

getting_started.md

---

# Getting started

Here you will learn some basic things you need to know to get started with mypyc.

## Prerequisites

You need a Python C extension development environment. The way to set this up depends on your operating system.

### macOS

Install Xcode command line tools:

    $ xcode-select --install

### Linux

You need a C compiler and CPython headers and libraries. The specifics of how to install these varies by distribution. Here are instructions for Ubuntu 18.04, for example:

    $ sudo apt install python3-dev

### Windows

From [Build Tools for Visual Studio 2022](https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2022), install MSVC C++ build tools for your architecture and a Windows SDK. (latest versions recommended)

## Installation

Mypyc is shipped as part of the mypy distribution. Install mypy like this (you need Python 3.8 or later):

    $ python3 -m pip install -U 'mypy[mypyc]'

On some systems you need to use this instead:

    $ python -m pip install -U 'mypy[mypyc]'

## Example program

Let's start with a classic micro-benchmark, recursive fibonacci. Save this file as `fib.py`:

`` `python    import time     def fib(n: int) -> int:        if n <= 1:            return n        else:            return fib(n - 2) + fib(n - 1)     t0 = time.time()    fib(32)    print(time.time() - t0)  Note that we gave the ``fib`function a type annotation. Without it,`\` performance won't be as impressive after compilation.

\> **Note** \> [Mypy documentation](https://mypy.readthedocs.io/en/stable/index.html) is a good introduction if you are new to type annotations or mypy. Mypyc uses mypy to perform type checking and type inference, so some familiarity with mypy is very useful.

## Compiling and running

We can run `fib.py` as a regular, interpreted program using CPython:

`` `console     $ python3 fib.py     0.4125328063964844  It took about 0.41s to run on my computer.  Run ``mypyc`to compile the program to a binary C extension:  .. code-block:: console      $ mypyc fib.py  This will generate a C extension for`fib`in the current working`<span class="title-ref"> directory. For example, on a Linux system the generated file may be called </span><span class="title-ref">fib.cpython-37m-x86\_64-linux-gnu.so</span>\`.

Since C extensions can't be run as programs, use `python3 -c` to run the compiled module as a program:

`` `console     $ python3 -c "import fib"     0.04097270965576172  After compilation, the program is about 10x faster. Nice!  > **Note** > ``\_\_name\_\_`in`fib.py`would now be`"fib"`, not`"\_\_main\_\_"`.  You can also pass most`<span class="title-ref"> \`mypy command line options \<https://mypy.readthedocs.io/en/stable/command\_line.html\></span>\_ to `mypyc`.

## Deleting compiled binary

You can manually delete the C extension to get back to an interpreted version (this example works on Linux):

    $ rm fib.*.so

## Using setup.py

You can also use `setup.py` to compile modules using mypyc. Here is an example `setup.py` file:

    from setuptools import setup
    
    from mypyc.build import mypycify
    
    setup(
        name='mylib',
        packages=['mylib'],
        ext_modules=mypycify([
            'mylib/__init__.py',
            'mylib/mod.py',
        ]),
    )

We used `mypycify(...)` to specify which files to compile using mypyc. Your `setup.py` can include additional Python files outside `mypycify(...)` that won't be compiled.

Now you can build a wheel (.whl) file for the package:

    python3 setup.py bdist_wheel

The wheel is created under `dist/`.

You can also compile the C extensions in-place, in the current directory (similar to using `mypyc` to compile modules):

    python3 setup.py build_ext --inplace

You can include most [mypy command line options](https://mypy.readthedocs.io/en/stable/command_line.html) in the list of arguments passed to `mypycify()`. For example, here we use the `--disallow-untyped-defs` flag to require that all functions have type annotations:

    ...
    setup(
        name='frobnicate',
        packages=['frobnicate'],
        ext_modules=mypycify([
            '--disallow-untyped-defs',  # Pass a mypy flag
            'frobnicate.py',
        ]),
    )

## Recommended workflow

A simple way to use mypyc is to always compile your code after any code changes, but this can get tedious, especially if you have a lot of code. Instead, you can do most development in interpreted mode. This development workflow has worked smoothly for developing mypy and mypyc (often we forget that we aren't working on a vanilla Python project):

1.  During development, use interpreted mode. This gives you a fast edit-run cycle.
2.  Use type annotations liberally and use mypy to type check your code during development. Mypy and tests can find most errors that would break your compiled code, if you have good type annotation coverage. (Running mypy is pretty quick.)
3.  After you've implemented a feature or a fix, compile your project and run tests again, now in compiled mode. Usually nothing will break here, assuming your type annotation coverage is good. This can happen locally or in a Continuous Integration (CI) job. If you have CI, compiling locally may be rarely needed.
4.  Release or deploy a compiled version. Optionally, include a fallback interpreted version for platforms that mypyc doesn't support.

This mypyc workflow only involves minor tweaks to a typical Python workflow. Most of development, testing and debugging happens in interpreted mode. Incremental mypy runs, especially when using the mypy daemon, are very quick (often a few hundred milliseconds).

## Next steps

You can sometimes get good results by just annotating your code and compiling it. If this isn't providing meaningful performance gains, if you have trouble getting your code to work under mypyc, or if you want to optimize your code for maximum performance, you should read the rest of the documentation in some detail.

Here are some specific recommendations, or you can just read the documentation in order:

  - \[using-type-annotations\](\#using-type-annotations)
  - \[native-classes\](\#native-classes)
  - \[differences-from-python\](\#differences-from-python)
  - \[performance-tips\](\#performance-tips)

---

index.md

---

# Welcome to mypyc documentation\!

Mypyc compiles Python modules to C extensions. It uses standard Python [type hints](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html) to generate fast code.

<div class="toctree" data-maxdepth="2" data-caption="First steps">

introduction getting\_started

</div>

<div class="toctree" data-maxdepth="2" data-caption="Using mypyc">

using\_type\_annotations native\_classes differences\_from\_python compilation\_units

</div>

<div class="toctree" data-maxdepth="2" data-caption="Native operations reference">

native\_operations int\_operations bool\_operations float\_operations str\_operations list\_operations dict\_operations set\_operations tuple\_operations

</div>

<div class="toctree" data-maxdepth="2" data-caption="Advanced topics">

performance\_tips\_and\_tricks

</div>

<div class="toctree" hidden="" data-caption="Project Links">

GitHub \<<https://github.com/python/mypy>\>

</div>

# Indices and tables

  - \[genindex\](\#genindex)
  - \[modindex\](\#modindex)
  - \[search\](\#search)

---

int_operations.md

---

# Native integer operations

Mypyc supports these integer types:

  - `int` (arbitrary-precision integer)
  - `i64` (64-bit signed integer)
  - `i32` (32-bit signed integer)
  - `i16` (16-bit signed integer)
  - `u8` (8-bit unsigned integer)

`i64`, `i32`, `i16` and `u8` are *native integer types* and are available in the `mypy_extensions` module. `int` corresponds to the Python `int` type, but uses a more efficient runtime representation (tagged pointer). Native integer types are value types.

All integer types have optimized primitive operations, but the native integer types are more efficient than `int`, since they don't require range or bounds checks.

Operations on integers that are listed here have fast, optimized implementations. Other integer operations use generic implementations that are generally slower. Some operations involving integers and other types, such as list indexing, are documented elsewhere.

## Construction

`int` type:

  - Integer literal
  - `int(x: float)`
  - `int(x: i64)`
  - `int(x: i32)`
  - `int(x: i16)`
  - `int(x: u8)`
  - `int(x: str)`
  - `int(x: str, base: int)`
  - `int(x: int)` (no-op)

`i64` type:

  - `i64(x: int)`
  - `i64(x: float)`
  - `i64(x: i64)` (no-op)
  - `i64(x: i32)`
  - `i64(x: i16)`
  - `i64(x: u8)`
  - `i64(x: str)`
  - `i64(x: str, base: int)`

`i32` type:

  - `i32(x: int)`
  - `i32(x: float)`
  - `i32(x: i64)` (truncate)
  - `i32(x: i32)` (no-op)
  - `i32(x: i16)`
  - `i32(x: u8)`
  - `i32(x: str)`
  - `i32(x: str, base: int)`

`i16` type:

  - `i16(x: int)`
  - `i16(x: float)`
  - `i16(x: i64)` (truncate)
  - `i16(x: i32)` (truncate)
  - `i16(x: i16)` (no-op)
  - `i16(x: u8)`
  - `i16(x: str)`
  - `i16(x: str, base: int)`

Conversions from `int` to a native integer type raise `OverflowError` if the value is too large or small. Conversions from a wider native integer type to a narrower one truncate the value and never fail. More generally, operations between native integer types don't check for overflow.

## Implicit conversions

`int` values can be implicitly converted to a native integer type, for convenience. This means that these are equivalent:

    from mypy_extensions import i64
    
    def implicit() -> None:
        # Implicit conversion of 0 (int) to i64
        x: i64 = 0
    
    def explicit() -> None:
        # Explicit conversion of 0 (int) to i64
        x = i64(0)

Similarly, a native integer value can be implicitly converted to an arbitrary-precision integer. These two functions are equivalent:

    def implicit(x: i64) -> int:
        # Implicit conversion from i64 to int
        return x
    
    def explicit(x: i64) -> int:
        # Explicit conversion from i64 to int
        return int(x)

## Operators

  - Arithmetic (`+`, `-`, `*`, `//`, `/`, `%`)
  - Bitwise operations (`&`, `|`, `^`, `<<`, `>>`, `~`)
  - Comparisons (`==`, `!=`, `<`, etc.)
  - Augmented assignment (`x += y`, etc.)

If one of the above native integer operations overflows or underflows with signed operands, the behavior is undefined. Signed native integer types should only be used if all possible values are small enough for the type. For this reason, the arbitrary-precision `int` type is recommended for signed values unless the performance of integer operations is critical.

Operations on unsigned integers (`u8`) wrap around on overflow.

It's a compile-time error to mix different native integer types in a binary operation such as addition. An explicit conversion is required:

    from mypy_extensions import i64, i32
    
    def add(x: i64, y: i32) -> None:
        a = x + y  # Error (i64 + i32)
        b = x + i64(y)  # OK

You can freely mix a native integer value and an arbitrary-precision `int` value in an operation. The native integer type is "sticky" and the `int` operand is coerced to the native integer type:

    def example(x: i64, y: int) -> None:
        a = x * y
        # Type of "a" is "i64"
        ...
        b = 1 - x
        # Similarly, type of "b" is "i64"

## Statements

For loop over a range is compiled efficiently, if the `range(...)` object is constructed in the for statement (after `in`):

  - `for x in range(end)`
  - `for x in range(start, end)`
  - `for x in range(start, end, step)`

If one of the arguments to `range` in a for loop is a native integer type, the type of the loop variable is inferred to have this native integer type, instead of `int`:

    for x in range(i64(n)):
        # Type of "x" is "i64"
        ...

---

introduction.md

---

# Introduction

Mypyc compiles Python modules to C extensions. It uses standard Python [type hints](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html) to generate fast code.

The compiled language is a strict, *gradually typed* Python variant. It restricts the use of some dynamic Python features to gain performance, but it's mostly compatible with standard Python.

Mypyc uses [mypy](https://www.mypy-lang.org/) to perform type checking and type inference. Most type system features in the stdlib [typing](https://docs.python.org/3/library/typing.html) module are supported.

Compiled modules can import arbitrary Python modules and third-party libraries. You can compile anything from a single performance-critical module to your entire codebase. You can run the modules you compile also as normal, interpreted Python modules.

Existing code with type annotations is often **1.5x to 5x** faster when compiled. Code tuned for mypyc can be **5x to 10x** faster.

Mypyc currently aims to speed up non-numeric code, such as server applications. Mypyc is also used to compile itself (and mypy).

## Why mypyc?

**Easy to get started.** Compiled code has the look and feel of regular Python code. Mypyc supports familiar Python syntax and idioms.

**Expressive types.** Mypyc fully supports standard Python type hints. Mypyc has local type inference, generics, optional types, tuple types, union types, and more. Type hints act as machine-checked documentation, making code not only faster but also easier to understand and modify.

**Python ecosystem.** Mypyc runs on top of CPython, the standard Python implementation. You can use any third-party libraries, including C extensions, installed with pip. Mypyc uses only valid Python syntax, so all Python editors and IDEs work perfectly.

**Fast program startup.** Mypyc uses ahead-of-time compilation, so compilation does not slow down program startup. Slow program startup is a common issue with JIT compilers.

**Migration path for existing code.** Existing Python code often requires only minor changes to compile using mypyc.

**Waiting for compilation is optional.** Compiled code also runs as normal Python code. You can use interpreted Python during development, with familiar and fast workflows.

**Runtime type safety.** Mypyc protects you from segfaults and memory corruption. Any unexpected runtime type safety violation is a bug in mypyc. Runtime values are checked against type annotations. (Without mypyc, type annotations are ignored at runtime.)

**Find errors statically.** Mypyc uses mypy for static type checking that helps catch many bugs.

## Use cases

**Fix only performance bottlenecks.** Often most time is spent in a few Python modules or functions. Add type annotations and compile these modules for easy performance gains.

**Compile it all.** During development you can use interpreted mode, for a quick edit-run cycle. In releases all non-test code is compiled. This is how mypy achieved a 4x performance improvement over interpreted Python.

**Take advantage of existing type hints.** If you already use type annotations in your code, adopting mypyc will be easier. You've already done most of the work needed to use mypyc.

**Alternative to a lower-level language.** Instead of writing performance-critical code in C, C++, Cython or Rust, you may get good performance while staying in the comfort of Python.

**Migrate C extensions.** Maintaining C extensions is not always fun for a Python developer. With mypyc you may get performance similar to the original C, with the convenience of Python.

## Differences from Cython

Mypyc targets many similar use cases as Cython. Mypyc does many things differently, however:

  - No need to use non-standard syntax, such as `cpdef`, or extra decorators to get good performance. Clean, normal-looking type-annotated Python code can be fast without language extensions. This makes it practical to compile entire codebases without a developer productivity hit.
  - Mypyc has first-class support for features in the `typing` module, such as tuple types, union types and generics.
  - Mypyc has powerful type inference, provided by mypy. Variable type annotations are not needed for optimal performance.
  - Mypyc fully integrates with mypy for robust and seamless static type checking.
  - Mypyc performs strict enforcement of type annotations at runtime, resulting in better runtime type safety and easier debugging.

Unlike Cython, mypyc doesn't directly support interfacing with C libraries or speeding up numeric code.

## How does it work

Mypyc uses several techniques to produce fast code:

  - Mypyc uses *ahead-of-time compilation* to native code. This removes CPython interpreter overhead.
  - Mypyc enforces type annotations (and type comments) at runtime, raising `TypeError` if runtime values don't match annotations. Value types only need to be checked in the boundaries between dynamic and static typing.
  - Compiled code uses optimized, type-specific primitives.
  - Mypyc uses *early binding* to resolve called functions and name references at compile time. Mypyc avoids many dynamic namespace lookups.
  - Classes are compiled to *C extension classes*. They use [vtables](https://en.wikipedia.org/wiki/Virtual_method_table) for fast method calls and attribute access.
  - Mypyc treats compiled functions, classes, and attributes declared `Final` as immutable.
  - Mypyc has memory-efficient, unboxed representations for integers and booleans.

## Development status

Mypyc is currently alpha software. It's only recommended for production use cases with careful testing, and if you are willing to contribute fixes or to work around issues you will encounter.

---

list_operations.md

---

# Native list operations

These `list` operations have fast, optimized implementations. Other list operations use generic implementations that are often slower.

## Construction

Construct list with specific items:

  - `[item0, ..., itemN]`

Construct empty list:

  - `[]`
  - `list()`

Construct list from iterable:

  - `list(x: Iterable)`

List comprehensions:

  - `[... for ... in ...]`
  - `[... for ... in ... if ...]`

## Operators

  - `lst[n]` (get item by integer index)
  - `lst[n:m]`, `lst[n:]`, `lst[:m]`, `lst[:]` (slicing)
  - `lst * n`, `n * lst`
  - `obj in lst`

## Statements

Set item by integer index:

  - `lst[n] = x`

For loop over a list:

  - `for item in lst:`

## Methods

  - `lst.append(obj)`
  - `lst.extend(x: Iterable)`
  - `lst.insert(index, obj)`
  - `lst.pop(index=-1)`
  - `lst.remove(obj)`
  - `lst.count(obj)`
  - `lst.index(obj)`
  - `lst.reverse()`
  - `lst.sort()`

## Functions

  - `len(lst: list)`

---

native_classes.md

---

# Native classes

Classes in compiled modules are *native classes* by default (some exceptions are discussed below). Native classes are compiled to C extension classes, which have some important differences from normal Python classes. Native classes are similar in many ways to built-in types, such as `int`, `str`, and `list`.

## Immutable namespaces

The type object namespace of native classes is mostly immutable (but class variables can be assigned to):

    class Cls:
        def method1(self) -> None:
            print("method1")
    
        def method2(self) -> None:
            print("method2")
    
    Cls.method1 = Cls.method2  # Error
    Cls.new_method = Cls.method2  # Error

Only attributes defined within a class definition (or in a base class) can be assigned to (similar to using `__slots__`):

    class Cls:
        x: int
    
        def __init__(self, y: int) -> None:
            self.x = 0
            self.y = y
    
        def method(self) -> None:
            self.z = "x"
    
    o = Cls(0)
    print(o.x, o.y)  # OK
    o.z = "y"  # OK
    o.extra = 3  # Error: no attribute "extra"

## Inheritance

Only single inheritance is supported (except for \[traits \<trait-types\>\](\#traits \<trait-types\>)). Most non-native classes can't be used as base classes.

These non-native classes can be used as base classes of native classes:

  - `object`
  - `dict` (and `Dict[k, v]`)
  - `BaseException`
  - `Exception`
  - `ValueError`
  - `IndexError`
  - `LookupError`
  - `UserWarning`
  - `typing.NamedTuple`
  - `enum.Enum`

By default, a non-native class can't inherit a native class, and you can't inherit from a native class outside the compilation unit that defines the class. You can enable these through `mypy_extensions.mypyc_attr`:

    from mypy_extensions import mypyc_attr
    
    @mypyc_attr(allow_interpreted_subclasses=True)
    class Cls:
        ...

Allowing interpreted subclasses has only minor impact on performance of instances of the native class. Accessing methods and attributes of a *non-native* subclass (or a subclass defined in another compilation unit) will be slower, since it needs to use the normal Python attribute access mechanism.

You need to install `mypy-extensions` to use `@mypyc_attr`:

`` `text     pip install --upgrade mypy-extensions  Class variables ``\` ---------------

Class variables must be explicitly declared using `attr: ClassVar` or `attr: ClassVar[<type>]`. You can't assign to a class variable through an instance. Example:

    from typing import ClassVar
    
    class Cls:
        cv: ClassVar = 0
    
    Cls.cv = 2  # OK
    o = Cls()
    print(o.cv)  # OK (2)
    o.cv = 3  # Error!

\> **Tip** \> Constant class variables can be declared using `typing.Final` or `typing.Final[<type>]`.

## Generic native classes

Native classes can be generic. Type variables are *erased* at runtime, and instances don't keep track of type variable values.

Compiled code thus can't check the values of type variables when performing runtime type checks. These checks are delayed to when reading a value with a type variable type:

    from typing import TypeVar, Generic, cast
    
    T = TypeVar('T')
    
    class Box(Generic[T]):
        def __init__(self, item: T) -> None:
            self.item = item
    
    x = Box(1)  # Box[int]
    y = cast(Box[str], x)  # OK (type variable value not checked)
    y.item  # Runtime error: item is "int", but "str" expected

## Metaclasses

Most metaclasses aren't supported with native classes, since their behavior is too dynamic. You can use these metaclasses, however:

  - `abc.ABCMeta`
  - `typing.GenericMeta` (used by `typing.Generic`)

\> **Note** \> If a class definition uses an unsupported metaclass, *mypyc compiles the class into a regular Python class*.

## Class decorators

Similar to metaclasses, most class decorators aren't supported with native classes, as they are usually too dynamic. These class decorators can be used with native classes, however:

  - `mypy_extensions.trait` (for defining \[trait types \<trait-types\>\](\#trait-types-\<trait-types\>))
  - `mypy_extensions.mypyc_attr` (see \[above \<inheritance\>\](\#above-\<inheritance\>))
  - `dataclasses.dataclass`
  - `@attr.s(auto_attribs=True)`

Dataclasses and attrs classes have partial native support, and they aren't as efficient as pure native classes.

\> **Note** \> If a class definition uses an unsupported class decorator, *mypyc compiles the class into a regular Python class*.

## Deleting attributes

By default, attributes defined in native classes can't be deleted. You can explicitly allow certain attributes to be deleted by using `__deletable__`:

    class Cls:
        x: int = 0
        y: int = 0
        other: int = 0
    
        __deletable__ = ['x', 'y']  # 'x' and 'y' can be deleted
    
    o = Cls()
    del o.x  # OK
    del o.y  # OK
    del o.other  # Error

You must initialize the `__deletable__` attribute in the class body, using a list or a tuple expression with only string literal items that refer to attributes. These are not valid:

    a = ['x', 'y']
    
    class Cls:
        x: int
        y: int
    
        __deletable__ = a  # Error: cannot use variable 'a'
    
    __deletable__ = ('a',)  # Error: not in a class body

## Other properties

Instances of native classes don't usually have a `__dict__` attribute.

---

native_operations.md

---

# Miscellaneous native operations

This is a list of various non-type-specific operations that have custom native implementations. If an operation has no native implementation, mypyc will use fallback generic implementations that are often not as fast.

\> **Note** \> Operations specific to various primitive types are described in the following sections.

## Operators

  - `x is y` (this is very fast for all types)

## Functions

  - `isinstance(obj, type: type)`
  - `isinstance(obj, type: tuple)`
  - `cast(<type>, obj)`
  - `type(obj)`
  - `len(obj)`
  - `abs(obj)`
  - `id(obj)`
  - `iter(obj)`
  - `next(iter: Iterator)`
  - `hash(obj)`
  - `getattr(obj, attr)`
  - `getattr(obj, attr, default)`
  - `setattr(obj, attr, value)`
  - `hasattr(obj, attr)`
  - `delattr(obj, name)`
  - `slice(start, stop, step)`
  - `globals()`

## Method decorators

  - `@property`
  - `@staticmethod`
  - `@classmethod`
  - `@abc.abstractmethod`

## Statements

These variants of statements have custom implementations:

  - `for ... in seq:` (for loop over a sequence)
  - `for ... in enumerate(...):`
  - `for ... in zip(...):`

---

performance_tips_and_tricks.md

---

# Performance tips and tricks

Performance optimization is part art, part science. Just using mypyc in a simple manner will likely make your code faster, but squeezing the most performance out of your code requires the use of some techniques we'll summarize below.

## Profiling

If you are speeding up existing code, understanding where time is spent is important. Mypyc speeds up code that you compile. If most of the time is spent elsewhere, you may come back disappointed. For example, if you spend 40% of time outside compiled code, even if compiled code would go 100x faster, overall performance will only be 2.5x faster.

A simple (but often effective) approach is to record the time in various points of program execution using `time.time()`, and to print out elapsed time (or to write it to a log file).

The stdlib modules `profile` and `cProfile` can provide much more detailed data. (But these only work well with non-compiled code.)

## Avoiding slow libraries

If profiling indicates that a lot of time is spent in the stdlib or third-party libraries, you still have several options.

First, if most time is spent in a few library features, you can perhaps easily reimplement them in type-annotated Python, or extract the relevant code and annotate it. Now it may be easy to compile this code to speed it up.

Second, you may be able to avoid the library altogether, or use an alternative, more efficient library to achieve the same purpose.

## Type annotations

As discussed earlier, type annotations are key to major performance gains. You should at least consider adding annotations to any performance-critical functions and classes. It may also be helpful to annotate code called by this code, even if it's not compiled, since this may help mypy infer better types in the compile code. If you use libraries, ensure they have stub files with decent type annotation coverage. Writing a stub file is often easy, and you only need to annotate features you use a lot.

If annotating external code or writing stubs feel too burdensome, a simple workaround is to annotate variables explicitly. For example, here we call `acme.get_items()`, but it has no type annotation. We can use an explicit type annotation for the variable to which we assign the result:

    from typing import List, Tuple
    import acme
    
    def work() -> None:
        # Annotate "items" to help mypyc
        items: List[Tuple[int, str]] = acme.get_items()
        for item in items:
            ...  # Do some work here

Without the annotation on `items`, the type would be `Any` (since `acme` has no type annotation), resulting in slower, generic operations being used later in the function.

## Avoiding slow Python features

Mypyc can optimize some features more effectively than others. Here the difference is sometimes big -- some things only get marginally faster at best, while others can get 10x faster, or more. Avoiding these slow features in performance-critical parts of your code can help a lot.

These are some of the most important things to avoid:

  - Using class decorators or metaclasses in compiled code (that aren't properly supported by mypyc)
  - Heavy reliance on interpreted Python libraries (C extensions are usually fine)

These things also tend to be relatively slow:

  - Using Python classes and instances of Python classes (native classes are much faster)
  - Calling decorated functions (`@property`, `@staticmethod`, and `@classmethod` are special cased and thus fast)
  - Calling nested functions
  - Calling functions or methods defined in other compilation units
  - Using `*args` or `**kwargs`
  - Using generator functions
  - Using callable values (i.e. not leveraging early binding to call functions or methods)

Nested functions can often be replaced with module-level functions or methods of native classes.

Callable values and nested functions can sometimes be replaced with an instance of a native class with a single method only, such as `call(...)`. You can derive the class from an ABC, if there are multiple possible functions.

\> **Note** \> Some slow features will likely get efficient implementations in the future. You should check this section every once in a while to see if some additional operations are fast.

## Using fast native features

Some native operations are particularly quick relative to the corresponding interpreted operations. Using them as much as possible may allow you to see 10x or more in performance gains.

Some things are not much (or any) faster in compiled code, such as set math operations. In contrast, calling a method of a native class is much faster in compiled code.

If you are used to optimizing for CPython, you might have replaced some class instances with dictionaries, as they can be faster. However, in compiled code, this "optimization" would likely slow down your code.

Similarly, caching a frequently called method in a local variable can help in CPython, but it can slow things down in compiled code, since the code won't use \[early binding \<early-binding\>\](\#early-binding-\<early-binding\>):

    def squares(n: int) -> List[int]:
        a = []
        append = a.append  # Not a good idea in compiled code!
        for i in range(n):
            append(i * i)
        return a

Here are examples of features that are fast, in no particular order (this list is *not* exhaustive):

  - Calling compiled functions directly defined in the same compilation unit (with positional and/or keyword arguments)
  - Calling methods of native classes defined in the same compilation unit (with positional and/or keyword arguments)
  - Many integer operations
  - Many `float` operations
  - Booleans
  - \[Native list operations \<list-ops\>\](\#native-list-operations-\<list-ops\>), such as indexing, `append`, and list comprehensions
  - While loops
  - For loops over ranges and lists, and with `enumerate` or `zip`
  - Reading dictionary items
  - `isinstance()` checks against native classes and instances of primitive types (and unions of them)
  - Accessing local variables
  - Accessing attributes of native classes
  - Accessing final module-level attributes
  - Comparing strings for equality

These features are also fast, but somewhat less so (relative to other related operations):

  - Constructing instances of native classes
  - Constructing dictionaries
  - Setting dictionary items
  - Native \[dict \<dict-ops\>\](\#dict-\<dict-ops\>) and \[set \<set-ops\>\](\#set-\<set-ops\>) operations
  - Accessing module-level variables

Generally anything documented as a native operation is fast, even if it's not explicitly mentioned here

## Adjusting garbage collection

Compilation does not speed up cyclic garbage collection. If everything else gets much faster, it's possible that garbage collection will take a big fraction of time. You can use `gc.set_threshold()` to adjust the garbage collector to run less often:

    import gc
    
    # Spend less time in gc; do this before significant computation
    gc.set_threshold(150000)
    
    ...  # Actual work happens here

## Fast interpreter shutdown

If you allocate many objects, it's possible that your program spends a lot of time cleaning up when the Python runtime shuts down. Mypyc won't speed up the shutdown of a Python process much.

You can call `os._exit(code)` to immediately terminate the Python process, skipping normal cleanup. This can give a nice boost to a batch process or a command-line tool.

\> **Note** \> This can be dangerous and can lose data. You need to ensure that all streams are flushed and everything is otherwise cleaned up properly.

## Work smarter

Usually there are many things you can do to improve performance, even if most tweaks will yield only minor gains. The key to being effective is to focus on things that give a large gain with a small effort.

For example, low-level optimizations, such as avoiding a nested function, can be pointless, if you could instead avoid a metaclass --to allow a key class to be compiled as a native class. The latter optimization could speed up numerous method calls and attribute accesses, just like that.

---

set_operations.md

---

# Native set operations

These `set` operations have fast, optimized implementations. Other set operations use generic implementations that are often slower.

## Construction

Construct set with specific items:

  - `{item0, ..., itemN}`

Construct empty set:

  - `set()`

Construct set from iterable:

  - `set(x: Iterable)`

Set comprehensions:

  - `{... for ... in ...}`
  - `{... for ... in ... if ...}`

## Operators

  - `item in s`

## Methods

  - `s.add(item)`
  - `s.remove(item)`
  - `s.discard(item)`
  - `s.update(x: Iterable)`
  - `s.clear()`
  - `s.pop()`

## Functions

  - `len(s: set)`

---

str_operations.md

---

# Native string operations

These `str` operations have fast, optimized implementations. Other string operations use generic implementations that are often slower.

## Construction

  - String literal
  - `str(x: int)`
  - `str(x: object)`

## Operators

  - Concatenation (`s1 + s2`)
  - Indexing (`s[n]`)
  - Slicing (`s[n:m]`, `s[n:]`, `s[:m]`)
  - Comparisons (`==`, `!=`)
  - Augmented assignment (`s1 += s2`)

## Methods

  - `s1.endswith(s2: str)`
  - `s.join(x: Iterable)`
  - `s.replace(old: str, new: str)`
  - `s.replace(old: str, new: str, count: int)`
  - `s.split()`
  - `s.split(sep: str)`
  - `s.split(sep: str, maxsplit: int)`
  - `s1.startswith(s2: str)`

---

tuple_operations.md

---

# Native tuple operations

These `tuple` operations have fast, optimized implementations. Other tuple operations use generic implementations that are often slower.

Unless mentioned otherwise, these operations apply to both fixed-length tuples and variable-length tuples.

## Construction

  - `item0, ..., itemN` (construct a tuple)
  - `tuple(lst: list)` (construct a variable-length tuple)
  - `tuple(lst: Iterable)` (construct a variable-length tuple)

## Operators

  - `tup[n]` (integer index)
  - `tup[n:m]`, `tup[n:]`, `tup[:m]` (slicing)

## Statements

  - `item0, ..., itemN = tup` (for fixed-length tuples)

## Functions

  - `len(tup: tuple)`

---

using_type_annotations.md

---

# Using type annotations

You will get the most out of mypyc if you compile code with precise type annotations. Not all type annotations will help performance equally, however. Using types such as \[primitive types \<primitive-types\>\](\#primitive-types \<primitive-types\>), \[native classes \<native-class-intro\>\](\#native-classes-\<native-class-intro\>), \[union types \<union-types\>\](\#union-types-\<union-types\>), \[trait types \<trait-types\>\](\#trait-types-\<trait-types\>), and \[tuple types \<tuple-types\>\](\#tuple-types-\<tuple-types\>) as much as possible is a key to major performance gains over CPython.

In contrast, some other types, including `Any`, are treated as \[erased types \<erased-types\>\](\#erased-types-\<erased-types\>). Operations on erased types use generic operations that work with arbitrary objects, similar to how the CPython interpreter works. If you only use erased types, the only notable benefits over CPython will be the removal of interpreter overhead (from compilation) and a bit of \[early binding \<early-binding\>\](\#early-binding \<early-binding\>), which will usually only give minor performance gains.

## Primitive types

The following built-in types are treated as *primitive types* by mypyc, and many operations on these types have efficient implementations:

  - `int` (\[native operations \<int-ops\>\](\#native-operations-\<int-ops\>))
  - `i64` (\[documentation \<native-ints\>\](\#documentation-\<native-ints\>), \[native operations \<int-ops\>\](\#native-operations-\<int-ops\>))
  - `i32` (\[documentation \<native-ints\>\](\#documentation-\<native-ints\>), \[native operations \<int-ops\>\](\#native-operations-\<int-ops\>))
  - `i16` (\[documentation \<native-ints\>\](\#documentation-\<native-ints\>), \[native operations \<int-ops\>\](\#native-operations-\<int-ops\>))
  - `u8` (\[documentation \<native-ints\>\](\#documentation-\<native-ints\>), \[native operations \<int-ops\>\](\#native-operations-\<int-ops\>))
  - `float` (\[native operations \<float-ops\>\](\#native-operations-\<float-ops\>))
  - `bool` (\[native operations \<bool-ops\>\](\#native-operations-\<bool-ops\>))
  - `str` (\[native operations \<str-ops\>\](\#native-operations-\<str-ops\>))
  - `List[T]` (\[native operations \<list-ops\>\](\#native-operations-\<list-ops\>))
  - `Dict[K, V]` (\[native operations \<dict-ops\>\](\#native-operations-\<dict-ops\>))
  - `Set[T]` (\[native operations \<set-ops\>\](\#native-operations-\<set-ops\>))
  - `Tuple[T, ...]` (variable-length tuple; \[native operations \<tuple-ops\>\](\#native-operations-\<tuple-ops\>))
  - `None`

The link after each type lists all supported native, optimized operations for the type. You can use all operations supported by Python, but *native operations* will have custom, optimized implementations.

## Primitive containers

Primitive container objects such as `list` and `dict` don't maintain knowledge of the item types at runtime -- the item type is *erased*.

This means that item types are checked when items are accessed, not when a container is passed as an argument or assigned to another variable. For example, here we have a runtime type error on the final line of `example` (the `Any` type means an arbitrary, unchecked value):

    from typing import List, Any
    
    def example(a: List[Any]) -> None:
        b: List[int] = a  # No error -- items are not checked
        print(b[0])  # Error here -- got str, but expected int
    
    example(["x"])

## Native classes

Classes that get compiled to C extensions are called native classes. Most common operations on instances of these classes are optimized, including construction, attribute access and method calls.

Native class definitions look exactly like normal Python class definitions. A class is usually native if it's in a compiled module (though there are some exceptions).

Consider this example:

    class Point:
        def __init__(self, x: int, y: int) -> None:
            self.x = x
            self.y = y
    
    def shift(p: Point) -> Point:
        return Point(p.x + 1, p.y + 1)

All operations in the above example use native operations, if the file is compiled.

Native classes have some notable different from Python classes:

  - Only attributes and methods defined in the class body or methods are supported. If you try to assign to an undefined attribute outside the class definition, `AttributeError` will be raised. This enables an efficient memory layout and fast method calls for native classes.
  - Native classes usually don't define the `__dict__` attribute (they don't have an attribute dictionary). This follows from only having a specific set of attributes.
  - Native classes can't have an arbitrary metaclass or use most class decorators.

Native classes only support single inheritance. A limited form of multiple inheritance is supported through *trait types*. You generally must inherit from another native class (or `object`). By default, you can't inherit a Python class from a native class (but there's an \[override \<inheritance\>\](\#override-\<inheritance\>) to allow that).

See \[native-classes\](\#native-classes) for more details.

## Tuple types

Fixed-length [tuple types](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#tuple-types) such as `Tuple[int, str]` are represented as \[value types \<value-and-heap-types\>\](\#value-types-\<value-and-heap-types\>) when stored in variables, passed as arguments, or returned from functions. Value types are allocated in the low-level machine stack or in CPU registers, as opposed to *heap types*, which are allocated dynamically from the heap.

Like all value types, tuples will be *boxed*, i.e. converted to corresponding heap types, when stored in Python containers, or passed to non-native code. A boxed tuple value will be a regular Python tuple object.

## Union types

[Union types](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#union-types) and [optional types](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#optional-types-and-the-none-type) that contain primitive types, native class types and trait types are also efficient. If a union type has \[erased \<erased-types\>\](\#erased-\<erased-types\>) items, accessing items with non-erased types is often still quite efficient.

A value with a union types is always \[boxed \<value-and-heap-types\>\](\#boxed-\<value-and-heap-types\>), even if it contains a value that also has an unboxed representation, such as an integer or a boolean.

For example, using `Optional[int]` is quite efficient, but the value will always be boxed. A plain `int` value will usually be faster, since it has an unboxed representation.

## Trait types

Trait types enable a form of multiple inheritance for native classes. A native class can inherit any number of traits. Trait types are defined as classes using the `mypy_extensions.trait` decorator:

    from mypy_extensions import trait
    
    @trait
    class MyTrait:
        def method(self) -> None:
            ...

Traits can define methods, properties and attributes. They often define abstract methods. Traits can be generic.

If a class subclasses both a non-trait class and traits, the traits must be placed at the end of the base class list:

    class Base: ...
    
    class Derived(Base, MyTrait, FooTrait):  # OK
        ...
    
    class Derived2(MyTrait, FooTrait, Base):
        # Error: traits should come last
        ...

Traits have some special properties:

  - You shouldn't create instances of traits (though mypyc does not prevent it yet).
  - Traits can subclass other traits or native classes, but the MRO must be linear (just like with native classes).
  - Accessing methods or attributes through a trait type is somewhat less efficient than through a native class type, but this is much faster than through Python class types or other \[erased types \<erased-types\>\](\#erased-types-\<erased-types\>).

You need to install `mypy-extensions` to use `@trait`:

`` `text     pip install --upgrade mypy-extensions  .. _erased-types:  Erased types ``\` ------------

Mypyc supports many other kinds of types as well, beyond those described above. However, these types don't have customized operations, and they are implemented using *type erasure*. Type erasure means that all other types are equivalent to untyped values at runtime, i.e. they are the equivalent of the type `Any`. Erased types include these:

  - Python classes (including ABCs)
  - Non-mypyc extension types and primitive types (including built-in types that are not primitives)
  - [Callable types](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#callable-types-and-lambdas)
  - [Type variable types](https://mypy.readthedocs.io/en/stable/generics.html)
  - Type [Any](https://mypy.readthedocs.io/en/stable/dynamic_typing.html)
  - Protocol types

Using erased types can still improve performance, since they can enable better types to be inferred for expressions that use these types. For example, a value with type `Callable[[], int]` will not allow native calls. However, the return type is a primitive type, and we can use fast operations on the return value:

    from typing import Callable
    
    def call_and_inc(f: Callable[[], int]) -> int:
        # Slow call, since f has an erased type
        n = f()
        # Fast increment; inferred type of n is int (primitive type)
        n += 1
        return n

If the type of the argument `f` was `Any`, the type of `n` would also be `Any`, resulting in a generic, slower increment operation being used.

## Strict runtime type checking

Compiled code ensures that any variable or expression with a non-erased type only has compatible values at runtime. This is in contrast with using *optional static typing*, such as by using mypy, when type annotations are not enforced at runtime. Mypyc ensures type safety both statically and at runtime.

`Any` types and erased types in general can compromise type safety, and this is by design. Inserting strict runtime type checks for all possible values would be too expensive and against the goal of high performance.

## Value and heap types

In CPython, memory for all objects is dynamically allocated on the heap. All Python types are thus *heap types*. In compiled code, some types are *value types* -- no object is (necessarily) allocated on the heap. `bool`, `float`, `None`, \[native integer types \<native-ints\>\](\#native-integer-types-\<native-ints\>) and fixed-length tuples are value types.

`int` is a hybrid. For typical integer values, it is a value type. Large enough integer values, those that require more than 63 bits (or 31 bits on 32-bit platforms) to represent, use a heap-based representation (same as CPython).

Value types have a few differences from heap types:

  - When an instance of a value type is used in a context that expects a heap value, for example as a list item, it will transparently switch to a heap-based representation (boxing) as needed.
  - Similarly, mypyc transparently changes from a heap-based representation to a value representation (unboxing).
  - Object identity of integers, floating point values and tuples is not preserved. You should use `==` instead of `is` if you are comparing two integers, floats or fixed-length tuples.
  - When an instance of a subclass of a value type is converted to the base type, it is implicitly converted to an instance of the target type. For example, a `bool` value assigned to a variable with an `int` type will be converted to the corresponding integer.

The latter conversion is the only implicit type conversion that happens in mypyc programs.

Example:

    def example() -> None:
        # A small integer uses the value (unboxed) representation
        x = 5
        # A large integer uses the heap (boxed) representation
        x = 2**500
        # Lists always contain boxed integers
        a = [55]
        # When reading from a list, the object is automatically unboxed
        x = a[0]
        # True is converted to 1 on assignment
        x = True

Since integers and floating point values have a different runtime representations and neither can represent all the values of the other type, type narrowing of floating point values through assignment is disallowed in compiled code. For consistency, mypyc rejects assigning an integer value to a float variable even in variable initialization. An explicit conversion is required.

Examples:

    def narrowing(n: int) -> None:
        # Error: Incompatible value representations in assignment
        # (expression has type "int", variable has type "float")
        x: float = 0
    
        y: float = 0.0  # Ok
    
        if f():
            y = n  # Error
        if f():
            y = float(n)  # Ok

## Native integer types

You can use the native integer types `i64` (64-bit signed integer), `i32` (32-bit signed integer), `i16` (16-bit signed integer), and `u8` (8-bit unsigned integer) if you know that integer values will always fit within fixed bounds. These types are faster than the arbitrary-precision `int` type, since they don't require overflow checks on operations. They may also use less memory than `int` values. The types are imported from the `mypy_extensions` module (installed via `pip install mypy_extensions`).

Example:

    from mypy_extensions import i64
    
    def sum_list(l: list[i64]) -> i64:
        s: i64 = 0
        for n in l:
            s += n
        return s
    
    # Implicit conversions from int to i64
    print(sum_list([1, 3, 5]))

\> **Note** \> Since there are no overflow checks when performing native integer arithmetic, the above function could result in an overflow or other undefined behavior if the sum might not fit within 64 bits.

> The behavior when running as interpreted Python program will be different if there are overflows. Declaring native integer types have no effect unless code is compiled. Native integer types are effectively equivalent to `int` when interpreted.

Native integer types have these additional properties:

  - Values can be implicitly converted between `int` and a native integer type (both ways).
  - Conversions between different native integer types must be explicit. A conversion to a narrower native integer type truncates the value without a runtime overflow check.
  - If a binary operation (such as `+`) or an augmented assignment (such as `+=`) mixes native integer and `int` values, the `int` operand is implicitly coerced to the native integer type (native integer types are "sticky").
  - You can't mix different native integer types in binary operations. Instead, convert between types explicitly.

For more information about native integer types, refer to \[native integer operations \<int-ops\>\](\#native-integer-operations-\<int-ops\>).

---

CHANGELOG.md

---

# Mypy Release Notes

## Next release

### Change to enum membership semantics

As per the updated [typing specification for enums](https://typing.readthedocs.io/en/latest/spec/enums.html#defining-members),
enum members must be left unannotated.

```python
class Pet(Enum):
    CAT = 1  # Member attribute
    DOG = 2  # Member attribute
    WOLF: int = 3  # New error: Enum members must be left unannotated

    species: str  # Considered a non-member attribute
```

In particular, the specification change can result in issues in type stubs (`.pyi` files), since
historically it was common to leave the value absent:

```python
# In a type stub (.pyi file)

class Pet(Enum):
    # Change in semantics: previously considered members, now non-member attributes
    CAT: int
    DOG: int

    # Mypy will now issue a warning if it detects this situation in type stubs:
    # > Detected enum "Pet" in a type stub with zero members.
    # > There is a chance this is due to a recent change in the semantics of enum membership.
    # > If so, use `member = value` to mark an enum member, instead of `member: type`

class Pet(Enum):
    # As per the specification, you should now do one of the following:
    DOG = 1  # Member attribute with value 1 and known type
    WOLF = cast(int, ...)  # Member attribute with unknown value but known type
    LION = ...  # Member attribute with unknown value and unknown type
```

Contributed by Terence Honles in PR [17207](https://github.com/python/mypy/pull/17207) and
Shantanu Jain in PR [18068](https://github.com/python/mypy/pull/18068).

## Mypy 1.13

We’ve just uploaded mypy 1.13 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)).
Mypy is a static type checker for Python. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

Note that unlike typical releases, Mypy 1.13 does not have any changes to type checking semantics
from 1.12.1.

### Improved performance

Mypy 1.13 contains several performance improvements. Users can expect mypy to be 5-20% faster.
In environments with long search paths (such as environments using many editable installs), mypy
can be significantly faster, e.g. 2.2x faster in the use case targeted by these improvements.

Mypy 1.13 allows use of the `orjson` library for handling the cache instead of the stdlib `json`,
for improved performance. You can ensure the presence of `orjson` using the `faster-cache` extra:

    python3 -m pip install -U mypy[faster-cache]

Mypy may depend on `orjson` by default in the future.

These improvements were contributed by Shantanu.

List of changes:
* Significantly speed up file handling error paths (Shantanu, PR [17920](https://github.com/python/mypy/pull/17920))
* Use fast path in modulefinder more often (Shantanu, PR [17950](https://github.com/python/mypy/pull/17950))
* Let mypyc optimise os.path.join (Shantanu, PR [17949](https://github.com/python/mypy/pull/17949))
* Make is_sub_path faster (Shantanu, PR [17962](https://github.com/python/mypy/pull/17962))
* Speed up stubs suggestions (Shantanu, PR [17965](https://github.com/python/mypy/pull/17965))
* Use sha1 for hashing (Shantanu, PR [17953](https://github.com/python/mypy/pull/17953))
* Use orjson instead of json, when available (Shantanu, PR [17955](https://github.com/python/mypy/pull/17955))
* Add faster-cache extra, test in CI (Shantanu, PR [17978](https://github.com/python/mypy/pull/17978))

### Acknowledgements
Thanks to all mypy contributors who contributed to this release:

- Shantanu Jain
- Jukka Lehtosalo

## Mypy 1.12

We’ve just uploaded mypy 1.12 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type
checker for Python. This release includes new features, performance improvements and bug fixes.
You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Support Python 3.12 Syntax for Generics (PEP 695)

Support for the new type parameter syntax introduced in Python 3.12 is now enabled by default,
documented, and no longer experimental. It was available through a feature flag in
mypy 1.11 as an experimental feature.

This example demonstrates the new syntax:

```python
# Generic function
def f[T](x: T) -> T: ...

reveal_type(f(1))  # Revealed type is 'int'

# Generic class
class C[T]:
    def __init__(self, x: T) -> None:
       self.x = x

c = C('a')
reveal_type(c.x)  # Revealed type is 'str'

# Type alias
type A[T] = C[list[T]]
```

For more information, refer to the [documentation](https://mypy.readthedocs.io/en/latest/generics.html).

These improvements are included:

 * Document Python 3.12 type parameter syntax (Jukka Lehtosalo, PR [17816](https://github.com/python/mypy/pull/17816))
 * Further documentation updates (Jukka Lehtosalo, PR [17826](https://github.com/python/mypy/pull/17826))
 * Allow Self return types with contravariance (Jukka Lehtosalo, PR [17786](https://github.com/python/mypy/pull/17786))
 * Enable new type parameter syntax by default (Jukka Lehtosalo, PR [17798](https://github.com/python/mypy/pull/17798))
 * Generate error if new-style type alias used as base class (Jukka Lehtosalo, PR [17789](https://github.com/python/mypy/pull/17789))
 * Inherit variance if base class has explicit variance (Jukka Lehtosalo, PR [17787](https://github.com/python/mypy/pull/17787))
 * Fix crash on invalid type var reference (Jukka Lehtosalo, PR [17788](https://github.com/python/mypy/pull/17788))
 * Fix covariance of frozen dataclasses (Jukka Lehtosalo, PR [17783](https://github.com/python/mypy/pull/17783))
 * Allow covariance with attribute that has "`_`" name prefix (Jukka Lehtosalo, PR [17782](https://github.com/python/mypy/pull/17782))
 * Support `Annotated[...]` in new-style type aliases (Jukka Lehtosalo, PR [17777](https://github.com/python/mypy/pull/17777))
 * Fix nested generic classes (Jukka Lehtosalo, PR [17776](https://github.com/python/mypy/pull/17776))
 * Add detection and error reporting for the use of incorrect expressions within the scope of a type parameter and a type alias (Kirill Podoprigora, PR [17560](https://github.com/python/mypy/pull/17560))

### Basic Support for Python 3.13

This release adds partial support for Python 3.13 features and compiled binaries for
Python 3.13. Mypyc now also supports Python 3.13.

In particular, these features are supported:
 * Various new stdlib features and changes (through typeshed stub improvements)
 * `typing.ReadOnly` (see below for more)
 * `typing.TypeIs` (added in mypy 1.10, [PEP 742](https://peps.python.org/pep-0742/))
 * Type parameter defaults when using the legacy syntax ([PEP 696](https://peps.python.org/pep-0696/))

These features are not supported yet:
 * `warnings.deprecated` ([PEP 702](https://peps.python.org/pep-0702/))
 * Type parameter defaults when using Python 3.12 type parameter syntax

### Mypyc Support for Python 3.13

Mypyc now supports Python 3.13. This was contributed by Marc Mueller, with additional
fixes by Jukka Lehtosalo. Free threaded Python 3.13 builds are not supported yet.

List of changes:

 * Add additional includes for Python 3.13 (Marc Mueller, PR [17506](https://github.com/python/mypy/pull/17506))
 * Add another include for Python 3.13 (Marc Mueller, PR [17509](https://github.com/python/mypy/pull/17509))
 * Fix ManagedDict functions for Python 3.13 (Marc Mueller, PR [17507](https://github.com/python/mypy/pull/17507))
 * Update mypyc test output for Python 3.13 (Marc Mueller, PR [17508](https://github.com/python/mypy/pull/17508))
 * Fix `PyUnicode` functions for Python 3.13 (Marc Mueller, PR [17504](https://github.com/python/mypy/pull/17504))
 * Fix `_PyObject_LookupAttrId` for Python 3.13 (Marc Mueller, PR [17505](https://github.com/python/mypy/pull/17505))
 * Fix `_PyList_Extend` for Python 3.13 (Marc Mueller, PR [17503](https://github.com/python/mypy/pull/17503))
 * Fix `gen_is_coroutine` for Python 3.13 (Marc Mueller, PR [17501](https://github.com/python/mypy/pull/17501))
 * Fix `_PyObject_FastCall` for Python 3.13 (Marc Mueller, PR [17502](https://github.com/python/mypy/pull/17502))
 * Avoid uses of `_PyObject_CallMethodOneArg` on 3.13 (Jukka Lehtosalo, PR [17526](https://github.com/python/mypy/pull/17526))
 * Don't rely on `_PyType_CalculateMetaclass` on 3.13 (Jukka Lehtosalo, PR [17525](https://github.com/python/mypy/pull/17525))
 * Don't use `_PyUnicode_FastCopyCharacters` on 3.13 (Jukka Lehtosalo, PR [17524](https://github.com/python/mypy/pull/17524))
 * Don't use `_PyUnicode_EQ` on 3.13, as it's no longer exported (Jukka Lehtosalo, PR [17523](https://github.com/python/mypy/pull/17523))

### Inferring Unions for Conditional Expressions

Mypy now always tries to infer a union type for a conditional expression if left and right
operand types are different. This results in more precise inferred types and lets mypy detect
more issues. Example:

```python
s = "foo" if cond() else 1
# Type of "s" is now "str | int" (it used to be "object")
```

Notably, if one of the operands has type `Any`, the type of a conditional expression is
now `<type> | Any`. Previously the inferred type was just `Any`. The new type essentially
indicates that the value can be of type `<type>`, and potentially of some (unknown) type.
Most operations performed on the result must also be valid for `<type>`.
Example where this is relevant:

```python
from typing import Any

def func(a: Any, b: bool) -> None:
    x = a if b else None
    # Type of x is "Any | None"
    print(x.y)  # Error: None has no attribute "y"
```

This feature was contributed by Ivan Levkivskyi (PR [17427](https://github.com/python/mypy/pull/17427)).

### ReadOnly Support for TypedDict (PEP 705)

You can now use `typing.ReadOnly` to specity TypedDict items as
read-only ([PEP 705](https://peps.python.org/pep-0705/)):

```python
from typing import TypedDict

# Or "from typing ..." on Python 3.13
from typing_extensions import ReadOnly

class TD(TypedDict):
    a: int
    b: ReadOnly[int]

d: TD = {"a": 1, "b": 2}
d["a"] = 3  # OK
d["b"] = 5  # Error: "b" is ReadOnly
```

This feature was contributed by Nikita Sobolev (PR [17644](https://github.com/python/mypy/pull/17644)).

### Python 3.8 End of Life Approaching

We are planning to drop support for Python 3.8 in the next mypy feature release or the
one after that. Python 3.8 reaches end of life in October 2024.

### Planned Changes to Defaults

We are planning to enable `--local-partial-types` by default in mypy 2.0. This will
often require at least minor code changes. This option is implicitly enabled by mypy
daemon, so this makes the behavior of daemon and non-daemon modes consistent.

We recommend that mypy users start using local partial types soon (or to explicitly disable
them) to prepare for the change.

This can also be configured in a mypy configuration file:

```
local_partial_types = True
```

For more information, refer to the
[documentation](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-local-partial-types).

### Documentation Updates

Mypy documentation now uses modern syntax variants and imports in many examples. Some
examples no longer work on Python 3.8, which is the earliest Python version that mypy supports.

Notably, `Iterable` and other protocols/ABCs are imported from `collections.abc` instead of
`typing`:
```python
from collections.abc import Iterable, Callable
```

Examples also avoid the upper-case aliases to built-in types: `list[str]` is used instead
of `List[str]`. The `X | Y` union type syntax introduced in Python 3.10 is also now prevalent.

List of documentation updates:

 * Document `--output=json` CLI option (Edgar Ramírez Mondragón, PR [17611](https://github.com/python/mypy/pull/17611))
 * Update various references to deprecated type aliases in docs (Jukka Lehtosalo, PR [17829](https://github.com/python/mypy/pull/17829))
 * Make "X | Y" union syntax more prominent in documentation (Jukka Lehtosalo, PR [17835](https://github.com/python/mypy/pull/17835))
 * Discuss upper bounds before self types in documentation (Jukka Lehtosalo, PR [17827](https://github.com/python/mypy/pull/17827))
 * Make changelog visible in mypy documentation (quinn-sasha, PR [17742](https://github.com/python/mypy/pull/17742))
 * List all incomplete features in `--enable-incomplete-feature` docs (sobolevn, PR [17633](https://github.com/python/mypy/pull/17633))
 * Remove the explicit setting of a pygments theme (Pradyun Gedam, PR [17571](https://github.com/python/mypy/pull/17571))
 * Document ReadOnly with TypedDict (Jukka Lehtosalo, PR [17905](https://github.com/python/mypy/pull/17905))
 * Document TypeIs (Chelsea Durazo, PR [17821](https://github.com/python/mypy/pull/17821))

### Experimental Inline TypedDict Syntax

Mypy now supports a non-standard, experimental syntax for defining anonymous TypedDicts.
Example:

```python
def func(n: str, y: int) -> {"name": str, "year": int}:
    return {"name": n, "year": y}
```

The feature is disabled by default. Use `--enable-incomplete-feature=InlineTypedDict` to
enable it. *We might remove this feature in a future release.*

This feature was contributed by Ivan Levkivskyi (PR [17457](https://github.com/python/mypy/pull/17457)).

### Stubgen Improvements

 * Fix crash on literal class-level keywords (sobolevn, PR [17663](https://github.com/python/mypy/pull/17663))
 * Stubgen add `--version` (sobolevn, PR [17662](https://github.com/python/mypy/pull/17662))
 * Fix `stubgen --no-analysis/--parse-only` docs (sobolevn, PR [17632](https://github.com/python/mypy/pull/17632))
 * Include keyword only args when generating signatures in stubgenc (Eric Mark Martin, PR [17448](https://github.com/python/mypy/pull/17448))
 * Add support for detecting `Literal` types when extracting types from docstrings (Michael Carlstrom, PR [17441](https://github.com/python/mypy/pull/17441))
 * Use `Generator` type var defaults (Sebastian Rittau, PR [17670](https://github.com/python/mypy/pull/17670))

### Stubtest Improvements
 * Add support for `cached_property` (Ali Hamdan, PR [17626](https://github.com/python/mypy/pull/17626))
 * Add `enable_incomplete_feature` validation to `stubtest` (sobolevn, PR [17635](https://github.com/python/mypy/pull/17635))
 * Fix error code handling in `stubtest` with `--mypy-config-file` (sobolevn, PR [17629](https://github.com/python/mypy/pull/17629))

### Other Notables Fixes and Improvements

 * Report error if using unsupported type parameter defaults (Jukka Lehtosalo, PR [17876](https://github.com/python/mypy/pull/17876))
 * Fix re-processing cross-reference in mypy daemon when node kind changes (Ivan Levkivskyi, PR [17883](https://github.com/python/mypy/pull/17883))
 * Don't use equality to narrow when value is IntEnum/StrEnum (Jukka Lehtosalo, PR [17866](https://github.com/python/mypy/pull/17866))
 * Don't consider None vs IntEnum comparison ambiguous (Jukka Lehtosalo, PR [17877](https://github.com/python/mypy/pull/17877))
 * Fix narrowing of IntEnum and StrEnum types (Jukka Lehtosalo, PR [17874](https://github.com/python/mypy/pull/17874))
 * Filter overload items based on self type during type inference (Jukka Lehtosalo, PR [17873](https://github.com/python/mypy/pull/17873))
 * Enable negative narrowing of union TypeVar upper bounds (Brian Schubert, PR [17850](https://github.com/python/mypy/pull/17850))
 * Fix issue with member expression formatting (Brian Schubert, PR [17848](https://github.com/python/mypy/pull/17848))
 * Avoid type size explosion when expanding types (Jukka Lehtosalo, PR [17842](https://github.com/python/mypy/pull/17842))
 * Fix negative narrowing of tuples in match statement (Brian Schubert, PR [17817](https://github.com/python/mypy/pull/17817))
 * Narrow falsey str/bytes/int to literal type (Brian Schubert, PR [17818](https://github.com/python/mypy/pull/17818))
 * Test against latest Python 3.13, make testing 3.14 easy (Shantanu, PR [17812](https://github.com/python/mypy/pull/17812))
 * Reject ParamSpec-typed callables calls with insufficient arguments (Stanislav Terliakov, PR [17323](https://github.com/python/mypy/pull/17323))
 * Fix crash when passing too many type arguments to generic base class accepting single ParamSpec (Brian Schubert, PR [17770](https://github.com/python/mypy/pull/17770))
 * Fix TypeVar upper bounds sometimes not being displayed in pretty callables (Brian Schubert, PR [17802](https://github.com/python/mypy/pull/17802))
 * Added error code for overlapping function signatures (Katrina Connors, PR [17597](https://github.com/python/mypy/pull/17597))
 * Check for `truthy-bool` in `not ...` unary expressions (sobolevn, PR [17773](https://github.com/python/mypy/pull/17773))
 * Add missing lines-covered and lines-valid attributes (Soubhik Kumar Mitra, PR [17738](https://github.com/python/mypy/pull/17738))
 * Fix another crash scenario with recursive tuple types (Ivan Levkivskyi, PR [17708](https://github.com/python/mypy/pull/17708))
 * Resolve TypeVar upper bounds in `functools.partial` (Shantanu, PR [17660](https://github.com/python/mypy/pull/17660))
 * Always reset binder when checking deferred nodes (Ivan Levkivskyi, PR [17643](https://github.com/python/mypy/pull/17643))
 * Fix crash on a callable attribute with single unpack (Ivan Levkivskyi, PR [17641](https://github.com/python/mypy/pull/17641))
 * Fix mismatched signature between checker plugin API and implementation (bzoracler, PR [17343](https://github.com/python/mypy/pull/17343))
 * Indexing a type also produces a GenericAlias (Shantanu, PR [17546](https://github.com/python/mypy/pull/17546))
 * Fix crash on self-type in callable protocol (Ivan Levkivskyi, PR [17499](https://github.com/python/mypy/pull/17499))
 * Fix crash on NamedTuple with method and error in function (Ivan Levkivskyi, PR [17498](https://github.com/python/mypy/pull/17498))
 * Add `__replace__` for dataclasses in 3.13 (Max Muoto, PR [17469](https://github.com/python/mypy/pull/17469))
 * Fix help message for `--no-namespace-packages` (Raphael Krupinski, PR [17472](https://github.com/python/mypy/pull/17472))
 * Fix typechecking for async generators (Danny Yang, PR [17452](https://github.com/python/mypy/pull/17452))
 * Fix strict optional handling in attrs plugin (Ivan Levkivskyi, PR [17451](https://github.com/python/mypy/pull/17451))
 * Allow mixing ParamSpec and TypeVarTuple in Generic (Ivan Levkivskyi, PR [17450](https://github.com/python/mypy/pull/17450))
 * Improvements to `functools.partial` of types (Shantanu, PR [17898](https://github.com/python/mypy/pull/17898))
 * Make ReadOnly TypedDict items covariant (Jukka Lehtosalo, PR [17904](https://github.com/python/mypy/pull/17904))
 * Fix union callees with `functools.partial` (Jukka Lehtosalo, PR [17903](https://github.com/python/mypy/pull/17903))
 * Improve handling of generic functions with `functools.partial` (Ivan Levkivskyi, PR [17925](https://github.com/python/mypy/pull/17925))

### Typeshed Updates

Please see [git log](https://github.com/python/typeshed/commits/main?after=91a58b07cdd807b1d965e04ba85af2adab8bf924+0&branch=main&path=stdlib) for full list of standard library typeshed stub changes.

### Mypy 1.12.1
 * Fix crash when showing partially analyzed type in error message (Ivan Levkivskyi, PR [17961](https://github.com/python/mypy/pull/17961))
 * Fix iteration over union (when self type is involved) (Shantanu, PR [17976](https://github.com/python/mypy/pull/17976))
 * Fix type object with type var default in union context (Jukka Lehtosalo, PR [17991](https://github.com/python/mypy/pull/17991))
 * Revert change to `os.path` stubs affecting use of `os.PathLike[Any]` (Shantanu, PR [17995](https://github.com/python/mypy/pull/17995))

### Acknowledgements
Thanks to all mypy contributors who contributed to this release:

- Ali Hamdan
- Anders Kaseorg
- Bénédikt Tran
- Brian Schubert
- bzoracler
- Chelsea Durazo
- Danny Yang
- Edgar Ramírez Mondragón
- Eric Mark Martin
- InSync
- Ivan Levkivskyi
- Jordandev678
- Katrina Connors
- Kirill Podoprigora
- Marc Mueller
- Max Muoto
- Max Murin
- Michael Carlstrom
- Michael I Chen
- Pradyun Gedam
- quinn-sasha
- Raphael Krupinski
- Sebastian Rittau
- Shantanu
- sobolevn
- Soubhik Kumar Mitra
- Stanislav Terliakov
- wyattscarpenter

I’d also like to thank my employer, Dropbox, for supporting mypy development.


## Mypy 1.11

We’ve just uploaded mypy 1.11 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Support Python 3.12 Syntax for Generics (PEP 695)

Mypy now supports the new type parameter syntax introduced in Python 3.12 ([PEP 695](https://peps.python.org/pep-0695/)).
This feature is still experimental and must be enabled with the `--enable-incomplete-feature=NewGenericSyntax` flag, or with `enable_incomplete_feature = NewGenericSyntax` in the mypy configuration file.
We plan to enable this by default in the next mypy feature release.

This example demonstrates the new syntax:

```python
# Generic function
def f[T](x: T) -> T: ...

reveal_type(f(1))  # Revealed type is 'int'

# Generic class
class C[T]:
    def __init__(self, x: T) -> None:
       self.x = x

c = C('a')
reveal_type(c.x)  # Revealed type is 'str'

# Type alias
type A[T] = C[list[T]]
```

This feature was contributed by Jukka Lehtosalo.


### Support for `functools.partial`

Mypy now type checks uses of `functools.partial`. Previously mypy would accept arbitrary arguments.

This example will now produce an error:

```python
from functools import partial

def f(a: int, b: str) -> None: ...

g = partial(f, 1)

# Argument has incompatible type "int"; expected "str"
g(11)
```

This feature was contributed by Shantanu (PR [16939](https://github.com/python/mypy/pull/16939)).


### Stricter Checks for Untyped Overrides

Past mypy versions didn't check if untyped methods were compatible with overridden methods. This would result in false negatives. Now mypy performs these checks when using `--check-untyped-defs`.

For example, this now generates an error if using `--check-untyped-defs`:

```python
class Base:
    def f(self, x: int = 0) -> None: ...

class Derived(Base):
    # Signature incompatible with "Base"
    def f(self): ...
```

This feature was contributed by Steven Troxler (PR [17276](https://github.com/python/mypy/pull/17276)).


### Type Inference Improvements

The new polymorphic inference algorithm introduced in mypy 1.5 is now used in more situations. This improves type inference involving generic higher-order functions, in particular.

This feature was contributed by Ivan Levkivskyi (PR [17348](https://github.com/python/mypy/pull/17348)).

Mypy now uses unions of tuple item types in certain contexts to enable more precise inferred types. Example:

```python
for x in (1, 'x'):
    # Previously inferred as 'object'
    reveal_type(x)  # Revealed type is 'int | str'
```

This was also contributed by Ivan Levkivskyi (PR [17408](https://github.com/python/mypy/pull/17408)).


### Improvements to Detection of Overlapping Overloads

The details of how mypy checks if two `@overload` signatures are unsafely overlapping were overhauled. This both fixes some false positives, and allows mypy to detect additional unsafe signatures.

This feature was contributed by Ivan Levkivskyi (PR [17392](https://github.com/python/mypy/pull/17392)).


### Better Support for Type Hints in Expressions

Mypy now allows more expressions that evaluate to valid type annotations in all expression contexts. The inferred types of these expressions are also sometimes more precise. Previously they were often `object`.

This example uses a union type that includes a callable type as an expression, and it no longer generates an error:

```python
from typing import Callable

print(Callable[[], int] | None)  # No error
```

This feature was contributed by Jukka Lehtosalo (PR [17404](https://github.com/python/mypy/pull/17404)).


### Mypyc Improvements

Mypyc now supports the new syntax for generics introduced in Python 3.12 (see above). Another notable improvement is signficantly faster basic operations on `int` values.

 * Support Python 3.12 syntax for generic functions and classes (Jukka Lehtosalo, PR [17357](https://github.com/python/mypy/pull/17357))
 * Support Python 3.12 type alias syntax (Jukka Lehtosalo, PR [17384](https://github.com/python/mypy/pull/17384))
 * Fix ParamSpec (Shantanu, PR [17309](https://github.com/python/mypy/pull/17309))
 * Inline fast paths of integer unboxing operations (Jukka Lehtosalo, PR [17266](https://github.com/python/mypy/pull/17266))
 * Inline tagged integer arithmetic and bitwise operations (Jukka Lehtosalo, PR [17265](https://github.com/python/mypy/pull/17265))
 * Allow specifying primitives as pure (Jukka Lehtosalo, PR [17263](https://github.com/python/mypy/pull/17263))


### Changes to Stubtest
 * Ignore `_ios_support` (Alex Waygood, PR [17270](https://github.com/python/mypy/pull/17270))
 * Improve support for Python 3.13 (Shantanu, PR [17261](https://github.com/python/mypy/pull/17261))


### Changes to Stubgen
 * Gracefully handle invalid `Optional` and recognize aliases to PEP 604 unions (Ali Hamdan, PR [17386](https://github.com/python/mypy/pull/17386))
 * Fix for Python 3.13 (Jelle Zijlstra, PR [17290](https://github.com/python/mypy/pull/17290))
 * Preserve enum value initialisers (Shantanu, PR [17125](https://github.com/python/mypy/pull/17125))


### Miscellaneous New Features
 * Add error format support and JSON output option via `--output json` (Tushar Sadhwani, PR [11396](https://github.com/python/mypy/pull/11396))
 * Support `enum.member` in Python 3.11+ (Nikita Sobolev, PR [17382](https://github.com/python/mypy/pull/17382))
 * Support `enum.nonmember` in Python 3.11+ (Nikita Sobolev, PR [17376](https://github.com/python/mypy/pull/17376))
 * Support `namedtuple.__replace__` in Python 3.13 (Shantanu, PR [17259](https://github.com/python/mypy/pull/17259))
 * Support `rename=True` in collections.namedtuple (Jelle Zijlstra, PR [17247](https://github.com/python/mypy/pull/17247))
 * Add support for `__spec__` (Shantanu, PR [14739](https://github.com/python/mypy/pull/14739))


### Changes to Error Reporting
 * Mention `--enable-incomplete-feature=NewGenericSyntax` in messages (Shantanu, PR [17462](https://github.com/python/mypy/pull/17462))
 * Do not report plugin-generated methods with `explicit-override` (sobolevn, PR [17433](https://github.com/python/mypy/pull/17433))
 * Use and display namespaces for function type variables (Ivan Levkivskyi, PR [17311](https://github.com/python/mypy/pull/17311))
 * Fix false positive for Final local scope variable in Protocol (GiorgosPapoutsakis, PR [17308](https://github.com/python/mypy/pull/17308))
 * Use Never in more messages, use ambiguous in join (Shantanu, PR [17304](https://github.com/python/mypy/pull/17304))
 * Log full path to config file in verbose output (dexterkennedy, PR [17180](https://github.com/python/mypy/pull/17180))
 * Added `[prop-decorator]` code for unsupported property decorators (#14461) (Christopher Barber, PR [16571](https://github.com/python/mypy/pull/16571))
 * Suppress second error message with `:=` and `[truthy-bool]` (Nikita Sobolev, PR [15941](https://github.com/python/mypy/pull/15941))
 * Generate error for assignment of functional Enum to variable of different name (Shantanu, PR [16805](https://github.com/python/mypy/pull/16805))
 * Fix error reporting on cached run after uninstallation of third party library (Shantanu, PR [17420](https://github.com/python/mypy/pull/17420))


### Fixes for Crashes
 * Fix daemon crash on invalid type in TypedDict (Ivan Levkivskyi, PR [17495](https://github.com/python/mypy/pull/17495))
 * Fix crash and bugs related to `partial()` (Ivan Levkivskyi, PR [17423](https://github.com/python/mypy/pull/17423))
 * Fix crash when overriding with unpacked TypedDict (Ivan Levkivskyi, PR [17359](https://github.com/python/mypy/pull/17359))
 * Fix crash on TypedDict unpacking for ParamSpec (Ivan Levkivskyi, PR [17358](https://github.com/python/mypy/pull/17358))
 * Fix crash involving recursive union of tuples (Ivan Levkivskyi, PR [17353](https://github.com/python/mypy/pull/17353))
 * Fix crash on invalid callable property override (Ivan Levkivskyi, PR [17352](https://github.com/python/mypy/pull/17352))
 * Fix crash on unpacking self in NamedTuple (Ivan Levkivskyi, PR [17351](https://github.com/python/mypy/pull/17351))
 * Fix crash on recursive alias with an optional type (Ivan Levkivskyi, PR [17350](https://github.com/python/mypy/pull/17350))
 * Fix crash on type comment inside generic definitions (Bénédikt Tran, PR [16849](https://github.com/python/mypy/pull/16849))


### Changes to Documentation
 * Use inline config in documentation for optional error codes (Shantanu, PR [17374](https://github.com/python/mypy/pull/17374))
 * Use lower-case generics in documentation (Seo Sanghyeon, PR [17176](https://github.com/python/mypy/pull/17176))
 * Add documentation for show-error-code-links (GiorgosPapoutsakis, PR [17144](https://github.com/python/mypy/pull/17144))
 * Update CONTRIBUTING.md to include commands for Windows (GiorgosPapoutsakis, PR [17142](https://github.com/python/mypy/pull/17142))


### Other Notable Improvements and Fixes
 * Fix ParamSpec inference against TypeVarTuple (Ivan Levkivskyi, PR [17431](https://github.com/python/mypy/pull/17431))
 * Fix explicit type for `partial` (Ivan Levkivskyi, PR [17424](https://github.com/python/mypy/pull/17424))
 * Always allow lambda calls (Ivan Levkivskyi, PR [17430](https://github.com/python/mypy/pull/17430))
 * Fix isinstance checks with PEP 604 unions containing None (Shantanu, PR [17415](https://github.com/python/mypy/pull/17415))
 * Fix self-referential upper bound in new-style type variables (Ivan Levkivskyi, PR [17407](https://github.com/python/mypy/pull/17407))
 * Consider overlap between instances and callables (Ivan Levkivskyi, PR [17389](https://github.com/python/mypy/pull/17389))
 * Allow new-style self-types in classmethods (Ivan Levkivskyi, PR [17381](https://github.com/python/mypy/pull/17381))
 * Fix isinstance with type aliases to PEP 604 unions (Shantanu, PR [17371](https://github.com/python/mypy/pull/17371))
 * Properly handle unpacks in overlap checks (Ivan Levkivskyi, PR [17356](https://github.com/python/mypy/pull/17356))
 * Fix type application for classes with generic constructors (Ivan Levkivskyi, PR [17354](https://github.com/python/mypy/pull/17354))
 * Update `typing_extensions` to >=4.6.0 to fix Python 3.12 error (Ben Brown, PR [17312](https://github.com/python/mypy/pull/17312))
 * Avoid "does not return" error in lambda (Shantanu, PR [17294](https://github.com/python/mypy/pull/17294))
 * Fix bug with descriptors in non-strict-optional mode (Max Murin, PR [17293](https://github.com/python/mypy/pull/17293))
 * Don’t leak unreachability from lambda body to surrounding scope (Anders Kaseorg, PR [17287](https://github.com/python/mypy/pull/17287))
 * Fix issues with non-ASCII characters on Windows (Alexander Leopold Shon, PR [17275](https://github.com/python/mypy/pull/17275))
 * Fix for type narrowing of negative integer literals (gilesgc, PR [17256](https://github.com/python/mypy/pull/17256))
 * Fix confusion between .py and .pyi files in mypy daemon (Valentin Stanciu, PR [17245](https://github.com/python/mypy/pull/17245))
 * Fix type of `tuple[X, Y]` expression (urnest, PR [17235](https://github.com/python/mypy/pull/17235))
 * Don't forget that a `TypedDict` was wrapped in `Unpack` after a `name-defined` error occurred (Christoph Tyralla, PR [17226](https://github.com/python/mypy/pull/17226))
 * Mark annotated argument as having an explicit, not inferred type (bzoracler, PR [17217](https://github.com/python/mypy/pull/17217))
 * Don't consider Enum private attributes as enum members (Ali Hamdan, PR [17182](https://github.com/python/mypy/pull/17182))
 * Fix Literal strings containing pipe characters (Jelle Zijlstra, PR [17148](https://github.com/python/mypy/pull/17148))


### Typeshed Updates

Please see [git log](https://github.com/python/typeshed/commits/main?after=6dda799d8ad1d89e0f8aad7ac41d2d34bd838ace+0&branch=main&path=stdlib) for full list of standard library typeshed stub changes.

### Mypy 1.11.1
 * Fix `RawExpressionType.accept` crash with `--cache-fine-grained` (Anders Kaseorg, PR [17588](https://github.com/python/mypy/pull/17588))
 * Fix PEP 604 isinstance caching (Shantanu, PR [17563](https://github.com/python/mypy/pull/17563))
 * Fix `typing.TypeAliasType` being undefined on python < 3.12 (Nikita Sobolev, PR [17558](https://github.com/python/mypy/pull/17558))
 * Fix `types.GenericAlias` lookup crash (Shantanu, PR [17543](https://github.com/python/mypy/pull/17543))

### Mypy 1.11.2
 * Alternative fix for a union-like literal string (Ivan Levkivskyi, PR [17639](https://github.com/python/mypy/pull/17639))
 * Unwrap `TypedDict` item types before storing (Ivan Levkivskyi, PR [17640](https://github.com/python/mypy/pull/17640))

### Acknowledgements
Thanks to all mypy contributors who contributed to this release:

- Alex Waygood
- Alexander Leopold Shon
- Ali Hamdan
- Anders Kaseorg
- Ben Brown
- Bénédikt Tran
- bzoracler
- Christoph Tyralla
- Christopher Barber
- dexterkennedy
- gilesgc
- GiorgosPapoutsakis
- Ivan Levkivskyi
- Jelle Zijlstra
- Jukka Lehtosalo
- Marc Mueller
- Matthieu Devlin
- Michael R. Crusoe
- Nikita Sobolev
- Seo Sanghyeon
- Shantanu
- sobolevn
- Steven Troxler
- Tadeu Manoel
- Tamir Duberstein
- Tushar Sadhwani
- urnest
- Valentin Stanciu

I’d also like to thank my employer, Dropbox, for supporting mypy development.


## Mypy 1.10

We’ve just uploaded mypy 1.10 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Support TypeIs (PEP 742)

Mypy now supports `TypeIs` ([PEP 742](https://peps.python.org/pep-0742/)), which allows
functions to narrow the type of a value, similar to `isinstance()`. Unlike `TypeGuard`,
`TypeIs` can narrow in both the `if` and `else` branches of an if statement:

```python
from typing_extensions import TypeIs

def is_str(s: object) -> TypeIs[str]:
    return isinstance(s, str)

def f(o: str | int) -> None:
    if is_str(o):
        # Type of o is 'str'
        ...
    else:
        # Type of o is 'int'
        ...
```

`TypeIs` will be added to the `typing` module in Python 3.13, but it
can be used on earlier Python versions by importing it from
`typing_extensions`.

This feature was contributed by Jelle Zijlstra (PR [16898](https://github.com/python/mypy/pull/16898)).

### Support TypeVar Defaults (PEP 696)

[PEP 696](https://peps.python.org/pep-0696/) adds support for type parameter defaults.
Example:

```python
from typing import Generic
from typing_extensions import TypeVar

T = TypeVar("T", default=int)

class C(Generic[T]):
   ...

x: C = ...
y: C[str] = ...
reveal_type(x)  # C[int], because of the default
reveal_type(y)  # C[str]
```

TypeVar defaults will be added to the `typing` module in Python 3.13, but they
can be used with earlier Python releases by importing `TypeVar` from
`typing_extensions`.

This feature was contributed by Marc Mueller (PR [16878](https://github.com/python/mypy/pull/16878)
and PR [16925](https://github.com/python/mypy/pull/16925)).

### Support TypeAliasType (PEP 695)
As part of the initial steps towards implementing [PEP 695](https://peps.python.org/pep-0695/), mypy now supports `TypeAliasType`.
`TypeAliasType` provides a backport of the new `type` statement in Python 3.12.

```python
type ListOrSet[T] = list[T] | set[T]
```

is equivalent to:

```python
T = TypeVar("T")
ListOrSet = TypeAliasType("ListOrSet", list[T] | set[T], type_params=(T,))
```

Example of use in mypy:

```python
from typing_extensions import TypeAliasType, TypeVar

NewUnionType = TypeAliasType("NewUnionType", int | str)
x: NewUnionType = 42
y: NewUnionType = 'a'
z: NewUnionType = object()  # error: Incompatible types in assignment (expression has type "object", variable has type "int | str")  [assignment]

T = TypeVar("T")
ListOrSet = TypeAliasType("ListOrSet", list[T] | set[T], type_params=(T,))
a: ListOrSet[int] = [1, 2]
b: ListOrSet[str] = {'a', 'b'}
c: ListOrSet[str] = 'test'  # error: Incompatible types in assignment (expression has type "str", variable has type "list[str] | set[str]")  [assignment]
```

`TypeAliasType` was added to the `typing` module in Python 3.12, but it can be used with earlier Python releases by importing from `typing_extensions`.

This feature was contributed by Ali Hamdan (PR [16926](https://github.com/python/mypy/pull/16926), PR [17038](https://github.com/python/mypy/pull/17038) and PR [17053](https://github.com/python/mypy/pull/17053))

### Detect Additional Unsafe Uses of super()

Mypy will reject unsafe uses of `super()` more consistently, when the target has a
trivial (empty) body. Example:

```python
class Proto(Protocol):
    def method(self) -> int: ...

class Sub(Proto):
    def method(self) -> int:
        return super().meth()  # Error (unsafe)
```

This feature was contributed by Shantanu (PR [16756](https://github.com/python/mypy/pull/16756)).

### Stubgen Improvements
- Preserve empty tuple annotation (Ali Hamdan, PR [16907](https://github.com/python/mypy/pull/16907))
- Add support for PEP 570 positional-only parameters (Ali Hamdan, PR [16904](https://github.com/python/mypy/pull/16904))
- Replace obsolete typing aliases with builtin containers (Ali Hamdan, PR [16780](https://github.com/python/mypy/pull/16780))
- Fix generated dataclass `__init__` signature (Ali Hamdan, PR [16906](https://github.com/python/mypy/pull/16906))

### Mypyc Improvements

- Provide an easier way to define IR-to-IR transforms (Jukka Lehtosalo, PR [16998](https://github.com/python/mypy/pull/16998))
- Implement lowering pass and add primitives for int (in)equality (Jukka Lehtosalo, PR [17027](https://github.com/python/mypy/pull/17027))
- Implement lowering for remaining tagged integer comparisons (Jukka Lehtosalo, PR [17040](https://github.com/python/mypy/pull/17040))
- Optimize away some bool/bit registers (Jukka Lehtosalo, PR [17022](https://github.com/python/mypy/pull/17022))
- Remangle redefined names produced by async with (Richard Si, PR [16408](https://github.com/python/mypy/pull/16408))
- Optimize TYPE_CHECKING to False at Runtime (Srinivas Lade, PR [16263](https://github.com/python/mypy/pull/16263))
- Fix compilation of unreachable comprehensions (Richard Si, PR [15721](https://github.com/python/mypy/pull/15721))
- Don't crash on non-inlinable final local reads (Richard Si, PR [15719](https://github.com/python/mypy/pull/15719))

### Documentation Improvements
- Import `TypedDict` from `typing` instead of `typing_extensions` (Riccardo Di Maio, PR [16958](https://github.com/python/mypy/pull/16958))
- Add missing `mutable-override` to section title (James Braza, PR [16886](https://github.com/python/mypy/pull/16886))

### Error Reporting Improvements

- Use lower-case generics more consistently in error messages (Jukka Lehtosalo, PR [17035](https://github.com/python/mypy/pull/17035))

### Other Notable Changes and Fixes
- Fix incorrect inferred type when accessing descriptor on union type (Matthieu Devlin, PR [16604](https://github.com/python/mypy/pull/16604))
- Fix crash when expanding invalid `Unpack` in a `Callable` alias (Ali Hamdan, PR [17028](https://github.com/python/mypy/pull/17028))
- Fix false positive when string formatting with string enum (roberfi, PR [16555](https://github.com/python/mypy/pull/16555))
- Narrow individual items when matching a tuple to a sequence pattern (Loïc Simon, PR [16905](https://github.com/python/mypy/pull/16905))
- Fix false positive from type variable within TypeGuard or TypeIs (Evgeniy Slobodkin, PR [17071](https://github.com/python/mypy/pull/17071))
- Improve `yield from` inference for unions of generators (Shantanu, PR [16717](https://github.com/python/mypy/pull/16717))
- Fix emulating hash method logic in `attrs` classes (Hashem, PR [17016](https://github.com/python/mypy/pull/17016))
- Add reverted typeshed commit that uses `ParamSpec` for `functools.wraps` (Tamir Duberstein, PR [16942](https://github.com/python/mypy/pull/16942))
- Fix type narrowing for `types.EllipsisType` (Shantanu, PR [17003](https://github.com/python/mypy/pull/17003))
- Fix single item enum match type exhaustion (Oskari Lehto, PR [16966](https://github.com/python/mypy/pull/16966))
- Improve type inference with empty collections (Marc Mueller, PR [16994](https://github.com/python/mypy/pull/16994))
- Fix override checking for decorated property (Shantanu, PR [16856](https://github.com/python/mypy/pull/16856))
- Fix narrowing on match with function subject (Edward Paget, PR [16503](https://github.com/python/mypy/pull/16503))
- Allow `+N` within `Literal[...]` (Spencer Brown, PR [16910](https://github.com/python/mypy/pull/16910))
- Experimental: Support TypedDict within `type[...]` (Marc Mueller, PR [16963](https://github.com/python/mypy/pull/16963))
- Experimtental: Fix issue with TypedDict with optional keys in `type[...]` (Marc Mueller, PR [17068](https://github.com/python/mypy/pull/17068))

### Typeshed Updates

Please see [git log](https://github.com/python/typeshed/commits/main?after=6dda799d8ad1d89e0f8aad7ac41d2d34bd838ace+0&branch=main&path=stdlib) for full list of standard library typeshed stub changes.

### Mypy 1.10.1

- Fix error reporting on cached run after uninstallation of third party library (Shantanu, PR [17420](https://github.com/python/mypy/pull/17420))

### Acknowledgements
Thanks to all mypy contributors who contributed to this release:

- Alex Waygood
- Ali Hamdan
- Edward Paget
- Evgeniy Slobodkin
- Hashem
- hesam
- Hugo van Kemenade
- Ihor
- James Braza
- Jelle Zijlstra
- jhance
- Jukka Lehtosalo
- Loïc Simon
- Marc Mueller
- Matthieu Devlin
- Michael R. Crusoe
- Nikita Sobolev
- Oskari Lehto
- Riccardo Di Maio
- Richard Si
- roberfi
- Roman Solomatin
- Sam Xifaras
- Shantanu
- Spencer Brown
- Srinivas Lade
- Tamir Duberstein
- youkaichao

I’d also like to thank my employer, Dropbox, for supporting mypy development.


## Mypy 1.9

We’ve just uploaded mypy 1.9 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Breaking Changes

Because the version of typeshed we use in mypy 1.9 doesn't support 3.7, neither does mypy 1.9. (Jared Hance, PR [16883](https://github.com/python/mypy/pull/16883))

We are planning to enable
[local partial types](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-local-partial-types) (enabled via the
`--local-partial-types` flag) later this year by default. This change
was announced years ago, but now it's finally happening. This is a
major backward-incompatible change, so we'll probably include it as
part of the upcoming mypy 2.0 release. This makes daemon and
non-daemon mypy runs have the same behavior by default.

Local partial types can also be enabled in the mypy config file:
```
local_partial_types = True
```

We are looking at providing a tool to make it easier to migrate
projects to use `--local-partial-types`, but it's not yet clear whether
this is practical. The migration usually involves adding some
explicit type annotations to module-level and class-level variables.

### Basic Support for Type Parameter Defaults (PEP 696)

This release contains new experimental support for type parameter
defaults ([PEP 696](https://peps.python.org/pep-0696)). Please try it
out! This feature was contributed by Marc Mueller.

Since this feature will be officially introduced in the next Python
feature release (3.13), you will need to import `TypeVar`, `ParamSpec`
or `TypeVarTuple` from `typing_extensions` to use defaults for now.

This example adapted from the PEP defines a default for `BotT`:
```python
from typing import Generic
from typing_extensions import TypeVar

class Bot: ...

BotT = TypeVar("BotT", bound=Bot, default=Bot)

class Context(Generic[BotT]):
    bot: BotT

class MyBot(Bot): ...

# type is Bot (the default)
reveal_type(Context().bot)
# type is MyBot
reveal_type(Context[MyBot]().bot)
```

### Type-checking Improvements
 * Fix missing type store for overloads (Marc Mueller, PR [16803](https://github.com/python/mypy/pull/16803))
 * Fix `'WriteToConn' object has no attribute 'flush'` (Charlie Denton, PR [16801](https://github.com/python/mypy/pull/16801))
 * Improve TypeAlias error messages (Marc Mueller, PR [16831](https://github.com/python/mypy/pull/16831))
 * Support narrowing unions that include `type[None]` (Christoph Tyralla, PR [16315](https://github.com/python/mypy/pull/16315))
 * Support TypedDict functional syntax as class base type (anniel-stripe, PR [16703](https://github.com/python/mypy/pull/16703))
 * Accept multiline quoted annotations (Shantanu, PR [16765](https://github.com/python/mypy/pull/16765))
 * Allow unary + in `Literal` (Jelle Zijlstra, PR [16729](https://github.com/python/mypy/pull/16729))
 * Substitute type variables in return type of static methods (Kouroche Bouchiat, PR [16670](https://github.com/python/mypy/pull/16670))
 * Consider TypeVarTuple to be invariant (Marc Mueller, PR [16759](https://github.com/python/mypy/pull/16759))
 * Add `alias` support to `field()` in `attrs` plugin (Nikita Sobolev, PR [16610](https://github.com/python/mypy/pull/16610))
 * Improve attrs hashability detection (Tin Tvrtković, PR [16556](https://github.com/python/mypy/pull/16556))

### Performance Improvements

 * Speed up finding function type variables (Jukka Lehtosalo, PR [16562](https://github.com/python/mypy/pull/16562))

### Documentation Updates

 * Document supported values for `--enable-incomplete-feature` in "mypy --help" (Froger David, PR [16661](https://github.com/python/mypy/pull/16661))
 * Update new type system discussion links (thomaswhaley, PR [16841](https://github.com/python/mypy/pull/16841))
 * Add missing class instantiation to cheat sheet (Aleksi Tarvainen, PR [16817](https://github.com/python/mypy/pull/16817))
 * Document how evil `--no-strict-optional` is (Shantanu, PR [16731](https://github.com/python/mypy/pull/16731))
 * Improve mypy daemon documentation note about local partial types (Makonnen Makonnen, PR [16782](https://github.com/python/mypy/pull/16782))
 * Fix numbering error (Stefanie Molin, PR [16838](https://github.com/python/mypy/pull/16838))
 * Various documentation improvements (Shantanu, PR [16836](https://github.com/python/mypy/pull/16836))

### Stubtest Improvements
 * Ignore private function/method parameters when they are missing from the stub (private parameter names start with a single underscore and have a default) (PR [16507](https://github.com/python/mypy/pull/16507))
 * Ignore a new protocol dunder (Alex Waygood, PR [16895](https://github.com/python/mypy/pull/16895))
 * Private parameters can be omitted (Sebastian Rittau, PR [16507](https://github.com/python/mypy/pull/16507))
 * Add support for setting enum members to "..." (Jelle Zijlstra, PR [16807](https://github.com/python/mypy/pull/16807))
 * Adjust symbol table logic (Shantanu, PR [16823](https://github.com/python/mypy/pull/16823))
 * Fix posisitional-only handling in overload resolution (Shantanu, PR [16750](https://github.com/python/mypy/pull/16750))

### Stubgen Improvements
 * Fix crash on star unpack of TypeVarTuple (Ali Hamdan, PR [16869](https://github.com/python/mypy/pull/16869))
 * Use PEP 604 unions everywhere (Ali Hamdan, PR [16519](https://github.com/python/mypy/pull/16519))
 * Do not ignore property deleter (Ali Hamdan, PR [16781](https://github.com/python/mypy/pull/16781))
 * Support type stub generation for `staticmethod` (WeilerMarcel, PR [14934](https://github.com/python/mypy/pull/14934))

### Acknowledgements

​Thanks to all mypy contributors who contributed to this release:

- Aleksi Tarvainen
- Alex Waygood
- Ali Hamdan
- anniel-stripe
- Charlie Denton
- Christoph Tyralla
- Dheeraj
- Fabian Keller
- Fabian Lewis
- Froger David
- Ihor
- Jared Hance
- Jelle Zijlstra
- Jukka Lehtosalo
- Kouroche Bouchiat
- Lukas Geiger
- Maarten Huijsmans
- Makonnen Makonnen
- Marc Mueller
- Nikita Sobolev
- Sebastian Rittau
- Shantanu
- Stefanie Molin
- Stephen Morton
- thomaswhaley
- Tin Tvrtković
- WeilerMarcel
- Wesley Collin Wright
- zipperer

I’d also like to thank my employer, Dropbox, for supporting mypy development.

## Mypy 1.8

We’ve just uploaded mypy 1.8 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Type-checking Improvements
 * Do not intersect types in isinstance checks if at least one is final (Christoph Tyralla, PR [16330](https://github.com/python/mypy/pull/16330))
 * Detect that `@final` class without `__bool__` cannot have falsey instances (Ilya Priven, PR [16566](https://github.com/python/mypy/pull/16566))
 * Do not allow `TypedDict` classes with extra keywords (Nikita Sobolev, PR [16438](https://github.com/python/mypy/pull/16438))
 * Do not allow class-level keywords for `NamedTuple` (Nikita Sobolev, PR [16526](https://github.com/python/mypy/pull/16526))
 * Make imprecise constraints handling more robust (Ivan Levkivskyi, PR [16502](https://github.com/python/mypy/pull/16502))
 * Fix strict-optional in extending generic TypedDict (Ivan Levkivskyi, PR [16398](https://github.com/python/mypy/pull/16398))
 * Allow type ignores of PEP 695 constructs (Shantanu, PR [16608](https://github.com/python/mypy/pull/16608))
 * Enable `type_check_only` support for `TypedDict` and `NamedTuple` (Nikita Sobolev, PR [16469](https://github.com/python/mypy/pull/16469))

### Performance Improvements
 * Add fast path to analyzing special form assignments (Jukka Lehtosalo, PR [16561](https://github.com/python/mypy/pull/16561))

### Improvements to Error Reporting
 * Don't show documentation links for plugin error codes (Ivan Levkivskyi, PR [16383](https://github.com/python/mypy/pull/16383))
 * Improve error messages for `super` checks and add more tests (Nikita Sobolev, PR [16393](https://github.com/python/mypy/pull/16393))
 * Add error code for mutable covariant override (Ivan Levkivskyi, PR [16399](https://github.com/python/mypy/pull/16399))

### Stubgen Improvements
 * Preserve simple defaults in function signatures (Ali Hamdan, PR [15355](https://github.com/python/mypy/pull/15355))
 * Include `__all__` in output (Jelle Zijlstra, PR [16356](https://github.com/python/mypy/pull/16356))
 * Fix stubgen regressions with pybind11 and mypy 1.7 (Chad Dombrova, PR [16504](https://github.com/python/mypy/pull/16504))

### Stubtest Improvements
 * Improve handling of unrepresentable defaults (Jelle Zijlstra, PR [16433](https://github.com/python/mypy/pull/16433))
 * Print more helpful errors if a function is missing from stub (Alex Waygood, PR [16517](https://github.com/python/mypy/pull/16517))
 * Support `@type_check_only` decorator (Nikita Sobolev, PR [16422](https://github.com/python/mypy/pull/16422))
 * Warn about missing `__del__` (Shantanu, PR [16456](https://github.com/python/mypy/pull/16456))
 * Fix crashes with some uses of `final` and `deprecated` (Shantanu, PR [16457](https://github.com/python/mypy/pull/16457))

### Fixes to Crashes
 * Fix crash with type alias to `Callable[[Unpack[Tuple[Any, ...]]], Any]` (Alex Waygood, PR [16541](https://github.com/python/mypy/pull/16541))
 * Fix crash on TypeGuard in `__call__` (Ivan Levkivskyi, PR [16516](https://github.com/python/mypy/pull/16516))
 * Fix crash on invalid enum in method (Ivan Levkivskyi, PR [16511](https://github.com/python/mypy/pull/16511))
 * Fix crash on unimported Any in TypedDict (Ivan Levkivskyi, PR [16510](https://github.com/python/mypy/pull/16510))

### Documentation Updates
 * Update soft-error-limit default value to -1 (Sveinung Gundersen, PR [16542](https://github.com/python/mypy/pull/16542))
 * Support Sphinx 7.x (Michael R. Crusoe, PR [16460](https://github.com/python/mypy/pull/16460))

### Other Notable Changes and Fixes
 * Allow mypy to output a junit file with per-file results (Matthew Wright, PR [16388](https://github.com/python/mypy/pull/16388))

### Typeshed Updates

Please see [git log](https://github.com/python/typeshed/commits/main?after=4a854366e03dee700109f8e758a08b2457ea2f51+0&branch=main&path=stdlib) for full list of standard library typeshed stub changes.

### Acknowledgements

​Thanks to all mypy contributors who contributed to this release:

- Alex Waygood
- Ali Hamdan
- Chad Dombrova
- Christoph Tyralla
- Ilya Priven
- Ivan Levkivskyi
- Jelle Zijlstra
- Jukka Lehtosalo
- Marcel Telka
- Matthew Wright
- Michael R. Crusoe
- Nikita Sobolev
- Ole Peder Brandtzæg
- robjhornby
- Shantanu
- Sveinung Gundersen
- Valentin Stanciu

I’d also like to thank my employer, Dropbox, for supporting mypy development.

Posted by Wesley Collin Wright

## Mypy 1.7

We’ve just uploaded mypy 1.7 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Using TypedDict for `**kwargs` Typing

Mypy now has support for using `Unpack[...]` with a TypedDict type to annotate `**kwargs` arguments enabled by default. Example:

```python
# Or 'from typing_extensions import ...'
from typing import TypedDict, Unpack

class Person(TypedDict):
    name: str
    age: int

def foo(**kwargs: Unpack[Person]) -> None:
    ...

foo(name="x", age=1)  # Ok
foo(name=1)  # Error
```

The definition of `foo` above is equivalent to the one below, with keyword-only arguments `name` and `age`:

```python
def foo(*, name: str, age: int) -> None:
    ...
```

Refer to [PEP 692](https://peps.python.org/pep-0692/) for more information. Note that unlike in the current version of the PEP, mypy always treats signatures with `Unpack[SomeTypedDict]` as equivalent to their expanded forms with explicit keyword arguments, and there aren't special type checking rules for TypedDict arguments.

This was contributed by Ivan Levkivskyi back in 2022 (PR [13471](https://github.com/python/mypy/pull/13471)).

### TypeVarTuple Support Enabled (Experimental)

Mypy now has support for variadic generics (TypeVarTuple) enabled by default, as an experimental feature. Refer to [PEP 646](https://peps.python.org/pep-0646/) for the details.

TypeVarTuple was implemented by Jared Hance and Ivan Levkivskyi over several mypy releases, with help from Jukka Lehtosalo.

Changes included in this release:

 * Fix handling of tuple type context with unpacks (Ivan Levkivskyi, PR [16444](https://github.com/python/mypy/pull/16444))
 * Handle TypeVarTuples when checking overload constraints (robjhornby, PR [16428](https://github.com/python/mypy/pull/16428))
 * Enable Unpack/TypeVarTuple support (Ivan Levkivskyi, PR [16354](https://github.com/python/mypy/pull/16354))
 * Fix crash on unpack call special-casing (Ivan Levkivskyi, PR [16381](https://github.com/python/mypy/pull/16381))
 * Some final touches for variadic types support (Ivan Levkivskyi, PR [16334](https://github.com/python/mypy/pull/16334))
 * Support PEP-646 and PEP-692 in the same callable (Ivan Levkivskyi, PR [16294](https://github.com/python/mypy/pull/16294))
 * Support new `*` syntax for variadic types (Ivan Levkivskyi, PR [16242](https://github.com/python/mypy/pull/16242))
 * Correctly handle variadic instances with empty arguments (Ivan Levkivskyi, PR [16238](https://github.com/python/mypy/pull/16238))
 * Correctly handle runtime type applications of variadic types (Ivan Levkivskyi, PR [16240](https://github.com/python/mypy/pull/16240))
 * Support variadic tuple packing/unpacking (Ivan Levkivskyi, PR [16205](https://github.com/python/mypy/pull/16205))
 * Better support for variadic calls and indexing (Ivan Levkivskyi, PR [16131](https://github.com/python/mypy/pull/16131))
 * Subtyping and inference of user-defined variadic types (Ivan Levkivskyi, PR [16076](https://github.com/python/mypy/pull/16076))
 * Complete type analysis of variadic types (Ivan Levkivskyi, PR [15991](https://github.com/python/mypy/pull/15991))

### New Way of Installing Mypyc Dependencies

If you want to install package dependencies needed by mypyc (not just mypy), you should now install `mypy[mypyc]` instead of just `mypy`:

```
python3 -m pip install -U 'mypy[mypyc]'
```

Mypy has many more users than mypyc, so always installing mypyc dependencies would often bring unnecessary dependencies.

This change was contributed by Shantanu (PR [16229](https://github.com/python/mypy/pull/16229)).

### New Rules for Re-exports

Mypy no longer considers an import such as `import a.b as b` as an explicit re-export. The old behavior was arguably inconsistent and surprising. This may impact some stub packages, such as older versions of `types-six`. You can change the import to `from a import b as b`, if treating the import as a re-export was intentional.

This change was contributed by Anders Kaseorg (PR [14086](https://github.com/python/mypy/pull/14086)).

### Improved Type Inference

The new type inference algorithm that was recently introduced to mypy (but was not enabled by default) is now enabled by default. It improves type inference of calls to generic callables where an argument is also a generic callable, in particular. You can use `--old-type-inference` to disable the new behavior.

The new algorithm can (rarely) produce different error messages, different error codes, or errors reported on different lines. This is more likely in cases where generic types were used incorrectly.

The new type inference algorithm was contributed by Ivan Levkivskyi. PR [16345](https://github.com/python/mypy/pull/16345) enabled it by default.

### Narrowing Tuple Types Using len()

Mypy now can narrow tuple types using `len()` checks. Example:

```python
def f(t: tuple[int, int] | tuple[int, int, int]) -> None:
    if len(t) == 2:
        a, b = t   # Ok
    ...
```

This feature was contributed by Ivan Levkivskyi (PR [16237](https://github.com/python/mypy/pull/16237)).

### More Precise Tuple Lengths (Experimental)

Mypy supports experimental, more precise checking of tuple type lengths through `--enable-incomplete-feature=PreciseTupleTypes`. Refer to the [documentation](https://mypy.readthedocs.io/en/latest/command_line.html#enabling-incomplete-experimental-features) for more information.

More generally, we are planning to use `--enable-incomplete-feature` to introduce experimental features that would benefit from community feedback.

This feature was contributed by Ivan Levkivskyi (PR [16237](https://github.com/python/mypy/pull/16237)).

### Mypy Changelog

We now maintain a [changelog](https://github.com/python/mypy/blob/master/CHANGELOG.md) in the mypy Git repository. It mirrors the contents of [mypy release blog posts](https://mypy-lang.blogspot.com/). We will continue to also publish release blog posts. In the future, release blog posts will be created based on the changelog near a release date.

This was contributed by Shantanu (PR [16280](https://github.com/python/mypy/pull/16280)).

### Mypy Daemon Improvements

 * Fix daemon crash caused by deleted submodule (Jukka Lehtosalo, PR [16370](https://github.com/python/mypy/pull/16370))
 * Fix file reloading in dmypy with --export-types (Ivan Levkivskyi, PR [16359](https://github.com/python/mypy/pull/16359))
 * Fix dmypy inspect on Windows (Ivan Levkivskyi, PR [16355](https://github.com/python/mypy/pull/16355))
 * Fix dmypy inspect for namespace packages (Ivan Levkivskyi, PR [16357](https://github.com/python/mypy/pull/16357))
 * Fix return type change to optional in generic function (Jukka Lehtosalo, PR [16342](https://github.com/python/mypy/pull/16342))
 * Fix daemon false positives related to module-level `__getattr__` (Jukka Lehtosalo, PR [16292](https://github.com/python/mypy/pull/16292))
 * Fix daemon crash related to ABCs (Jukka Lehtosalo, PR [16275](https://github.com/python/mypy/pull/16275))
 * Stream dmypy output instead of dumping everything at the end (Valentin Stanciu, PR [16252](https://github.com/python/mypy/pull/16252))
 * Make sure all dmypy errors are shown (Valentin Stanciu, PR [16250](https://github.com/python/mypy/pull/16250))

### Mypyc Improvements

 * Generate error on duplicate function definitions (Jukka Lehtosalo, PR [16309](https://github.com/python/mypy/pull/16309))
 * Don't crash on unreachable statements (Jukka Lehtosalo, PR [16311](https://github.com/python/mypy/pull/16311))
 * Avoid cyclic reference in nested functions (Jukka Lehtosalo, PR [16268](https://github.com/python/mypy/pull/16268))
 * Fix direct `__dict__` access on inner functions in new Python (Shantanu, PR [16084](https://github.com/python/mypy/pull/16084))
 * Make tuple packing and unpacking more efficient (Jukka Lehtosalo, PR [16022](https://github.com/python/mypy/pull/16022))

### Improvements to Error Reporting

 * Update starred expression error message to match CPython (Cibin Mathew, PR [16304](https://github.com/python/mypy/pull/16304))
 * Fix error code of "Maybe you forgot to use await" note (Jelle Zijlstra, PR [16203](https://github.com/python/mypy/pull/16203))
 * Use error code `[unsafe-overload]` for unsafe overloads, instead of `[misc]` (Randolf Scholz, PR [16061](https://github.com/python/mypy/pull/16061))
 * Reword the error message related to void functions (Albert Tugushev, PR [15876](https://github.com/python/mypy/pull/15876))
 * Represent bottom type as Never in messages (Shantanu, PR [15996](https://github.com/python/mypy/pull/15996))
 * Add hint for AsyncIterator incompatible return type (Ilya Priven, PR [15883](https://github.com/python/mypy/pull/15883))
 * Don't suggest stubs packages where the runtime package now ships with types (Alex Waygood, PR [16226](https://github.com/python/mypy/pull/16226))

### Performance Improvements

 * Speed up type argument checking (Jukka Lehtosalo, PR [16353](https://github.com/python/mypy/pull/16353))
 * Add fast path for checking self types (Jukka Lehtosalo, PR [16352](https://github.com/python/mypy/pull/16352))
 * Cache information about whether file is typeshed file (Jukka Lehtosalo, PR [16351](https://github.com/python/mypy/pull/16351))
 * Skip expensive `repr()` in logging call when not needed (Jukka Lehtosalo, PR [16350](https://github.com/python/mypy/pull/16350))

### Attrs and Dataclass Improvements

 * `dataclass.replace`: Allow transformed classes (Ilya Priven, PR [15915](https://github.com/python/mypy/pull/15915))
 * `dataclass.replace`: Fall through to typeshed signature (Ilya Priven, PR [15962](https://github.com/python/mypy/pull/15962))
 * Document `dataclass_transform` behavior (Ilya Priven, PR [16017](https://github.com/python/mypy/pull/16017))
 * `attrs`: Remove fields type check (Ilya Priven, PR [15983](https://github.com/python/mypy/pull/15983))
 * `attrs`, `dataclasses`: Don't enforce slots when base class doesn't (Ilya Priven, PR [15976](https://github.com/python/mypy/pull/15976))
 * Fix crash on dataclass field / property collision (Nikita Sobolev, PR [16147](https://github.com/python/mypy/pull/16147))

### Stubgen Improvements

 * Write stubs with utf-8 encoding (Jørgen Lind, PR [16329](https://github.com/python/mypy/pull/16329))
 * Fix missing property setter in semantic analysis mode (Ali Hamdan, PR [16303](https://github.com/python/mypy/pull/16303))
 * Unify C extension and pure python stub generators with object oriented design (Chad Dombrova, PR [15770](https://github.com/python/mypy/pull/15770))
 * Multiple fixes to the generated imports (Ali Hamdan, PR [15624](https://github.com/python/mypy/pull/15624))
 * Generate valid dataclass stubs (Ali Hamdan, PR [15625](https://github.com/python/mypy/pull/15625))

### Fixes to Crashes

 * Fix incremental mode crash on TypedDict in method (Ivan Levkivskyi, PR [16364](https://github.com/python/mypy/pull/16364))
 * Fix crash on star unpack in TypedDict (Ivan Levkivskyi, PR [16116](https://github.com/python/mypy/pull/16116))
 * Fix crash on malformed TypedDict in incremental mode (Ivan Levkivskyi, PR [16115](https://github.com/python/mypy/pull/16115))
 * Fix crash with report generation on namespace packages (Shantanu, PR [16019](https://github.com/python/mypy/pull/16019))
 * Fix crash when parsing error code config with typo (Shantanu, PR [16005](https://github.com/python/mypy/pull/16005))
 * Fix `__post_init__()` internal error (Ilya Priven, PR [16080](https://github.com/python/mypy/pull/16080))

### Documentation Updates

 * Make it easier to copy commands from README (Hamir Mahal, PR [16133](https://github.com/python/mypy/pull/16133))
 * Document and rename `[overload-overlap]` error code (Shantanu, PR [16074](https://github.com/python/mypy/pull/16074))
 * Document `--force-uppercase-builtins` and `--force-union-syntax` (Nikita Sobolev, PR [16049](https://github.com/python/mypy/pull/16049))
 * Document `force_union_syntax` and `force_uppercase_builtins` (Nikita Sobolev, PR [16048](https://github.com/python/mypy/pull/16048))
 * Document we're not tracking relationships between symbols (Ilya Priven, PR [16018](https://github.com/python/mypy/pull/16018))

### Other Notable Changes and Fixes

 * Propagate narrowed types to lambda expressions (Ivan Levkivskyi, PR [16407](https://github.com/python/mypy/pull/16407))
 * Avoid importing from `setuptools._distutils` (Shantanu, PR [16348](https://github.com/python/mypy/pull/16348))
 * Delete recursive aliases flags (Ivan Levkivskyi, PR [16346](https://github.com/python/mypy/pull/16346))
 * Properly use proper subtyping for callables (Ivan Levkivskyi, PR [16343](https://github.com/python/mypy/pull/16343))
 * Use upper bound as inference fallback more consistently (Ivan Levkivskyi, PR [16344](https://github.com/python/mypy/pull/16344))
 * Add `[unimported-reveal]` error code (Nikita Sobolev, PR [16271](https://github.com/python/mypy/pull/16271))
 * Add `|=` and `|` operators support for `TypedDict` (Nikita Sobolev, PR [16249](https://github.com/python/mypy/pull/16249))
 * Clarify variance convention for Parameters (Ivan Levkivskyi, PR [16302](https://github.com/python/mypy/pull/16302))
 * Correctly recognize `typing_extensions.NewType` (Ganden Schaffner, PR [16298](https://github.com/python/mypy/pull/16298))
 * Fix partially defined in the case of missing type maps (Shantanu, PR [15995](https://github.com/python/mypy/pull/15995))
 * Use SPDX license identifier (Nikita Sobolev, PR [16230](https://github.com/python/mypy/pull/16230))
 * Make `__qualname__` and `__module__` available in class bodies (Anthony Sottile, PR [16215](https://github.com/python/mypy/pull/16215))
 * stubtest: Hint when args in stub need to be keyword-only (Alex Waygood, PR [16210](https://github.com/python/mypy/pull/16210))
 * Tuple slice should not propagate fallback (Thomas Grainger, PR [16154](https://github.com/python/mypy/pull/16154))
 * Fix cases of type object handling for overloads (Shantanu, PR [16168](https://github.com/python/mypy/pull/16168))
 * Fix walrus interaction with empty collections (Ivan Levkivskyi, PR [16197](https://github.com/python/mypy/pull/16197))
 * Use type variable bound when it appears as actual during inference (Ivan Levkivskyi, PR [16178](https://github.com/python/mypy/pull/16178))
 * Use upper bounds as fallback solutions for inference (Ivan Levkivskyi, PR [16184](https://github.com/python/mypy/pull/16184))
 * Special-case type inference of empty collections (Ivan Levkivskyi, PR [16122](https://github.com/python/mypy/pull/16122))
 * Allow TypedDict unpacking in Callable types (Ivan Levkivskyi, PR [16083](https://github.com/python/mypy/pull/16083))
 * Fix inference for overloaded `__call__` with generic self (Shantanu, PR [16053](https://github.com/python/mypy/pull/16053))
 * Call dynamic class hook on generic classes (Petter Friberg, PR [16052](https://github.com/python/mypy/pull/16052))
 * Preserve implicitly exported types via attribute access (Shantanu, PR [16129](https://github.com/python/mypy/pull/16129))
 * Fix a stubtest bug (Alex Waygood)
 * Fix `tuple[Any, ...]` subtyping (Shantanu, PR [16108](https://github.com/python/mypy/pull/16108))
 * Lenient handling of trivial Callable suffixes (Ivan Levkivskyi, PR [15913](https://github.com/python/mypy/pull/15913))
 * Add `add_overloaded_method_to_class` helper for plugins (Nikita Sobolev, PR [16038](https://github.com/python/mypy/pull/16038))
 * Bundle `misc/proper_plugin.py` as a part of `mypy` (Nikita Sobolev, PR [16036](https://github.com/python/mypy/pull/16036))
 * Fix `case Any()` in match statement (DS/Charlie, PR [14479](https://github.com/python/mypy/pull/14479))
 * Make iterable logic more consistent (Shantanu, PR [16006](https://github.com/python/mypy/pull/16006))
 * Fix inference for properties with `__call__` (Shantanu, PR [15926](https://github.com/python/mypy/pull/15926))

### Typeshed Updates

Please see [git log](https://github.com/python/typeshed/commits/main?after=4a854366e03dee700109f8e758a08b2457ea2f51+0&branch=main&path=stdlib) for full list of standard library typeshed stub changes.

### Acknowledgements

Thanks to all mypy contributors who contributed to this release:

* Albert Tugushev
* Alex Waygood
* Ali Hamdan
* Anders Kaseorg
* Anthony Sottile
* Chad Dombrova
* Cibin Mathew
* dinaldoap
* DS/Charlie
* Eli Schwartz
* Ganden Schaffner
* Hamir Mahal
* Ihor
* Ikko Eltociear Ashimine
* Ilya Priven
* Ivan Levkivskyi
* Jelle Zijlstra
* Jukka Lehtosalo
* Jørgen Lind
* KotlinIsland
* Matt Bogosian
* Nikita Sobolev
* Petter Friberg
* Randolf Scholz
* Shantanu
* Thomas Grainger
* Valentin Stanciu

I’d also like to thank my employer, Dropbox, for supporting mypy development.

Posted by Jukka Lehtosalo

## Mypy 1.6

[Tuesday, 10 October 2023](https://mypy-lang.blogspot.com/2023/10/mypy-16-released.html)

We’ve just uploaded mypy 1.6 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Introduce Error Subcodes for Import Errors

Mypy now uses the error code import-untyped if an import targets an installed library that doesn’t support static type checking, and no stub files are available. Other invalid imports produce the import-not-found error code. They both are subcodes of the import error code, which was previously used for both kinds of import-related errors.

Use \--disable-error-code=import-untyped to only ignore import errors about installed libraries without stubs. This way mypy will still report errors about typos in import statements, for example.

If you use \--warn-unused-ignore or \--strict, mypy will complain if you use \# type: ignore\[import\] to ignore an import error. You are expected to use one of the more specific error codes instead. Otherwise, ignoring the import error code continues to silence both errors.

This feature was contributed by Shantanu (PR [15840](https://github.com/python/mypy/pull/15840), PR [14740](https://github.com/python/mypy/pull/14740)).

### Remove Support for Targeting Python 3.6 and Earlier

Running mypy with \--python-version 3.6, for example, is no longer supported. Python 3.6 hasn’t been properly supported by mypy for some time now, and this makes it explicit. This was contributed by Nikita Sobolev (PR [15668](https://github.com/python/mypy/pull/15668)).

### Selective Filtering of \--disallow-untyped-calls Targets

Using \--disallow-untyped-calls could be annoying when using libraries with missing type information, as mypy would generate many errors about code that uses the library. Now you can use \--untyped-calls-exclude=acme, for example, to disable these errors about calls targeting functions defined in the acme package. Refer to the [documentation](https://mypy.readthedocs.io/en/latest/command_line.html#cmdoption-mypy-untyped-calls-exclude) for more information.

This feature was contributed by Ivan Levkivskyi (PR [15845](https://github.com/python/mypy/pull/15845)).

### Improved Type Inference between Callable Types

Mypy now does a better job inferring type variables inside arguments of callable types. For example, this code fragment now type checks correctly:

```python
def f(c: Callable[[T, S], None]) -> Callable[[str, T, S], None]: ...
def g(*x: int) -> None: ...

reveal_type(f(g))  # Callable[[str, int, int], None]
```

This was contributed by Ivan Levkivskyi (PR [15910](https://github.com/python/mypy/pull/15910)).

### Don’t Consider None and TypeVar to Overlap in Overloads

Mypy now doesn’t consider an overload item with an argument type None to overlap with a type variable:

```python
@overload
def f(x: None) -> None: ..
@overload
def f(x: T) -> Foo[T]: ...
...
```

Previously mypy would generate an error about the definition of f above. This is slightly unsafe if the upper bound of T is object, since the value of the type variable could be None. We relaxed the rules a little, since this solves a common issue.

This feature was contributed by Ivan Levkivskyi (PR [15846](https://github.com/python/mypy/pull/15846)).

### Improvements to \--new-type-inference

The experimental new type inference algorithm (polymorphic inference) introduced as an opt-in feature in mypy 1.5 has several improvements:

*   Improve transitive closure computation during constraint solving (Ivan Levkivskyi, PR [15754](https://github.com/python/mypy/pull/15754))
*   Add support for upper bounds and values with \--new-type-inference (Ivan Levkivskyi, PR [15813](https://github.com/python/mypy/pull/15813))
*   Basic support for variadic types with \--new-type-inference (Ivan Levkivskyi, PR [15879](https://github.com/python/mypy/pull/15879))
*   Polymorphic inference: support for parameter specifications and lambdas (Ivan Levkivskyi, PR [15837](https://github.com/python/mypy/pull/15837))
*   Invalidate cache when adding \--new-type-inference (Marc Mueller, PR [16059](https://github.com/python/mypy/pull/16059))

**Note:** We are planning to enable \--new-type-inference by default in mypy 1.7. Please try this out and let us know if you encounter any issues.

### ParamSpec Improvements

*   Support self-types containing ParamSpec (Ivan Levkivskyi, PR [15903](https://github.com/python/mypy/pull/15903))
*   Allow “…” in Concatenate, and clean up ParamSpec literals (Ivan Levkivskyi, PR [15905](https://github.com/python/mypy/pull/15905))
*   Fix ParamSpec inference for callback protocols (Ivan Levkivskyi, PR [15986](https://github.com/python/mypy/pull/15986))
*   Infer ParamSpec constraint from arguments (Ivan Levkivskyi, PR [15896](https://github.com/python/mypy/pull/15896))
*   Fix crash on invalid type variable with ParamSpec (Ivan Levkivskyi, PR [15953](https://github.com/python/mypy/pull/15953))
*   Fix subtyping between ParamSpecs (Ivan Levkivskyi, PR [15892](https://github.com/python/mypy/pull/15892))

### Stubgen Improvements

*   Add option to include docstrings with stubgen (chylek, PR [13284](https://github.com/python/mypy/pull/13284))
*   Add required ... initializer to NamedTuple fields with default values (Nikita Sobolev, PR [15680](https://github.com/python/mypy/pull/15680))

### Stubtest Improvements

*   Fix \_\_mypy-replace false positives (Alex Waygood, PR [15689](https://github.com/python/mypy/pull/15689))
*   Fix edge case for bytes enum subclasses (Alex Waygood, PR [15943](https://github.com/python/mypy/pull/15943))
*   Generate error if typeshed is missing modules from the stdlib (Alex Waygood, PR [15729](https://github.com/python/mypy/pull/15729))
*   Fixes to new check for missing stdlib modules (Alex Waygood, PR [15960](https://github.com/python/mypy/pull/15960))
*   Fix stubtest enum.Flag edge case (Alex Waygood, PR [15933](https://github.com/python/mypy/pull/15933))

### Documentation Improvements

*   Do not advertise to create your own assert\_never helper (Nikita Sobolev, PR [15947](https://github.com/python/mypy/pull/15947))
*   Fix all the missing references found within the docs (Albert Tugushev, PR [15875](https://github.com/python/mypy/pull/15875))
*   Document await-not-async error code (Shantanu, PR [15858](https://github.com/python/mypy/pull/15858))
*   Improve documentation of disabling error codes (Shantanu, PR [15841](https://github.com/python/mypy/pull/15841))

### Other Notable Changes and Fixes

*   Make unsupported PEP 695 features (introduced in Python 3.12) give a reasonable error message (Shantanu, PR [16013](https://github.com/python/mypy/pull/16013))
*   Remove the \--py2 command-line argument (Marc Mueller, PR [15670](https://github.com/python/mypy/pull/15670))
*   Change empty tuple from tuple\[\] to tuple\[()\] in error messages (Nikita Sobolev, PR [15783](https://github.com/python/mypy/pull/15783))
*   Fix assert\_type failures when some nodes are deferred (Nikita Sobolev, PR [15920](https://github.com/python/mypy/pull/15920))
*   Generate error on unbound TypeVar with values (Nikita Sobolev, PR [15732](https://github.com/python/mypy/pull/15732))
*   Fix over-eager types-google-cloud-ndb suggestion (Shantanu, PR [15347](https://github.com/python/mypy/pull/15347))
*   Fix type narrowing of \== None and in (None,) conditions (Marti Raudsepp, PR [15760](https://github.com/python/mypy/pull/15760))
*   Fix inference for attrs.fields (Shantanu, PR [15688](https://github.com/python/mypy/pull/15688))
*   Make “await in non-async function” a non-blocking error and give it an error code (Gregory Santosa, PR [15384](https://github.com/python/mypy/pull/15384))
*   Add basic support for decorated overloads (Ivan Levkivskyi, PR [15898](https://github.com/python/mypy/pull/15898))
*   Fix TypeVar regression with self types (Ivan Levkivskyi, PR [15945](https://github.com/python/mypy/pull/15945))
*   Add \_\_match\_args\_\_ to dataclasses with no fields (Ali Hamdan, PR [15749](https://github.com/python/mypy/pull/15749))
*   Include stdout and stderr in dmypy verbose output (Valentin Stanciu, PR [15881](https://github.com/python/mypy/pull/15881))
*   Improve match narrowing and reachability analysis (Shantanu, PR [15882](https://github.com/python/mypy/pull/15882))
*   Support \_\_bool\_\_ with Literal in \--warn-unreachable (Jannic Warken, PR [15645](https://github.com/python/mypy/pull/15645))
*   Fix inheriting from generic @frozen attrs class (Ilya Priven, PR [15700](https://github.com/python/mypy/pull/15700))
*   Correctly narrow types for tuple\[type\[X\], ...\] (Nikita Sobolev, PR [15691](https://github.com/python/mypy/pull/15691))
*   Don't flag intentionally empty generators unreachable (Ilya Priven, PR [15722](https://github.com/python/mypy/pull/15722))
*   Add tox.ini to mypy sdist (Marcel Telka, PR [15853](https://github.com/python/mypy/pull/15853))
*   Fix mypyc regression with pretty (Shantanu, PR [16124](https://github.com/python/mypy/pull/16124))

### Typeshed Updates

Typeshed is now modular and distributed as separate PyPI packages for everything except the standard library stubs. Please see [git log](https://github.com/python/typeshed/commits/main?after=6a8d653a671925b0a3af61729ff8cf3f90c9c662+0&branch=main&path=stdlib) for full list of typeshed changes.

### Acknowledgements

Thanks to Max Murin, who did most of the release manager work for this release (I just did the final steps).

Thanks to all mypy contributors who contributed to this release:

*   Albert Tugushev
*   Alex Waygood
*   Ali Hamdan
*   chylek
*   EXPLOSION
*   Gregory Santosa
*   Ilya Priven
*   Ivan Levkivskyi
*   Jannic Warken
*   KotlinIsland
*   Marc Mueller
*   Marcel Johannesmann
*   Marcel Telka
*   Mark Byrne
*   Marti Raudsepp
*   Max Murin
*   Nikita Sobolev
*   Shantanu
*   Valentin Stanciu

Posted by Jukka Lehtosalo


## Mypy 1.5

[Thursday, 10 August 2023](https://mypy-lang.blogspot.com/2023/08/mypy-15-released.html)

We’ve just uploaded mypy 1.5 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, deprecations and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Drop Support for Python 3.7

Mypy no longer supports running with Python 3.7, which has reached end-of-life. This was contributed by Shantanu (PR [15566](https://github.com/python/mypy/pull/15566)).

### Optional Check to Require Explicit @override

If you enable the explicit-override error code, mypy will generate an error if a method override doesn’t use the @typing.override decorator (as discussed in [PEP 698](https://peps.python.org/pep-0698/#strict-enforcement-per-project)). This way mypy will detect accidentally introduced overrides. Example:

```python
# mypy: enable-error-code="explicit-override"

from typing_extensions import override

class C:
    def foo(self) -> None: pass
    def bar(self) -> None: pass

class D(C):
    # Error: Method "foo" is not using @override but is
    # overriding a method
    def foo(self) -> None:
        ...

    @override
    def bar(self) -> None:  # OK
        ...
```

You can enable the error code via \--enable-error-code=explicit-override on the mypy command line or enable\_error\_code = explicit-override in the mypy config file.

The override decorator will be available in typing in Python 3.12, but you can also use the backport from a recent version of `typing_extensions` on all supported Python versions.

This feature was contributed by Marc Mueller(PR [15512](https://github.com/python/mypy/pull/15512)).

### More Flexible TypedDict Creation and Update

Mypy was previously overly strict when type checking TypedDict creation and update operations. Though these checks were often technically correct, they sometimes triggered for apparently valid code. These checks have now been relaxed by default. You can enable stricter checking by using the new \--extra-checks flag.

Construction using the `**` syntax is now more flexible:

```python
from typing import TypedDict

class A(TypedDict):
    foo: int
    bar: int

class B(TypedDict):
    foo: int

a: A = {"foo": 1, "bar": 2}
b: B = {"foo": 3}
a2: A = { **a, **b}  # OK (previously an error)
```

You can also call update() with a TypedDict argument that contains a subset of the keys in the updated TypedDict:
```python
a.update(b)  # OK (previously an error)
```

This feature was contributed by Ivan Levkivskyi (PR [15425](https://github.com/python/mypy/pull/15425)).

### Deprecated Flag: \--strict-concatenate

The behavior of \--strict-concatenate is now included in the new \--extra-checks flag, and the old flag is deprecated.

### Optionally Show Links to Error Code Documentation

If you use \--show-error-code-links, mypy will add documentation links to (many) reported errors. The links are not shown for error messages that are sufficiently obvious, and they are shown once per error code only.

Example output:
```
a.py:1: error: Need type annotation for "foo" (hint: "x: List[<type>] = ...")  [var-annotated]
a.py:1: note: See https://mypy.rtfd.io/en/stable/_refs.html#code-var-annotated for more info
```
This was contributed by Ivan Levkivskyi (PR [15449](https://github.com/python/mypy/pull/15449)).

### Consistently Avoid Type Checking Unreachable Code

If a module top level has unreachable code, mypy won’t type check the unreachable statements. This is consistent with how functions behave. The behavior of \--warn-unreachable is also more consistent now.

This was contributed by Ilya Priven (PR [15386](https://github.com/python/mypy/pull/15386)).

### Experimental Improved Type Inference for Generic Functions

You can use \--new-type-inference to opt into an experimental new type inference algorithm. It fixes issues when calling a generic functions with an argument that is also a generic function, in particular. This current implementation is still incomplete, but we encourage trying it out and reporting bugs if you encounter regressions. We are planning to enable the new algorithm by default in a future mypy release.

This feature was contributed by Ivan Levkivskyi (PR [15287](https://github.com/python/mypy/pull/15287)).

### Partial Support for Python 3.12

Mypy and mypyc now support running on recent Python 3.12 development versions. Not all new Python 3.12 features are supported, and we don’t ship compiled wheels for Python 3.12 yet.

*   Fix ast warnings for Python 3.12 (Nikita Sobolev, PR [15558](https://github.com/python/mypy/pull/15558))
*   mypyc: Fix multiple inheritance with a protocol on Python 3.12 (Jukka Lehtosalo, PR [15572](https://github.com/python/mypy/pull/15572))
*   mypyc: Fix self-compilation on Python 3.12 (Jukka Lehtosalo, PR [15582](https://github.com/python/mypy/pull/15582))
*   mypyc: Fix 3.12 issue with pickling of instances with \_\_dict\_\_ (Jukka Lehtosalo, PR [15574](https://github.com/python/mypy/pull/15574))
*   mypyc: Fix i16 on Python 3.12 (Jukka Lehtosalo, PR [15510](https://github.com/python/mypy/pull/15510))
*   mypyc: Fix int operations on Python 3.12 (Jukka Lehtosalo, PR [15470](https://github.com/python/mypy/pull/15470))
*   mypyc: Fix generators on Python 3.12 (Jukka Lehtosalo, PR [15472](https://github.com/python/mypy/pull/15472))
*   mypyc: Fix classes with \_\_dict\_\_ on 3.12 (Jukka Lehtosalo, PR [15471](https://github.com/python/mypy/pull/15471))
*   mypyc: Fix coroutines on Python 3.12 (Jukka Lehtosalo, PR [15469](https://github.com/python/mypy/pull/15469))
*   mypyc: Don't use \_PyErr\_ChainExceptions on 3.12, since it's deprecated (Jukka Lehtosalo, PR [15468](https://github.com/python/mypy/pull/15468))
*   mypyc: Add Python 3.12 feature macro (Jukka Lehtosalo, PR [15465](https://github.com/python/mypy/pull/15465))

### Improvements to Dataclasses

*   Improve signature of dataclasses.replace (Ilya Priven, PR [14849](https://github.com/python/mypy/pull/14849))
*   Fix dataclass/protocol crash on joining types (Ilya Priven, PR [15629](https://github.com/python/mypy/pull/15629))
*   Fix strict optional handling in dataclasses (Ivan Levkivskyi, PR [15571](https://github.com/python/mypy/pull/15571))
*   Support optional types for custom dataclass descriptors (Marc Mueller, PR [15628](https://github.com/python/mypy/pull/15628))
*   Add `__slots__` attribute to dataclasses (Nikita Sobolev, PR [15649](https://github.com/python/mypy/pull/15649))
*   Support better \_\_post\_init\_\_ method signature for dataclasses (Nikita Sobolev, PR [15503](https://github.com/python/mypy/pull/15503))

### Mypyc Improvements

*   Support unsigned 8-bit native integer type: mypy\_extensions.u8 (Jukka Lehtosalo, PR [15564](https://github.com/python/mypy/pull/15564))
*   Support signed 16-bit native integer type: mypy\_extensions.i16 (Jukka Lehtosalo, PR [15464](https://github.com/python/mypy/pull/15464))
*   Define mypy\_extensions.i16 in stubs (Jukka Lehtosalo, PR [15562](https://github.com/python/mypy/pull/15562))
*   Document more unsupported features and update supported features (Richard Si, PR [15524](https://github.com/python/mypy/pull/15524))
*   Fix final NamedTuple classes (Richard Si, PR [15513](https://github.com/python/mypy/pull/15513))
*   Use C99 compound literals for undefined tuple values (Jukka Lehtosalo, PR [15453](https://github.com/python/mypy/pull/15453))
*   Don't explicitly assign NULL values in setup functions (Logan Hunt, PR [15379](https://github.com/python/mypy/pull/15379))

### Stubgen Improvements

*   Teach stubgen to work with complex and unary expressions (Nikita Sobolev, PR [15661](https://github.com/python/mypy/pull/15661))
*   Support ParamSpec and TypeVarTuple (Ali Hamdan, PR [15626](https://github.com/python/mypy/pull/15626))
*   Fix crash on non-str docstring (Ali Hamdan, PR [15623](https://github.com/python/mypy/pull/15623))

### Documentation Updates

*   Add documentation for additional error codes (Ivan Levkivskyi, PR [15539](https://github.com/python/mypy/pull/15539))
*   Improve documentation of type narrowing (Ilya Priven, PR [15652](https://github.com/python/mypy/pull/15652))
*   Small improvements to protocol documentation (Shantanu, PR [15460](https://github.com/python/mypy/pull/15460))
*   Remove confusing instance variable example in cheat sheet (Adel Atallah, PR [15441](https://github.com/python/mypy/pull/15441))

### Other Notable Fixes and Improvements

*   Constant fold additional unary and binary expressions (Richard Si, PR [15202](https://github.com/python/mypy/pull/15202))
*   Exclude the same special attributes from Protocol as CPython (Kyle Benesch, PR [15490](https://github.com/python/mypy/pull/15490))
*   Change the default value of the slots argument of attrs.define to True, to match runtime behavior (Ilya Priven, PR [15642](https://github.com/python/mypy/pull/15642))
*   Fix type of class attribute if attribute is defined in both class and metaclass (Alex Waygood, PR [14988](https://github.com/python/mypy/pull/14988))
*   Handle type the same as typing.Type in the first argument of classmethods (Erik Kemperman, PR [15297](https://github.com/python/mypy/pull/15297))
*   Fix \--find-occurrences flag (Shantanu, PR [15528](https://github.com/python/mypy/pull/15528))
*   Fix error location for class patterns (Nikita Sobolev, PR [15506](https://github.com/python/mypy/pull/15506))
*   Fix re-added file with errors in mypy daemon (Ivan Levkivskyi, PR [15440](https://github.com/python/mypy/pull/15440))
*   Fix dmypy run on Windows (Ivan Levkivskyi, PR [15429](https://github.com/python/mypy/pull/15429))
*   Fix abstract and non-abstract variant error for property deleter (Shantanu, PR [15395](https://github.com/python/mypy/pull/15395))
*   Remove special casing for "cannot" in error messages (Ilya Priven, PR [15428](https://github.com/python/mypy/pull/15428))
*   Add runtime `__slots__` attribute to attrs classes (Nikita Sobolev, PR [15651](https://github.com/python/mypy/pull/15651))
*   Add get\_expression\_type to CheckerPluginInterface (Ilya Priven, PR [15369](https://github.com/python/mypy/pull/15369))
*   Remove parameters that no longer exist from NamedTuple.\_make() (Alex Waygood, PR [15578](https://github.com/python/mypy/pull/15578))
*   Allow using typing.Self in `__all__` with an explicit @staticmethod decorator (Erik Kemperman, PR [15353](https://github.com/python/mypy/pull/15353))
*   Fix self types in subclass methods without Self annotation (Ivan Levkivskyi, PR [15541](https://github.com/python/mypy/pull/15541))
*   Check for abstract class objects in tuples (Nikita Sobolev, PR [15366](https://github.com/python/mypy/pull/15366))

### Typeshed Updates

Typeshed is now modular and distributed as separate PyPI packages for everything except the standard library stubs. Please see [git log](https://github.com/python/typeshed/commits/main?after=fc7d4722eaa54803926cee5730e1f784979c0531+0&branch=main&path=stdlib) for full list of typeshed changes.

### Acknowledgements

Thanks to all mypy contributors who contributed to this release:

*   Adel Atallah
*   Alex Waygood
*   Ali Hamdan
*   Erik Kemperman
*   Federico Padua
*   Ilya Priven
*   Ivan Levkivskyi
*   Jelle Zijlstra
*   Jared Hance
*   Jukka Lehtosalo
*   Kyle Benesch
*   Logan Hunt
*   Marc Mueller
*   Nikita Sobolev
*   Richard Si
*   Shantanu
*   Stavros Ntentos
*   Valentin Stanciu

Posted by Valentin Stanciu


## Mypy 1.4

[Tuesday, 20 June 2023](https://mypy-lang.blogspot.com/2023/06/mypy-140-released.html)

We’ve just uploaded mypy 1.4 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### The Override Decorator

Mypy can now ensure that when renaming a method, overrides are also renamed. You can explicitly mark a method as overriding a base class method by using the @typing.override decorator ([PEP 698](https://peps.python.org/pep-0698/)). If the method is then renamed in the base class while the method override is not, mypy will generate an error. The decorator will be available in typing in Python 3.12, but you can also use the backport from a recent version of `typing_extensions` on all supported Python versions.

This feature was contributed byThomas M Kehrenberg (PR [14609](https://github.com/python/mypy/pull/14609)).

### Propagating Type Narrowing to Nested Functions

Previously, type narrowing was not propagated to nested functions because it would not be sound if the narrowed variable changed between the definition of the nested function and the call site. Mypy will now propagate the narrowed type if the variable is not assigned to after the definition of the nested function:

```python
def outer(x: str | None = None) -> None:
    if x is None:
        x = calculate_default()
    reveal_type(x)  # "str" (narrowed)

    def nested() -> None:
        reveal_type(x)  # Now "str" (used to be "str | None")

    nested()
```

This may generate some new errors because asserts that were previously necessary may become tautological or no-ops.

This was contributed by Jukka Lehtosalo (PR [15133](https://github.com/python/mypy/pull/15133)).

### Narrowing Enum Values Using “==”

Mypy now allows narrowing enum types using the \== operator. Previously this was only supported when using the is operator. This makes exhaustiveness checking with enum types more usable, as the requirement to use the is operator was not very intuitive. In this example mypy can detect that the developer forgot to handle the value MyEnum.C in example

```python
from enum import Enum

class MyEnum(Enum):
    A = 0
    B = 1
    C = 2

def example(e: MyEnum) -> str:  # Error: Missing return statement
    if e == MyEnum.A:
        return 'x'
    elif e == MyEnum.B:
        return 'y'
```

Adding an extra elif case resolves the error:

```python
...
def example(e: MyEnum) -> str:  # No error -- all values covered
    if e == MyEnum.A:
        return 'x'
    elif e == MyEnum.B:
        return 'y'
    elif e == MyEnum.C:
        return 'z'
```

This change can cause false positives in test cases that have assert statements like assert o.x == SomeEnum.X when using \--strict-equality. Example:

```python
# mypy: strict-equality

from enum import Enum

class MyEnum(Enum):
    A = 0
    B = 1

class C:
    x: MyEnum
    ...

def test_something() -> None:
    c = C(...)
    assert c.x == MyEnum.A
    c.do_something_that_changes_x()
    assert c.x == MyEnum.B  # Error: Non-overlapping equality check
```

These errors can be ignored using \# type: ignore\[comparison-overlap\], or you can perform the assertion using a temporary variable as a workaround:

```python
...
def test_something() -> None:
    ...
    x = c.x
    assert x == MyEnum.A  # Does not narrow c.x
    c.do_something_that_changes_x()
    x = c.x
    assert x == MyEnum.B  # OK
```

This feature was contributed by Shantanu (PR [11521](https://github.com/python/mypy/pull/11521)).

### Performance Improvements

*   Speed up simplification of large union types and also fix a recursive tuple crash (Shantanu, PR [15128](https://github.com/python/mypy/pull/15128))
*   Speed up union subtyping (Shantanu, PR [15104](https://github.com/python/mypy/pull/15104))
*   Don't type check most function bodies when type checking third-party library code, or generally when ignoring errors (Jukka Lehtosalo, PR [14150](https://github.com/python/mypy/pull/14150))

### Improvements to Plugins

*   attrs.evolve: Support generics and unions (Ilya Konstantinov, PR [15050](https://github.com/python/mypy/pull/15050))
*   Fix ctypes plugin (Alex Waygood)

### Fixes to Crashes

*   Fix a crash when function-scope recursive alias appears as upper bound (Ivan Levkivskyi, PR [15159](https://github.com/python/mypy/pull/15159))
*   Fix crash on follow\_imports\_for\_stubs (Ivan Levkivskyi, PR [15407](https://github.com/python/mypy/pull/15407))
*   Fix stubtest crash in explicit init subclass (Shantanu, PR [15399](https://github.com/python/mypy/pull/15399))
*   Fix crash when indexing TypedDict with empty key (Shantanu, PR [15392](https://github.com/python/mypy/pull/15392))
*   Fix crash on NamedTuple as attribute (Ivan Levkivskyi, PR [15404](https://github.com/python/mypy/pull/15404))
*   Correctly track loop depth for nested functions/classes (Ivan Levkivskyi, PR [15403](https://github.com/python/mypy/pull/15403))
*   Fix crash on joins with recursive tuples (Ivan Levkivskyi, PR [15402](https://github.com/python/mypy/pull/15402))
*   Fix crash with custom ErrorCode subclasses (Marc Mueller, PR [15327](https://github.com/python/mypy/pull/15327))
*   Fix crash in dataclass protocol with self attribute assignment (Ivan Levkivskyi, PR [15157](https://github.com/python/mypy/pull/15157))
*   Fix crash on lambda in generic context with generic method in body (Ivan Levkivskyi, PR [15155](https://github.com/python/mypy/pull/15155))
*   Fix recursive type alias crash in make\_simplified\_union (Ivan Levkivskyi, PR [15216](https://github.com/python/mypy/pull/15216))

### Improvements to Error Messages

*   Use lower-case built-in collection types such as list\[…\] instead of List\[…\] in errors when targeting Python 3.9+ (Max Murin, PR [15070](https://github.com/python/mypy/pull/15070))
*   Use X | Y union syntax in error messages when targeting Python 3.10+ (Omar Silva, PR [15102](https://github.com/python/mypy/pull/15102))
*   Use type instead of Type in errors when targeting Python 3.9+ (Rohit Sanjay, PR [15139](https://github.com/python/mypy/pull/15139))
*   Do not show unused-ignore errors in unreachable code, and make it a real error code (Ivan Levkivskyi, PR [15164](https://github.com/python/mypy/pull/15164))
*   Don’t limit the number of errors shown by default (Rohit Sanjay, PR [15138](https://github.com/python/mypy/pull/15138))
*   Improver message for truthy functions (madt2709, PR [15193](https://github.com/python/mypy/pull/15193))
*   Output distinct types when type names are ambiguous (teresa0605, PR [15184](https://github.com/python/mypy/pull/15184))
*   Update message about invalid exception type in try (AJ Rasmussen, PR [15131](https://github.com/python/mypy/pull/15131))
*   Add explanation if argument type is incompatible because of an unsupported numbers type (Jukka Lehtosalo, PR [15137](https://github.com/python/mypy/pull/15137))
*   Add more detail to 'signature incompatible with supertype' messages for non-callables (Ilya Priven, PR [15263](https://github.com/python/mypy/pull/15263))

### Documentation Updates

*   Add \--local-partial-types note to dmypy docs (Alan Du, PR [15259](https://github.com/python/mypy/pull/15259))
*   Update getting started docs for mypyc for Windows (Valentin Stanciu, PR [15233](https://github.com/python/mypy/pull/15233))
*   Clarify usage of callables regarding type object in docs (Viicos, PR [15079](https://github.com/python/mypy/pull/15079))
*   Clarify difference between disallow\_untyped\_defs and disallow\_incomplete\_defs (Ilya Priven, PR [15247](https://github.com/python/mypy/pull/15247))
*   Use attrs and @attrs.define in documentation and tests (Ilya Priven, PR [15152](https://github.com/python/mypy/pull/15152))

### Mypyc Improvements

*   Fix unexpected TypeError for certain variables with an inferred optional type (Richard Si, PR [15206](https://github.com/python/mypy/pull/15206))
*   Inline math literals (Logan Hunt, PR [15324](https://github.com/python/mypy/pull/15324))
*   Support unpacking mappings in dict display (Richard Si, PR [15203](https://github.com/python/mypy/pull/15203))

### Changes to Stubgen

*   Do not remove Generic from base classes (Ali Hamdan, PR [15316](https://github.com/python/mypy/pull/15316))
*   Support yield from statements (Ali Hamdan, PR [15271](https://github.com/python/mypy/pull/15271))
*   Fix missing total from TypedDict class (Ali Hamdan, PR [15208](https://github.com/python/mypy/pull/15208))
*   Fix call-based namedtuple omitted from class bases (Ali Hamdan, PR [14680](https://github.com/python/mypy/pull/14680))
*   Support TypedDict alternative syntax (Ali Hamdan, PR [14682](https://github.com/python/mypy/pull/14682))
*   Make stubgen respect MYPY\_CACHE\_DIR (Henrik Bäärnhielm, PR [14722](https://github.com/python/mypy/pull/14722))
*   Fixes and simplifications (Ali Hamdan, PR [15232](https://github.com/python/mypy/pull/15232))

### Other Notable Fixes and Improvements

*   Fix nested async functions when using TypeVar value restriction (Jukka Lehtosalo, PR [14705](https://github.com/python/mypy/pull/14705))
*   Always allow returning Any from lambda (Ivan Levkivskyi, PR [15413](https://github.com/python/mypy/pull/15413))
*   Add foundation for TypeVar defaults (PEP 696) (Marc Mueller, PR [14872](https://github.com/python/mypy/pull/14872))
*   Update semantic analyzer for TypeVar defaults (PEP 696) (Marc Mueller, PR [14873](https://github.com/python/mypy/pull/14873))
*   Make dict expression inference more consistent (Ivan Levkivskyi, PR [15174](https://github.com/python/mypy/pull/15174))
*   Do not block on duplicate base classes (Nikita Sobolev, PR [15367](https://github.com/python/mypy/pull/15367))
*   Generate an error when both staticmethod and classmethod decorators are used (Juhi Chandalia, PR [15118](https://github.com/python/mypy/pull/15118))
*   Fix assert\_type behaviour with literals (Carl Karsten, PR [15123](https://github.com/python/mypy/pull/15123))
*   Fix match subject ignoring redefinitions (Vincent Vanlaer, PR [15306](https://github.com/python/mypy/pull/15306))
*   Support `__all__`.remove (Shantanu, PR [15279](https://github.com/python/mypy/pull/15279))

### Typeshed Updates

Typeshed is now modular and distributed as separate PyPI packages for everything except the standard library stubs. Please see [git log](https://github.com/python/typeshed/commits/main?after=877e06ad1cfd9fd9967c0b0340a86d0c23ea89ce+0&branch=main&path=stdlib) for full list of typeshed changes.

### Acknowledgements

Thanks to all mypy contributors who contributed to this release:

*   Adrian Garcia Badaracco
*   AJ Rasmussen
*   Alan Du
*   Alex Waygood
*   Ali Hamdan
*   Carl Karsten
*   dosisod
*   Ethan Smith
*   Gregory Santosa
*   Heather White
*   Henrik Bäärnhielm
*   Ilya Konstantinov
*   Ilya Priven
*   Ivan Levkivskyi
*   Juhi Chandalia
*   Jukka Lehtosalo
*   Logan Hunt
*   madt2709
*   Marc Mueller
*   Max Murin
*   Nikita Sobolev
*   Omar Silva
*   Özgür
*   Richard Si
*   Rohit Sanjay
*   Shantanu
*   teresa0605
*   Thomas M Kehrenberg
*   Tin Tvrtković
*   Tushar Sadhwani
*   Valentin Stanciu
*   Viicos
*   Vincent Vanlaer
*   Wesley Collin Wright
*   William Santosa
*   yaegassy

I’d also like to thank my employer, Dropbox, for supporting mypy development.

Posted by Jared Hance


## Mypy 1.3

[Wednesday, 10 May 2023](https://mypy-lang.blogspot.com/2023/05/mypy-13-released.html)

 We’ve just uploaded mypy 1.3 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Performance Improvements

*   Improve performance of union subtyping (Shantanu, PR [15104](https://github.com/python/mypy/pull/15104))
*   Add negative subtype caches (Ivan Levkivskyi, PR [14884](https://github.com/python/mypy/pull/14884))

### Stub Tooling Improvements

*   Stubtest: Check that the stub is abstract if the runtime is, even when the stub is an overloaded method (Alex Waygood, PR [14955](https://github.com/python/mypy/pull/14955))
*   Stubtest: Verify stub methods or properties are decorated with @final if they are decorated with @final at runtime (Alex Waygood, PR [14951](https://github.com/python/mypy/pull/14951))
*   Stubtest: Fix stubtest false positives with TypedDicts at runtime (Alex Waygood, PR [14984](https://github.com/python/mypy/pull/14984))
*   Stubgen: Support @functools.cached\_property (Nikita Sobolev, PR [14981](https://github.com/python/mypy/pull/14981))
*   Improvements to stubgenc (Chad Dombrova, PR [14564](https://github.com/python/mypy/pull/14564))

### Improvements to attrs

*   Add support for converters with TypeVars on generic attrs classes (Chad Dombrova, PR [14908](https://github.com/python/mypy/pull/14908))
*   Fix attrs.evolve on bound TypeVar (Ilya Konstantinov, PR [15022](https://github.com/python/mypy/pull/15022))

### Documentation Updates

*   Improve async documentation (Shantanu, PR [14973](https://github.com/python/mypy/pull/14973))
*   Improvements to cheat sheet (Shantanu, PR [14972](https://github.com/python/mypy/pull/14972))
*   Add documentation for bytes formatting error code (Shantanu, PR [14971](https://github.com/python/mypy/pull/14971))
*   Convert insecure links to use HTTPS (Marti Raudsepp, PR [14974](https://github.com/python/mypy/pull/14974))
*   Also mention overloads in async iterator documentation (Shantanu, PR [14998](https://github.com/python/mypy/pull/14998))
*   stubtest: Improve allowlist documentation (Shantanu, PR [15008](https://github.com/python/mypy/pull/15008))
*   Clarify "Using types... but not at runtime" (Jon Shea, PR [15029](https://github.com/python/mypy/pull/15029))
*   Fix alignment of cheat sheet example (Ondřej Cvacho, PR [15039](https://github.com/python/mypy/pull/15039))
*   Fix error for callback protocol matching against callable type object (Shantanu, PR [15042](https://github.com/python/mypy/pull/15042))

### Error Reporting Improvements

*   Improve bytes formatting error (Shantanu, PR [14959](https://github.com/python/mypy/pull/14959))

### Mypyc Improvements

*   Fix unions of bools and ints (Tomer Chachamu, PR [15066](https://github.com/python/mypy/pull/15066))

### Other Fixes and Improvements

*   Fix narrowing union types that include Self with isinstance (Christoph Tyralla, PR [14923](https://github.com/python/mypy/pull/14923))
*   Allow objects matching SupportsKeysAndGetItem to be unpacked (Bryan Forbes, PR [14990](https://github.com/python/mypy/pull/14990))
*   Check type guard validity for staticmethods (EXPLOSION, PR [14953](https://github.com/python/mypy/pull/14953))
*   Fix sys.platform when cross-compiling with emscripten (Ethan Smith, PR [14888](https://github.com/python/mypy/pull/14888))

### Typeshed Updates

Typeshed is now modular and distributed as separate PyPI packages for everything except the standard library stubs. Please see [git log](https://github.com/python/typeshed/commits/main?after=b0ed50e9392a23e52445b630a808153e0e256976+0&branch=main&path=stdlib) for full list of typeshed changes.

### Acknowledgements

Thanks to all mypy contributors who contributed to this release:

*   Alex Waygood
*   Amin Alaee
*   Bryan Forbes
*   Chad Dombrova
*   Charlie Denton
*   Christoph Tyralla
*   dosisod
*   Ethan Smith
*   EXPLOSION
*   Ilya Konstantinov
*   Ivan Levkivskyi
*   Jon Shea
*   Jukka Lehtosalo
*   KotlinIsland
*   Marti Raudsepp
*   Nikita Sobolev
*   Ondřej Cvacho
*   Shantanu
*   sobolevn
*   Tomer Chachamu
*   Yaroslav Halchenko

Posted by Wesley Collin Wright.


## Mypy 1.2

[Thursday, 6 April 2023](https://mypy-lang.blogspot.com/2023/04/mypy-12-released.html)

We’ve just uploaded mypy 1.2 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Improvements to Dataclass Transforms

*   Support implicit default for "init" parameter in field specifiers (Wesley Collin Wright and Jukka Lehtosalo, PR [15010](https://github.com/python/mypy/pull/15010))
*   Support descriptors in dataclass transform (Jukka Lehtosalo, PR [15006](https://github.com/python/mypy/pull/15006))
*   Fix frozen\_default in incremental mode (Wesley Collin Wright)
*   Fix frozen behavior for base classes with direct metaclasses (Wesley Collin Wright, PR [14878](https://github.com/python/mypy/pull/14878))

### Mypyc: Native Floats

Mypyc now uses a native, unboxed representation for values of type float. Previously these were heap-allocated Python objects. Native floats are faster and use less memory. Code that uses floating-point operations heavily can be several times faster when using native floats.

Various float operations and math functions also now have optimized implementations. Refer to the [documentation](https://mypyc.readthedocs.io/en/latest/float_operations.html) for a full list.

This can change the behavior of existing code that uses subclasses of float. When assigning an instance of a subclass of float to a variable with the float type, it gets implicitly converted to a float instance when compiled:

```python
from lib import MyFloat  # MyFloat ia a subclass of "float"

def example() -> None:
    x = MyFloat(1.5)
    y: float = x  # Implicit conversion from MyFloat to float
    print(type(y))  # float, not MyFloat
```

Previously, implicit conversions were applied to int subclasses but not float subclasses.

Also, int values can no longer be assigned to a variable with type float in compiled code, since these types now have incompatible representations. An explicit conversion is required:

```python
def example(n: int) -> None:
    a: float = 1  # Error: cannot assign "int" to "float"
    b: float = 1.0  # OK
    c: float = n  # Error
    d: float = float(n)  # OK
```

This restriction only applies to assignments, since they could otherwise narrow down the type of a variable from float to int. int values can still be implicitly converted to float when passed as arguments to functions that expect float values.

Note that mypyc still doesn’t support arrays of unboxed float values. Using list\[float\] involves heap-allocated float objects, since list can only store boxed values. Support for efficient floating point arrays is one of the next major planned mypyc features.

Related changes:

*   Use a native unboxed representation for floats (Jukka Lehtosalo, PR [14880](https://github.com/python/mypy/pull/14880))
*   Document native floats and integers (Jukka Lehtosalo, PR [14927](https://github.com/python/mypy/pull/14927))
*   Fixes to float to int conversion (Jukka Lehtosalo, PR [14936](https://github.com/python/mypy/pull/14936))

### Mypyc: Native Integers

Mypyc now supports signed 32-bit and 64-bit integer types in addition to the arbitrary-precision int type. You can use the types mypy\_extensions.i32 and mypy\_extensions.i64 to speed up code that uses integer operations heavily.

Simple example:
```python
from mypy_extensions import i64

def inc(x: i64) -> i64:
    return x + 1
```

Refer to the [documentation](https://mypyc.readthedocs.io/en/latest/using_type_annotations.html#native-integer-types) for more information. This feature was contributed by Jukka Lehtosalo.

### Other Mypyc Fixes and Improvements

*   Support iterating over a TypedDict (Richard Si, PR [14747](https://github.com/python/mypy/pull/14747))
*   Faster coercions between different tuple types (Jukka Lehtosalo, PR [14899](https://github.com/python/mypy/pull/14899))
*   Faster calls via type aliases (Jukka Lehtosalo, PR [14784](https://github.com/python/mypy/pull/14784))
*   Faster classmethod calls via cls (Jukka Lehtosalo, PR [14789](https://github.com/python/mypy/pull/14789))

### Fixes to Crashes

*   Fix crash on class-level import in protocol definition (Ivan Levkivskyi, PR [14926](https://github.com/python/mypy/pull/14926))
*   Fix crash on single item union of alias (Ivan Levkivskyi, PR [14876](https://github.com/python/mypy/pull/14876))
*   Fix crash on ParamSpec in incremental mode (Ivan Levkivskyi, PR [14885](https://github.com/python/mypy/pull/14885))

### Documentation Updates

*   Update adopting \--strict documentation for 1.0 (Shantanu, PR [14865](https://github.com/python/mypy/pull/14865))
*   Some minor documentation tweaks (Jukka Lehtosalo, PR [14847](https://github.com/python/mypy/pull/14847))
*   Improve documentation of top level mypy: disable-error-code comment (Nikita Sobolev, PR [14810](https://github.com/python/mypy/pull/14810))

### Error Reporting Improvements

*   Add error code to `typing_extensions` suggestion (Shantanu, PR [14881](https://github.com/python/mypy/pull/14881))
*   Add a separate error code for top-level await (Nikita Sobolev, PR [14801](https://github.com/python/mypy/pull/14801))
*   Don’t suggest two obsolete stub packages (Jelle Zijlstra, PR [14842](https://github.com/python/mypy/pull/14842))
*   Add suggestions for pandas-stubs and lxml-stubs (Shantanu, PR [14737](https://github.com/python/mypy/pull/14737))

### Other Fixes and Improvements

*   Multiple inheritance considers callable objects as subtypes of functions (Christoph Tyralla, PR [14855](https://github.com/python/mypy/pull/14855))
*   stubtest: Respect @final runtime decorator and enforce it in stubs (Nikita Sobolev, PR [14922](https://github.com/python/mypy/pull/14922))
*   Fix false positives related to type\[<type-var>\] (sterliakov, PR [14756](https://github.com/python/mypy/pull/14756))
*   Fix duplication of ParamSpec prefixes and properly substitute ParamSpecs (EXPLOSION, PR [14677](https://github.com/python/mypy/pull/14677))
*   Fix line number if `__iter__` is incorrectly reported as missing (Jukka Lehtosalo, PR [14893](https://github.com/python/mypy/pull/14893))
*   Fix incompatible overrides of overloaded generics with self types (Shantanu, PR [14882](https://github.com/python/mypy/pull/14882))
*   Allow SupportsIndex in slice expressions (Shantanu, PR [14738](https://github.com/python/mypy/pull/14738))
*   Support if statements in bodies of dataclasses and classes that use dataclass\_transform (Jacek Chałupka, PR [14854](https://github.com/python/mypy/pull/14854))
*   Allow iterable class objects to be unpacked (including enums) (Alex Waygood, PR [14827](https://github.com/python/mypy/pull/14827))
*   Fix narrowing for walrus expressions used in match statements (Shantanu, PR [14844](https://github.com/python/mypy/pull/14844))
*   Add signature for attr.evolve (Ilya Konstantinov, PR [14526](https://github.com/python/mypy/pull/14526))
*   Fix Any inference when unpacking iterators that don't directly inherit from typing.Iterator (Alex Waygood, PR [14821](https://github.com/python/mypy/pull/14821))
*   Fix unpack with overloaded `__iter__` method (Nikita Sobolev, PR [14817](https://github.com/python/mypy/pull/14817))
*   Reduce size of JSON data in mypy cache (dosisod, PR [14808](https://github.com/python/mypy/pull/14808))
*   Improve “used before definition” checks when a local definition has the same name as a global definition (Stas Ilinskiy, PR [14517](https://github.com/python/mypy/pull/14517))
*   Honor NoReturn as \_\_setitem\_\_ return type to mark unreachable code (sterliakov, PR [12572](https://github.com/python/mypy/pull/12572))

### Typeshed Updates

Typeshed is now modular and distributed as separate PyPI packages for everything except the standard library stubs. Please see [git log](https://github.com/python/typeshed/commits/main?after=a544b75320e97424d2d927605316383c755cdac0+0&branch=main&path=stdlib) for full list of typeshed changes.

### Acknowledgements

Thanks to all mypy contributors who contributed to this release:

*   Alex Waygood
*   Avasam
*   Christoph Tyralla
*   dosisod
*   EXPLOSION
*   Ilya Konstantinov
*   Ivan Levkivskyi
*   Jacek Chałupka
*   Jelle Zijlstra
*   Jukka Lehtosalo
*   Marc Mueller
*   Max Murin
*   Nikita Sobolev
*   Richard Si
*   Shantanu
*   Stas Ilinskiy
*   sterliakov
*   Wesley Collin Wright

Posted by Jukka Lehtosalo


## Mypy 1.1.1

[Monday, 6 March 2023](https://mypy-lang.blogspot.com/2023/03/mypy-111-released.html)

 We’ve just uploaded mypy 1.1.1 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### Support for `dataclass_transform``

This release adds full support for the dataclass\_transform decorator defined in [PEP 681](https://peps.python.org/pep-0681/#decorator-function-example). This allows decorators, base classes, and metaclasses that generate a \_\_init\_\_ method or other methods based on the properties of that class (similar to dataclasses) to have those methods recognized by mypy.

This was contributed by Wesley Collin Wright.

### Dedicated Error Code for Method Assignments

Mypy can’t safely check all assignments to methods (a form of monkey patching), so mypy generates an error by default. To make it easier to ignore this error, mypy now uses the new error code method-assign for this. By disabling this error code in a file or globally, mypy will no longer complain about assignments to methods if the signatures are compatible.

Mypy also supports the old error code assignment for these assignments to prevent a backward compatibility break. More generally, we can use this mechanism in the future if we wish to split or rename another existing error code without causing backward compatibility issues.

This was contributed by Ivan Levkivskyi (PR [14570](https://github.com/python/mypy/pull/14570)).

### Fixes to Crashes

*   Fix a crash on walrus in comprehension at class scope (Ivan Levkivskyi, PR [14556](https://github.com/python/mypy/pull/14556))
*   Fix crash related to value-constrained TypeVar (Shantanu, PR [14642](https://github.com/python/mypy/pull/14642))

### Fixes to Cache Corruption

*   Fix generic TypedDict/NamedTuple caching (Ivan Levkivskyi, PR [14675](https://github.com/python/mypy/pull/14675))

### Mypyc Fixes and Improvements

*   Raise "non-trait base must be first..." error less frequently (Richard Si, PR [14468](https://github.com/python/mypy/pull/14468))
*   Generate faster code for bool comparisons and arithmetic (Jukka Lehtosalo, PR [14489](https://github.com/python/mypy/pull/14489))
*   Optimize \_\_(a)enter\_\_/\_\_(a)exit\_\_ for native classes (Jared Hance, PR [14530](https://github.com/python/mypy/pull/14530))
*   Detect if attribute definition conflicts with base class/trait (Jukka Lehtosalo, PR [14535](https://github.com/python/mypy/pull/14535))
*   Support \_\_(r)divmod\_\_ dunders (Richard Si, PR [14613](https://github.com/python/mypy/pull/14613))
*   Support \_\_pow\_\_, \_\_rpow\_\_, and \_\_ipow\_\_ dunders (Richard Si, PR [14616](https://github.com/python/mypy/pull/14616))
*   Fix crash on star unpacking to underscore (Ivan Levkivskyi, PR [14624](https://github.com/python/mypy/pull/14624))
*   Fix iterating over a union of dicts (Richard Si, PR [14713](https://github.com/python/mypy/pull/14713))

### Fixes to Detecting Undefined Names (used-before-def)

*   Correctly handle walrus operator (Stas Ilinskiy, PR [14646](https://github.com/python/mypy/pull/14646))
*   Handle walrus declaration in match subject correctly (Stas Ilinskiy, PR [14665](https://github.com/python/mypy/pull/14665))

### Stubgen Improvements

Stubgen is a tool for automatically generating draft stubs for libraries.

*   Allow aliases below the top level (Chad Dombrova, PR [14388](https://github.com/python/mypy/pull/14388))
*   Fix crash with PEP 604 union in type variable bound (Shantanu, PR [14557](https://github.com/python/mypy/pull/14557))
*   Preserve PEP 604 unions in generated .pyi files (hamdanal, PR [14601](https://github.com/python/mypy/pull/14601))

### Stubtest Improvements

Stubtest is a tool for testing that stubs conform to the implementations.

*   Update message format so that it’s easier to go to error location (Avasam, PR [14437](https://github.com/python/mypy/pull/14437))
*   Handle name-mangling edge cases better (Alex Waygood, PR [14596](https://github.com/python/mypy/pull/14596))

### Changes to Error Reporting and Messages

*   Add new TypedDict error code typeddict-unknown-key (JoaquimEsteves, PR [14225](https://github.com/python/mypy/pull/14225))
*   Give arguments a more reasonable location in error messages (Max Murin, PR [14562](https://github.com/python/mypy/pull/14562))
*   In error messages, quote just the module's name (Ilya Konstantinov, PR [14567](https://github.com/python/mypy/pull/14567))
*   Improve misleading message about Enum() (Rodrigo Silva, PR [14590](https://github.com/python/mypy/pull/14590))
*   Suggest importing from `typing_extensions` if definition is not in typing (Shantanu, PR [14591](https://github.com/python/mypy/pull/14591))
*   Consistently use type-abstract error code (Ivan Levkivskyi, PR [14619](https://github.com/python/mypy/pull/14619))
*   Consistently use literal-required error code for TypedDicts (Ivan Levkivskyi, PR [14621](https://github.com/python/mypy/pull/14621))
*   Adjust inconsistent dataclasses plugin error messages (Wesley Collin Wright, PR [14637](https://github.com/python/mypy/pull/14637))
*   Consolidate literal bool argument error messages (Wesley Collin Wright, PR [14693](https://github.com/python/mypy/pull/14693))

### Other Fixes and Improvements

*   Check that type guards accept a positional argument (EXPLOSION, PR [14238](https://github.com/python/mypy/pull/14238))
*   Fix bug with in operator used with a union of Container and Iterable (Max Murin, PR [14384](https://github.com/python/mypy/pull/14384))
*   Support protocol inference for type\[T\] via metaclass (Ivan Levkivskyi, PR [14554](https://github.com/python/mypy/pull/14554))
*   Allow overlapping comparisons between bytes-like types (Shantanu, PR [14658](https://github.com/python/mypy/pull/14658))
*   Fix mypy daemon documentation link in README (Ivan Levkivskyi, PR [14644](https://github.com/python/mypy/pull/14644))

### Typeshed Updates

Typeshed is now modular and distributed as separate PyPI packages for everything except the standard library stubs. Please see [git log](https://github.com/python/typeshed/commits/main?after=5ebf892d0710a6e87925b8d138dfa597e7bb11cc+0&branch=main&path=stdlib) for full list of typeshed changes.

### Acknowledgements

Thanks to all mypy contributors who contributed to this release:

*   Alex Waygood
*   Avasam
*   Chad Dombrova
*   dosisod
*   EXPLOSION
*   hamdanal
*   Ilya Konstantinov
*   Ivan Levkivskyi
*   Jared Hance
*   JoaquimEsteves
*   Jukka Lehtosalo
*   Marc Mueller
*   Max Murin
*   Michael Lee
*   Michael R. Crusoe
*   Richard Si
*   Rodrigo Silva
*   Shantanu
*   Stas Ilinskiy
*   Wesley Collin Wright
*   Yilei "Dolee" Yang
*   Yurii Karabas

We’d also like to thank our employer, Dropbox, for funding the mypy core team.

Posted by Max Murin


## Mypy 1.0

[Monday, 6 February 2023](https://mypy-lang.blogspot.com/2023/02/mypy-10-released.html)

We’ve just uploaded mypy 1.0 to the Python Package Index ([PyPI](https://pypi.org/project/mypy/)). Mypy is a static type checker for Python. This release includes new features, performance improvements and bug fixes. You can install it as follows:

    python3 -m pip install -U mypy

You can read the full documentation for this release on [Read the Docs](http://mypy.readthedocs.io).

### New Release Versioning Scheme

Now that mypy reached 1.0, we’ll switch to a new versioning scheme. Mypy version numbers will be of form x.y.z.

Rules:

*   The major release number (x) is incremented if a feature release includes a significant backward incompatible change that affects a significant fraction of users.
*   The minor release number (y) is incremented on each feature release. Minor releases include updated stdlib stubs from typeshed.
*   The point release number (z) is incremented when there are fixes only.

Mypy doesn't use SemVer, since most minor releases have at least minor backward incompatible changes in typeshed, at the very least. Also, many type checking features find new legitimate issues in code. These are not considered backward incompatible changes, unless the number of new errors is very high.

Any significant backward incompatible change must be announced in the blog post for the previous feature release, before making the change. The previous release must also provide a flag to explicitly enable or disable the new behavior (whenever practical), so that users will be able to prepare for the changes and report issues. We should keep the feature flag for at least a few releases after we've switched the default.

See [”Release Process” in the mypy wiki](https://github.com/python/mypy/wiki/Release-Process) for more details and for the most up-to-date version of the versioning scheme.

### Performance Improvements

Mypy 1.0 is up to 40% faster than mypy 0.991 when type checking the Dropbox internal codebase. We also set up a daily job to measure the performance of the most recent development version of mypy to make it easier to track changes in performance.

Many optimizations contributed to this improvement:

*   Improve performance for errors on class with many attributes (Shantanu, PR [14379](https://github.com/python/mypy/pull/14379))
*   Speed up make\_simplified\_union (Jukka Lehtosalo, PR [14370](https://github.com/python/mypy/pull/14370))
*   Micro-optimize get\_proper\_type(s) (Jukka Lehtosalo, PR [14369](https://github.com/python/mypy/pull/14369))
*   Micro-optimize flatten\_nested\_unions (Jukka Lehtosalo, PR [14368](https://github.com/python/mypy/pull/14368))
*   Some semantic analyzer micro-optimizations (Jukka Lehtosalo, PR [14367](https://github.com/python/mypy/pull/14367))
*   A few miscellaneous micro-optimizations (Jukka Lehtosalo, PR [14366](https://github.com/python/mypy/pull/14366))
*   Optimization: Avoid a few uses of contextmanagers in semantic analyzer (Jukka Lehtosalo, PR [14360](https://github.com/python/mypy/pull/14360))
*   Optimization: Enable always defined attributes in Type subclasses (Jukka Lehtosalo, PR [14356](https://github.com/python/mypy/pull/14356))
*   Optimization: Remove expensive context manager in type analyzer (Jukka Lehtosalo, PR [14357](https://github.com/python/mypy/pull/14357))
*   subtypes: fast path for Union/Union subtype check (Hugues, PR [14277](https://github.com/python/mypy/pull/14277))
*   Micro-optimization: avoid Bogus\[int\] types that cause needless boxing (Jukka Lehtosalo, PR [14354](https://github.com/python/mypy/pull/14354))
*   Avoid slow error message logic if errors not shown to user (Jukka Lehtosalo, PR [14336](https://github.com/python/mypy/pull/14336))
*   Speed up the implementation of hasattr() checks (Jukka Lehtosalo, PR [14333](https://github.com/python/mypy/pull/14333))
*   Avoid the use of a context manager in hot code path (Jukka Lehtosalo, PR [14331](https://github.com/python/mypy/pull/14331))
*   Change various type queries into faster bool type queries (Jukka Lehtosalo, PR [14330](https://github.com/python/mypy/pull/14330))
*   Speed up recursive type check (Jukka Lehtosalo, PR [14326](https://github.com/python/mypy/pull/14326))
*   Optimize subtype checking by avoiding a nested function (Jukka Lehtosalo, PR [14325](https://github.com/python/mypy/pull/14325))
*   Optimize type parameter checks in subtype checking (Jukka Lehtosalo, PR [14324](https://github.com/python/mypy/pull/14324))
*   Speed up freshening type variables (Jukka Lehtosalo, PR [14323](https://github.com/python/mypy/pull/14323))
*   Optimize implementation of TypedDict types for \*\*kwds (Jukka Lehtosalo, PR [14316](https://github.com/python/mypy/pull/14316))

### Warn About Variables Used Before Definition

Mypy will now generate an error if you use a variable before it’s defined. This feature is enabled by default. By default mypy reports an error when it infers that a variable is always undefined.
```python
y = x  # E: Name "x" is used before definition [used-before-def]
x = 0
```
This feature was contributed by Stas Ilinskiy.

### Detect Possibly Undefined Variables (Experimental)

A new experimental possibly-undefined error code is now available that will detect variables that may be undefined:
```python
    if b:
        x = 0
    print(x)  # Error: Name "x" may be undefined [possibly-undefined]
```
The error code is disabled be default, since it can generate false positives.

This feature was contributed by Stas Ilinskiy.

### Support the “Self” Type

There is now a simpler syntax for declaring [generic self types](https://mypy.readthedocs.io/en/stable/generics.html#generic-methods-and-generic-self) introduced in [PEP 673](https://peps.python.org/pep-0673/): the Self type. You no longer have to define a type variable to use “self types”, and you can use them with attributes. Example from mypy documentation:
```python
from typing import Self

class Friend:
    other: Self | None = None

    @classmethod
    def make_pair(cls) -> tuple[Self, Self]:
        a, b = cls(), cls()
        a.other = b
        b.other = a
        return a, b

class SuperFriend(Friend):
    pass

# a and b have the inferred type "SuperFriend", not "Friend"
a, b = SuperFriend.make_pair()
```
The feature was introduced in Python 3.11. In earlier Python versions a backport of Self is available in `typing_extensions`.

This was contributed by Ivan Levkivskyi (PR [14041](https://github.com/python/mypy/pull/14041)).

### Support ParamSpec in Type Aliases

ParamSpec and Concatenate can now be used in type aliases. Example:
```python
from typing import ParamSpec, Callable

P = ParamSpec("P")
A = Callable[P, None]

def f(c: A[int, str]) -> None:
    c(1, "x")
```
This feature was contributed by Ivan Levkivskyi (PR [14159](https://github.com/python/mypy/pull/14159)).

### ParamSpec and Generic Self Types No Longer Experimental

Support for ParamSpec ([PEP 612](https://www.python.org/dev/peps/pep-0612/)) and generic self types are no longer considered experimental.

### Miscellaneous New Features

*   Minimal, partial implementation of dataclass\_transform ([PEP 681](https://peps.python.org/pep-0681/)) (Wesley Collin Wright, PR [14523](https://github.com/python/mypy/pull/14523))
*   Add basic support for `typing_extensions`.TypeVar (Marc Mueller, PR [14313](https://github.com/python/mypy/pull/14313))
*   Add \--debug-serialize option (Marc Mueller, PR [14155](https://github.com/python/mypy/pull/14155))
*   Constant fold initializers of final variables (Jukka Lehtosalo, PR [14283](https://github.com/python/mypy/pull/14283))
*   Enable Final instance attributes for attrs (Tin Tvrtković, PR [14232](https://github.com/python/mypy/pull/14232))
*   Allow function arguments as base classes (Ivan Levkivskyi, PR [14135](https://github.com/python/mypy/pull/14135))
*   Allow super() with mixin protocols (Ivan Levkivskyi, PR [14082](https://github.com/python/mypy/pull/14082))
*   Add type inference for dict.keys membership (Matthew Hughes, PR [13372](https://github.com/python/mypy/pull/13372))
*   Generate error for class attribute access if attribute is defined with `__slots__` (Harrison McCarty, PR [14125](https://github.com/python/mypy/pull/14125))
*   Support additional attributes in callback protocols (Ivan Levkivskyi, PR [14084](https://github.com/python/mypy/pull/14084))

### Fixes to Crashes

*   Fix crash on prefixed ParamSpec with forward reference (Ivan Levkivskyi, PR [14569](https://github.com/python/mypy/pull/14569))
*   Fix internal crash when resolving the same partial type twice (Shantanu, PR [14552](https://github.com/python/mypy/pull/14552))
*   Fix crash in daemon mode on new import cycle (Ivan Levkivskyi, PR [14508](https://github.com/python/mypy/pull/14508))
*   Fix crash in mypy daemon (Ivan Levkivskyi, PR [14497](https://github.com/python/mypy/pull/14497))
*   Fix crash on Any metaclass in incremental mode (Ivan Levkivskyi, PR [14495](https://github.com/python/mypy/pull/14495))
*   Fix crash in await inside comprehension outside function (Ivan Levkivskyi, PR [14486](https://github.com/python/mypy/pull/14486))
*   Fix crash in Self type on forward reference in upper bound (Ivan Levkivskyi, PR [14206](https://github.com/python/mypy/pull/14206))
*   Fix a crash when incorrect super() is used outside a method (Ivan Levkivskyi, PR [14208](https://github.com/python/mypy/pull/14208))
*   Fix crash on overriding with frozen attrs (Ivan Levkivskyi, PR [14186](https://github.com/python/mypy/pull/14186))
*   Fix incremental mode crash on generic function appearing in nested position (Ivan Levkivskyi, PR [14148](https://github.com/python/mypy/pull/14148))
*   Fix daemon crash on malformed NamedTuple (Ivan Levkivskyi, PR [14119](https://github.com/python/mypy/pull/14119))
*   Fix crash during ParamSpec inference (Ivan Levkivskyi, PR [14118](https://github.com/python/mypy/pull/14118))
*   Fix crash on nested generic callable (Ivan Levkivskyi, PR [14093](https://github.com/python/mypy/pull/14093))
*   Fix crashes with unpacking SyntaxError (Shantanu, PR [11499](https://github.com/python/mypy/pull/11499))
*   Fix crash on partial type inference within a lambda (Ivan Levkivskyi, PR [14087](https://github.com/python/mypy/pull/14087))
*   Fix crash with enums (Michael Lee, PR [14021](https://github.com/python/mypy/pull/14021))
*   Fix crash with malformed TypedDicts and disllow-any-expr (Michael Lee, PR [13963](https://github.com/python/mypy/pull/13963))

### Error Reporting Improvements

*   More helpful error for missing self (Shantanu, PR [14386](https://github.com/python/mypy/pull/14386))
*   Add error-code truthy-iterable (Marc Mueller, PR [13762](https://github.com/python/mypy/pull/13762))
*   Fix pluralization in error messages (KotlinIsland, PR [14411](https://github.com/python/mypy/pull/14411))

### Mypyc: Support Match Statement

Mypyc can now compile Python 3.10 match statements.

This was contributed by dosisod (PR [13953](https://github.com/python/mypy/pull/13953)).

### Other Mypyc Fixes and Improvements

*   Optimize int(x)/float(x)/complex(x) on instances of native classes (Richard Si, PR [14450](https://github.com/python/mypy/pull/14450))
*   Always emit warnings (Richard Si, PR [14451](https://github.com/python/mypy/pull/14451))
*   Faster bool and integer conversions (Jukka Lehtosalo, PR [14422](https://github.com/python/mypy/pull/14422))
*   Support attributes that override properties (Jukka Lehtosalo, PR [14377](https://github.com/python/mypy/pull/14377))
*   Precompute set literals for "in" operations and iteration (Richard Si, PR [14409](https://github.com/python/mypy/pull/14409))
*   Don't load targets with forward references while setting up non-extension class `__all__` (Richard Si, PR [14401](https://github.com/python/mypy/pull/14401))
*   Compile away NewType type calls (Richard Si, PR [14398](https://github.com/python/mypy/pull/14398))
*   Improve error message for multiple inheritance (Joshua Bronson, PR [14344](https://github.com/python/mypy/pull/14344))
*   Simplify union types (Jukka Lehtosalo, PR [14363](https://github.com/python/mypy/pull/14363))
*   Fixes to union simplification (Jukka Lehtosalo, PR [14364](https://github.com/python/mypy/pull/14364))
*   Fix for typeshed changes to Collection (Shantanu, PR [13994](https://github.com/python/mypy/pull/13994))
*   Allow use of enum.Enum (Shantanu, PR [13995](https://github.com/python/mypy/pull/13995))
*   Fix compiling on Arch Linux (dosisod, PR [13978](https://github.com/python/mypy/pull/13978))

### Documentation Improvements

*   Various documentation and error message tweaks (Jukka Lehtosalo, PR [14574](https://github.com/python/mypy/pull/14574))
*   Improve Generics documentation (Shantanu, PR [14587](https://github.com/python/mypy/pull/14587))
*   Improve protocols documentation (Shantanu, PR [14577](https://github.com/python/mypy/pull/14577))
*   Improve dynamic typing documentation (Shantanu, PR [14576](https://github.com/python/mypy/pull/14576))
*   Improve the Common Issues page (Shantanu, PR [14581](https://github.com/python/mypy/pull/14581))
*   Add a top-level TypedDict page (Shantanu, PR [14584](https://github.com/python/mypy/pull/14584))
*   More improvements to getting started documentation (Shantanu, PR [14572](https://github.com/python/mypy/pull/14572))
*   Move truthy-function documentation from “optional checks” to “enabled by default” (Anders Kaseorg, PR [14380](https://github.com/python/mypy/pull/14380))
*   Avoid use of implicit optional in decorator factory documentation (Tom Schraitle, PR [14156](https://github.com/python/mypy/pull/14156))
*   Clarify documentation surrounding install-types (Shantanu, PR [14003](https://github.com/python/mypy/pull/14003))
*   Improve searchability for module level type ignore errors (Shantanu, PR [14342](https://github.com/python/mypy/pull/14342))
*   Advertise mypy daemon in README (Ivan Levkivskyi, PR [14248](https://github.com/python/mypy/pull/14248))
*   Add link to error codes in README (Ivan Levkivskyi, PR [14249](https://github.com/python/mypy/pull/14249))
*   Document that report generation disables cache (Ilya Konstantinov, PR [14402](https://github.com/python/mypy/pull/14402))
*   Stop saying mypy is beta software (Ivan Levkivskyi, PR [14251](https://github.com/python/mypy/pull/14251))
*   Flycheck-mypy is deprecated, since its functionality was merged to Flycheck (Ivan Levkivskyi, PR [14247](https://github.com/python/mypy/pull/14247))
*   Update code example in "Declaring decorators" (ChristianWitzler, PR [14131](https://github.com/python/mypy/pull/14131))

### Stubtest Improvements

Stubtest is a tool for testing that stubs conform to the implementations.

*   Improve error message for `__all__`\-related errors (Alex Waygood, PR [14362](https://github.com/python/mypy/pull/14362))
*   Improve heuristics for determining whether global-namespace names are imported (Alex Waygood, PR [14270](https://github.com/python/mypy/pull/14270))
*   Catch BaseException on module imports (Shantanu, PR [14284](https://github.com/python/mypy/pull/14284))
*   Associate exported symbol error with `__all__` object\_path (Nikita Sobolev, PR [14217](https://github.com/python/mypy/pull/14217))
*   Add \_\_warningregistry\_\_ to the list of ignored module dunders (Nikita Sobolev, PR [14218](https://github.com/python/mypy/pull/14218))
*   If a default is present in the stub, check that it is correct (Jelle Zijlstra, PR [14085](https://github.com/python/mypy/pull/14085))

### Stubgen Improvements

Stubgen is a tool for automatically generating draft stubs for libraries.

*   Treat dlls as C modules (Shantanu, PR [14503](https://github.com/python/mypy/pull/14503))

### Other Notable Fixes and Improvements

*   Update stub suggestions based on recent typeshed changes (Alex Waygood, PR [14265](https://github.com/python/mypy/pull/14265))
*   Fix attrs protocol check with cache (Marc Mueller, PR [14558](https://github.com/python/mypy/pull/14558))
*   Fix strict equality check if operand item type has custom \_\_eq\_\_ (Jukka Lehtosalo, PR [14513](https://github.com/python/mypy/pull/14513))
*   Don't consider object always truthy (Jukka Lehtosalo, PR [14510](https://github.com/python/mypy/pull/14510))
*   Properly support union of TypedDicts as dict literal context (Ivan Levkivskyi, PR [14505](https://github.com/python/mypy/pull/14505))
*   Properly expand type in generic class with Self and TypeVar with values (Ivan Levkivskyi, PR [14491](https://github.com/python/mypy/pull/14491))
*   Fix recursive TypedDicts/NamedTuples defined with call syntax (Ivan Levkivskyi, PR [14488](https://github.com/python/mypy/pull/14488))
*   Fix type inference issue when a class inherits from Any (Shantanu, PR [14404](https://github.com/python/mypy/pull/14404))
*   Fix false positive on generic base class with six (Ivan Levkivskyi, PR [14478](https://github.com/python/mypy/pull/14478))
*   Don't read scripts without extensions as modules in namespace mode (Tim Geypens, PR [14335](https://github.com/python/mypy/pull/14335))
*   Fix inference for constrained type variables within unions (Christoph Tyralla, PR [14396](https://github.com/python/mypy/pull/14396))
*   Fix Unpack imported from typing (Marc Mueller, PR [14378](https://github.com/python/mypy/pull/14378))
*   Allow trailing commas in ini configuration of multiline values (Nikita Sobolev, PR [14240](https://github.com/python/mypy/pull/14240))
*   Fix false negatives involving Unions and generators or coroutines (Shantanu, PR [14224](https://github.com/python/mypy/pull/14224))
*   Fix ParamSpec constraint for types as callable (Vincent Vanlaer, PR [14153](https://github.com/python/mypy/pull/14153))
*   Fix type aliases with fixed-length tuples (Jukka Lehtosalo, PR [14184](https://github.com/python/mypy/pull/14184))
*   Fix issues with type aliases and new style unions (Jukka Lehtosalo, PR [14181](https://github.com/python/mypy/pull/14181))
*   Simplify unions less aggressively (Ivan Levkivskyi, PR [14178](https://github.com/python/mypy/pull/14178))
*   Simplify callable overlap logic (Ivan Levkivskyi, PR [14174](https://github.com/python/mypy/pull/14174))
*   Try empty context when assigning to union typed variables (Ivan Levkivskyi, PR [14151](https://github.com/python/mypy/pull/14151))
*   Improvements to recursive types (Ivan Levkivskyi, PR [14147](https://github.com/python/mypy/pull/14147))
*   Make non-numeric non-empty FORCE\_COLOR truthy (Shantanu, PR [14140](https://github.com/python/mypy/pull/14140))
*   Fix to recursive type aliases (Ivan Levkivskyi, PR [14136](https://github.com/python/mypy/pull/14136))
*   Correctly handle Enum name on Python 3.11 (Ivan Levkivskyi, PR [14133](https://github.com/python/mypy/pull/14133))
*   Fix class objects falling back to metaclass for callback protocol (Ivan Levkivskyi, PR [14121](https://github.com/python/mypy/pull/14121))
*   Correctly support self types in callable ClassVar (Ivan Levkivskyi, PR [14115](https://github.com/python/mypy/pull/14115))
*   Fix type variable clash in nested positions and in attributes (Ivan Levkivskyi, PR [14095](https://github.com/python/mypy/pull/14095))
*   Allow class variable as implementation for read only attribute (Ivan Levkivskyi, PR [14081](https://github.com/python/mypy/pull/14081))
*   Prevent warnings from causing dmypy to fail (Andrzej Bartosiński, PR [14102](https://github.com/python/mypy/pull/14102))
*   Correctly process nested definitions in mypy daemon (Ivan Levkivskyi, PR [14104](https://github.com/python/mypy/pull/14104))
*   Don't consider a branch unreachable if there is a possible promotion (Ivan Levkivskyi, PR [14077](https://github.com/python/mypy/pull/14077))
*   Fix incompatible overrides of overloaded methods in concrete subclasses (Shantanu, PR [14017](https://github.com/python/mypy/pull/14017))
*   Fix new style union syntax in type aliases (Jukka Lehtosalo, PR [14008](https://github.com/python/mypy/pull/14008))
*   Fix and optimise overload compatibility checking (Shantanu, PR [14018](https://github.com/python/mypy/pull/14018))
*   Improve handling of redefinitions through imports (Shantanu, PR [13969](https://github.com/python/mypy/pull/13969))
*   Preserve (some) implicitly exported types (Shantanu, PR [13967](https://github.com/python/mypy/pull/13967))

### Typeshed Updates

Typeshed is now modular and distributed as separate PyPI packages for everything except the standard library stubs. Please see [git log](https://github.com/python/typeshed/commits/main?after=ea0ae2155e8a04c9837903c3aff8dd5ad5f36ebc+0&branch=main&path=stdlib) for full list of typeshed changes.

### Acknowledgements

Thanks to all mypy contributors who contributed to this release:

*   Alessio Izzo
*   Alex Waygood
*   Anders Kaseorg
*   Andrzej Bartosiński
*   Avasam
*   ChristianWitzler
*   Christoph Tyralla
*   dosisod
*   Harrison McCarty
*   Hugo van Kemenade
*   Hugues
*   Ilya Konstantinov
*   Ivan Levkivskyi
*   Jelle Zijlstra
*   jhance
*   johnthagen
*   Jonathan Daniel
*   Joshua Bronson
*   Jukka Lehtosalo
*   KotlinIsland
*   Lakshay Bisht
*   Lefteris Karapetsas
*   Marc Mueller
*   Matthew Hughes
*   Michael Lee
*   Nick Drozd
*   Nikita Sobolev
*   Richard Si
*   Shantanu
*   Stas Ilinskiy
*   Tim Geypens
*   Tin Tvrtković
*   Tom Schraitle
*   Valentin Stanciu
*   Vincent Vanlaer

We’d also like to thank our employer, Dropbox, for funding the mypy core team.

Posted by Stas Ilinskiy

## Previous releases

For information about previous releases, refer to the posts at https://mypy-lang.blogspot.com/


---

CONTRIBUTING.md

---

# Contributing to Mypy

Welcome!  Mypy is a community project that aims to work for a wide
range of Python users and Python codebases.  If you're trying mypy on
your Python code, your experience and what you can contribute are
important to the project's success.

## Code of Conduct

Everyone participating in the Mypy community, and in particular in our
issue tracker, pull requests, and chat, is expected to treat
other people with respect and more generally to follow the guidelines
articulated in the [Python Community Code of Conduct](https://www.python.org/psf/codeofconduct/).

## Getting started with development

### Setup

#### (1) Fork the mypy repository

Within Github, navigate to <https://github.com/python/mypy> and fork the repository.

#### (2) Clone the mypy repository and enter into it

```bash
git clone git@github.com:<your_username>/mypy.git
cd mypy
```

#### (3) Create then activate a virtual environment

```bash
python3 -m venv venv
source venv/bin/activate
```

```bash
# For Windows use
python -m venv venv
. venv/Scripts/activate

# For more details, see https://docs.python.org/3/library/venv.html#creating-virtual-environments
```

#### (4) Install the test requirements and the project

```bash
python -m pip install -r test-requirements.txt
python -m pip install -e .
hash -r  # This resets shell PATH cache, not necessary on Windows
```

> **Note**
> You'll need Python 3.8 or higher to install all requirements listed in
> test-requirements.txt

### Running tests

Running the full test suite can take a while, and usually isn't necessary when
preparing a PR. Once you file a PR, the full test suite will run on GitHub.
You'll then be able to see any test failures, and make any necessary changes to
your PR.

However, if you wish to do so, you can run the full test suite
like this:

```bash
python runtests.py
```

Some useful commands for running specific tests include:

```bash
# Use mypy to check mypy's own code
python runtests.py self
# or equivalently:
python -m mypy --config-file mypy_self_check.ini -p mypy

# Run a single test from the test suite
pytest -n0 -k 'test_name'

# Run all test cases in the "test-data/unit/check-dataclasses.test" file
pytest mypy/test/testcheck.py::TypeCheckSuite::check-dataclasses.test

# Run the formatters and linters
python runtests.py lint
```

For an in-depth guide on running and writing tests,
see [the README in the test-data directory](test-data/unit/README.md).

#### Using `tox`

You can also use [`tox`](https://tox.wiki/en/latest/) to run tests and other commands.
`tox` handles setting up test environments for you.

```bash
# Run tests
tox run -e py

# Run tests using some specific Python version
tox run -e py311

# Run a specific command
tox run -e lint

# Run a single test from the test suite
tox run -e py -- -n0 -k 'test_name'

# Run all test cases in the "test-data/unit/check-dataclasses.test" file using
# Python 3.11 specifically
tox run -e py311 -- mypy/test/testcheck.py::TypeCheckSuite::check-dataclasses.test

# Set up a development environment with all the project libraries and run a command
tox -e dev -- mypy --verbose test_case.py
tox -e dev --override testenv:dev.allowlist_externals+=env -- env  # inspect the environment
```

If you don't already have `tox` installed, you can use a virtual environment as
described above to install `tox` via `pip` (e.g., ``python -m pip install tox``).

## First time contributors

If you're looking for things to help with, browse our [issue tracker](https://github.com/python/mypy/issues)!

In particular, look for:

- [good first issues](https://github.com/python/mypy/labels/good-first-issue)
- [good second issues](https://github.com/python/mypy/labels/good-second-issue)
- [documentation issues](https://github.com/python/mypy/labels/documentation)

You do not need to ask for permission to work on any of these issues.
Just fix the issue yourself, [try to add a unit test](#running-tests) and
[open a pull request](#submitting-changes).

To get help fixing a specific issue, it's often best to comment on the issue
itself. You're much more likely to get help if you provide details about what
you've tried and where you've looked (maintainers tend to help those who help
themselves). [gitter](https://gitter.im/python/typing) can also be a good place
to ask for help.

Interactive debuggers like `pdb` and `ipdb` are really useful for getting
started with the mypy codebase. This is a
[useful tutorial](https://realpython.com/python-debugging-pdb/).

It's also extremely easy to get started contributing to our sister project
[typeshed](https://github.com/python/typeshed/issues) that provides type stubs
for libraries. This is a great way to become familiar with type syntax.

## Submitting changes

Even more excellent than a good bug report is a fix for a bug, or the
implementation of a much-needed new feature. We'd love to have
your contributions.

We use the usual GitHub pull-request flow, which may be familiar to
you if you've contributed to other projects on GitHub.  For the mechanics,
see [our git and GitHub workflow help page](https://github.com/python/mypy/wiki/Using-Git-And-GitHub),
or [GitHub's own documentation](https://help.github.com/articles/using-pull-requests/).

Anyone interested in Mypy may review your code.  One of the Mypy core
developers will merge your pull request when they think it's ready.

If your change will be a significant amount of work
to write, we highly recommend starting by opening an issue laying out
what you want to do.  That lets a conversation happen early in case
other contributors disagree with what you'd like to do or have ideas
that will help you do it.

The best pull requests are focused, clearly describe what they're for
and why they're correct, and contain tests for whatever changes they
make to the code's behavior.  As a bonus these are easiest for someone
to review, which helps your pull request get merged quickly!  Standard
advice about good pull requests for open-source projects applies; we
have [our own writeup](https://github.com/python/mypy/wiki/Good-Pull-Request)
of this advice.

Also, do not squash your commits after you have submitted a pull request, as this
erases context during review. We will squash commits when the pull request is merged.

You may also find other pages in the
[Mypy developer guide](https://github.com/python/mypy/wiki/Developer-Guides)
helpful in developing your change.

## Core developer guidelines

Core developers should follow these rules when processing pull requests:

- Always wait for tests to pass before merging PRs.
- Use "[Squash and merge](https://github.com/blog/2141-squash-your-commits)"
  to merge PRs.
- Delete branches for merged PRs (by core devs pushing to the main repo).
- Edit the final commit message before merging to conform to the following
  style (we wish to have a clean `git log` output):
  - When merging a multi-commit PR make sure that the commit message doesn't
    contain the local history from the committer and the review history from
    the PR. Edit the message to only describe the end state of the PR.
  - Make sure there is a *single* newline at the end of the commit message.
    This way there is a single empty line between commits in `git log`
    output.
  - Split lines as needed so that the maximum line length of the commit
    message is under 80 characters, including the subject line.
  - Capitalize the subject and each paragraph.
  - Make sure that the subject of the commit message has no trailing dot.
  - Use the imperative mood in the subject line (e.g. "Fix typo in README").
  - If the PR fixes an issue, make sure something like "Fixes #xxx." occurs
    in the body of the message (not in the subject).
  - Use Markdown for formatting.


---

README.md

---

<img src="docs/source/mypy_light.svg" alt="mypy logo" width="300px"/>

Mypy: Static Typing for Python
=======================================

[![Stable Version](https://img.shields.io/pypi/v/mypy?color=blue)](https://pypi.org/project/mypy/)
[![Downloads](https://img.shields.io/pypi/dm/mypy)](https://pypistats.org/packages/mypy)
[![Build Status](https://github.com/python/mypy/actions/workflows/test.yml/badge.svg)](https://github.com/python/mypy/actions)
[![Documentation Status](https://readthedocs.org/projects/mypy/badge/?version=latest)](https://mypy.readthedocs.io/en/latest/?badge=latest)
[![Chat at https://gitter.im/python/typing](https://badges.gitter.im/python/typing.svg)](https://gitter.im/python/typing?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
[![Checked with mypy](https://www.mypy-lang.org/static/mypy_badge.svg)](https://mypy-lang.org/)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
[![Linting: Ruff](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/charliermarsh/ruff/main/assets/badge/v2.json)](https://github.com/astral-sh/ruff)

Got a question?
---------------

We are always happy to answer questions! Here are some good places to ask them:

- for anything you're curious about, try [gitter chat](https://gitter.im/python/typing)
- for general questions about Python typing, try [typing discussions](https://github.com/python/typing/discussions)

If you're just getting started,
[the documentation](https://mypy.readthedocs.io/en/stable/index.html)
and [type hints cheat sheet](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html)
can also help answer questions.

If you think you've found a bug:

- check our [common issues page](https://mypy.readthedocs.io/en/stable/common_issues.html)
- search our [issue tracker](https://github.com/python/mypy/issues) to see if
  it's already been reported
- consider asking on [gitter chat](https://gitter.im/python/typing)

To report a bug or request an enhancement:

- report at [our issue tracker](https://github.com/python/mypy/issues)
- if the issue is with a specific library or function, consider reporting it at
  [typeshed tracker](https://github.com/python/typeshed/issues) or the issue
  tracker for that library

To discuss a new type system feature:

- discuss at [discuss.python.org](https://discuss.python.org/c/typing/32)
- there is also some historical discussion at the [typing-sig mailing list](https://mail.python.org/archives/list/typing-sig@python.org/) and the [python/typing repo](https://github.com/python/typing/issues)

What is mypy?
-------------

Mypy is a static type checker for Python.

Type checkers help ensure that you're using variables and functions in your code
correctly. With mypy, add type hints ([PEP 484](https://www.python.org/dev/peps/pep-0484/))
to your Python programs, and mypy will warn you when you use those types
incorrectly.

Python is a dynamic language, so usually you'll only see errors in your code
when you attempt to run it. Mypy is a *static* checker, so it finds bugs
in your programs without even running them!

Here is a small example to whet your appetite:

```python
number = input("What is your favourite number?")
print("It is", number + 1)  # error: Unsupported operand types for + ("str" and "int")
```

Adding type hints for mypy does not interfere with the way your program would
otherwise run. Think of type hints as similar to comments! You can always use
the Python interpreter to run your code, even if mypy reports errors.

Mypy is designed with gradual typing in mind. This means you can add type
hints to your code base slowly and that you can always fall back to dynamic
typing when static typing is not convenient.

Mypy has a powerful and easy-to-use type system, supporting features such as
type inference, generics, callable types, tuple types, union types,
structural subtyping and more. Using mypy will make your programs easier to
understand, debug, and maintain.

See [the documentation](https://mypy.readthedocs.io/en/stable/index.html) for
more examples and information.

In particular, see:

- [type hints cheat sheet](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html)
- [getting started](https://mypy.readthedocs.io/en/stable/getting_started.html)
- [list of error codes](https://mypy.readthedocs.io/en/stable/error_code_list.html)

Quick start
-----------

Mypy can be installed using pip:

```bash
python3 -m pip install -U mypy
```

If you want to run the latest version of the code, you can install from the
repo directly:

```bash
python3 -m pip install -U git+https://github.com/python/mypy.git
# or if you don't have 'git' installed
python3 -m pip install -U https://github.com/python/mypy/zipball/master
```

Now you can type-check the [statically typed parts] of a program like this:

```bash
mypy PROGRAM
```

You can always use the Python interpreter to run your statically typed
programs, even if mypy reports type errors:

```bash
python3 PROGRAM
```

You can also try mypy in an [online playground](https://mypy-play.net/) (developed by
Yusuke Miyazaki). If you are working with large code bases, you can run mypy in
[daemon mode], that will give much faster (often sub-second) incremental updates:

```bash
dmypy run -- PROGRAM
```

[statically typed parts]: https://mypy.readthedocs.io/en/latest/getting_started.html#function-signatures-and-dynamic-vs-static-typing
[daemon mode]: https://mypy.readthedocs.io/en/stable/mypy_daemon.html

Integrations
------------

Mypy can be integrated into popular IDEs:

- Vim:
  - Using [Syntastic](https://github.com/vim-syntastic/syntastic): in `~/.vimrc` add
    `let g:syntastic_python_checkers=['mypy']`
  - Using [ALE](https://github.com/dense-analysis/ale): should be enabled by default when `mypy` is installed,
    or can be explicitly enabled by adding `let b:ale_linters = ['mypy']` in `~/vim/ftplugin/python.vim`
- Emacs: using [Flycheck](https://github.com/flycheck/)
- Sublime Text: [SublimeLinter-contrib-mypy](https://github.com/fredcallaway/SublimeLinter-contrib-mypy)
- Atom: [linter-mypy](https://atom.io/packages/linter-mypy)
- PyCharm: [mypy plugin](https://github.com/dropbox/mypy-PyCharm-plugin) (PyCharm integrates
  [its own implementation](https://www.jetbrains.com/help/pycharm/type-hinting-in-product.html) of [PEP 484](https://peps.python.org/pep-0484/))
- VS Code: provides [basic integration](https://code.visualstudio.com/docs/python/linting#_mypy) with mypy.
- pre-commit: use [pre-commit mirrors-mypy](https://github.com/pre-commit/mirrors-mypy).

Web site and documentation
--------------------------

Additional information is available at the web site:

  <https://www.mypy-lang.org/>

Jump straight to the documentation:

  <https://mypy.readthedocs.io/>

Follow along our changelog at:

  <https://mypy-lang.blogspot.com/>

Contributing
------------

Help in testing, development, documentation and other tasks is
highly appreciated and useful to the project. There are tasks for
contributors of all experience levels.

To get started with developing mypy, see [CONTRIBUTING.md](CONTRIBUTING.md).

If you need help getting started, don't hesitate to ask on [gitter](https://gitter.im/python/typing).

Mypyc and compiled version of mypy
----------------------------------

[Mypyc](https://github.com/mypyc/mypyc) uses Python type hints to compile Python
modules to faster C extensions. Mypy is itself compiled using mypyc: this makes
mypy approximately 4 times faster than if interpreted!

To install an interpreted mypy instead, use:

```bash
python3 -m pip install --no-binary mypy -U mypy
```

To use a compiled version of a development
version of mypy, directly install a binary from
<https://github.com/mypyc/mypy_mypyc-wheels/releases/latest>.

To contribute to the mypyc project, check out <https://github.com/mypyc/mypyc>


---

build-requirements.txt

---

# NOTE: this needs to be kept in sync with the "requires" list in pyproject.toml
-r mypy-requirements.txt
types-psutil
types-setuptools


---

mypy-requirements.txt

---

# NOTE: this needs to be kept in sync with the "requires" list in pyproject.toml
# and the pins in setup.py
typing_extensions>=4.6.0
mypy_extensions>=1.0.0
tomli>=1.1.0; python_version<'3.11'


---

test-requirements.txt

---

#
# This file is autogenerated by pip-compile with Python 3.11
# by the following command:
#
#    pip-compile --allow-unsafe --output-file=test-requirements.txt --strip-extras test-requirements.in
#
attrs==24.2.0
    # via -r test-requirements.in
cfgv==3.4.0
    # via pre-commit
coverage==7.6.1
    # via pytest-cov
distlib==0.3.9
    # via virtualenv
execnet==2.1.1
    # via pytest-xdist
filelock==3.16.1
    # via
    #   -r test-requirements.in
    #   virtualenv
identify==2.6.1
    # via pre-commit
iniconfig==2.0.0
    # via pytest
lxml==4.9.2 ; (python_version < "3.11" or sys_platform != "win32") and python_version < "3.12"
    # via -r test-requirements.in
mypy-extensions==1.0.0
    # via -r mypy-requirements.txt
nodeenv==1.9.1
    # via pre-commit
packaging==24.1
    # via pytest
platformdirs==4.3.6
    # via virtualenv
pluggy==1.5.0
    # via pytest
pre-commit==3.5.0
    # via -r test-requirements.in
psutil==6.0.0
    # via -r test-requirements.in
pytest==8.3.3
    # via
    #   -r test-requirements.in
    #   pytest-cov
    #   pytest-xdist
pytest-cov==5.0.0
    # via -r test-requirements.in
pytest-xdist==3.6.1
    # via -r test-requirements.in
pyyaml==6.0.2
    # via pre-commit
tomli==2.0.2
    # via -r test-requirements.in
types-psutil==6.0.0.20241011
    # via -r build-requirements.txt
types-setuptools==75.1.0.20241014
    # via -r build-requirements.txt
typing-extensions==4.12.2
    # via -r mypy-requirements.txt
virtualenv==20.26.6
    # via pre-commit

# The following packages are considered to be unsafe in a requirements file:
setuptools==75.1.0
    # via -r test-requirements.in
